<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[篮球赛后]]></title>
    <url>%2F2019%2F05%2Fyuque%2Flundx2%2F</url>
    <content type="text"><![CDATA[description: …categories: Life 概述准备了一年的篮球赛落下帷幕，今年和去年一样开了个好头，去年上场两分钟，今年 5 场比赛 2 替补 3 首发，得了 4 分。 场下篮球，一直都是激烈而残酷的，这一很大程度靠天赋决定实力的竞技体育，让我一度想回到伪球迷的闲适时光。虽然我们一直嘴里嚷着欢乐篮球，但是谁不想赢得比赛，谁又不想出线，走向下一轮呢？去年的比赛仅仅赢了一场，今年的锦鲤签打到现在也只是赢了一场，并且出线已然无望。相较于去年，走了一届，来了一届，但新一届学生的确没有什么技术，很不成熟，根本无法上场。所以我们知道我们需要更加努力，好在我们这群家伙里面有一个想打 CUBA 的，进入了校队，不然我们这一届会崩的很难看。想到之前的早训、晚训还有随意出去约的投篮、斗牛。备赛期间，觉是不可能睡好的，你每天醒来，脑子里面都是篮球，那才是正确的。不过我知道，比我压力大，比我更忙的人不在少数。我前面的队长，为了留学，东奔西走，却也把托福和球赛一起抗在肩上，现在在写论文，还怪我约球没有叫他。每个人都很辛苦，但有些人终究是上不了场。我们院篮球人才稀缺，我想只要是想打球的，熬两年总是能体验一下正式比赛的快乐的，不想工学院这些底蕴深厚的院，球技很不错，却也上不了场。 场上第一场比赛和第二场比赛我记得比较清楚，和外院的比赛最终只有一分之差，在我上场的时间内，我只能说自己一直在坐晕车，也没有丝毫经验，被人造了三分犯规，他妈的还防守不积极。第二场园林分差较大，但是我学到的经验最多，他们的后卫和锋线都很快，我对位后卫的时候让我明白，什么是用身体和脑子来防守。内线要贴紧，对于我们这种比赛，外线换防和单防都要留一定的空间，防突而放投。至于进攻，我的突破今年完全就是零，只靠快攻得了仅有的 4 分，而投篮只能有抛投和跳投，跳投是不敢投的，抛投又太短，5 场比赛的三分球又全部未中，只能说自己的提升空间太大了（滑稽），当然防守用的是经验和体力，进攻就要靠基本功和脑子了，至于视野，先多看比赛培养，然后再实战结合吧，视野这种东西我觉得自己还是有机会练出来的，毕竟以前冲动是能进球，而现在强度变大，我不再是予取予求的球员，自然会多考虑给别人做球。 定位和总结明年估计我还是和现在一样 1、2 号位傻傻分不清楚，所以定位就是要有视野、有基本功、有脑子、有经验。其实我觉得 CS 和打球如果能兼顾得好，会是一个有益身心的明智选择（逃），奈何自己太菜，感觉这两方面要做的都很多，当然 CS 做的要更多，毕竟篮球对于我只是爱好， CS 才是职业，以后能工作之余，打一下养身篮球，想必是极好的。 明年，我希望全员健康，不辜负自己的希冀，给其他院队一些惊喜（也是给自己一个交代），加油！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 配置ssr(酸酸乳)]]></title>
    <url>%2F2019%2F03%2Fyuque%2Ftsw1x0%2F</url>
    <content type="text"><![CDATA[告别扩展，拥抱酸酸乳 概述Ubuntu18.04也已经告别了 ss 和 ssr 的命令行界面(或许早就告别了但是现在才知道)，迎来了配置 ss 或者 ssr 的图形化界面，对于我这样的小白简直不能太友好。 下载安装 electron-ssr 或者 shadowsocks-qt5下载可以去github：electron-ssrshadowsocks-qt5也可以从我的分享里下载（母鸡为何要科学上网才能看到）:electron-ssr-0.2.6.AppImageShadowsocks-Qt5-3.0.1-x86_64.AppImage安装就是命令行下面赋予执行权限后双击一下图标，例如 electron-ssr1chmod a+x electron-ssr-0.2.6.AppImage electron-ssr 打开之后的界面（这里就不给主页面了，你懂的）Shadowsocks-Qt5 配置完成后打开的界面：这边安利一下 electron-ssr ，没啥原因，就是页面好看，配置方便。 ssr 配置参考 github 上给出的方法shadowsocks-qt5electron-ssr 配置 SwitchyOmega auto switch在 Chrome 浏览器中配置完毕如下 关于如何使用 SwitchyOmega,参考:https://blog.csdn.net/u010658816/article/details/85782272 ，配置完毕不影响访问网站，同时一定程度上节省了流量。火狐浏览器同样下载此插件进行同样的操作，但是要正常访问可能要关闭 PAC 代理，这个问题之后再解决吧，实际上就是因为菜。通过 vimcaw 的个人博客，初步判断和下图的两层判断的 PAC 文件起了冲突。~~ 总结关于订阅，就要靠自己去找或者去买了，本篇教程面对小白，纯属技术交流，如有不妥之处，望指出。如果有需要，可以留言或者私聊，我会尽力解答。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周会分享]]></title>
    <url>%2F2019%2F03%2Fyuque%2Frcibso%2F</url>
    <content type="text"><![CDATA[脚本使用 概述脚本最重要的体验就是方便。如果能有一些基础，高度定制自己的工作环境，是一种很不错的体验。如果自己总是会出问题，那么做好备份就很重要。一般来说，我们很少要编写脚本文件，除非自己的系统崩了，或者有一些小的繁琐的事情需要不断重复。我们可以直接对别人的脚本进行修改，然后就可以达到一键执行的效果。 学习资料W3Cschool：https://www.w3cschool.cn/linux/linux-shell-variable.html语雀链接：https://www.yuque.com/allenlei/ia7uhw/edyrfz b站链接：https://www.bilibili.com/video/av17384556实验楼链接：https://www.shiyanlou.com/courses/944 读一下 Linux 命令行与shell脚本编程大全和 Linux shell 脚本攻略Linux命令行与shell脚本编程大全.pdf 实例用处 dos 清除图标缓存12345678910111213141516171819202122232425262728293031@ECHO OFF&amp;PUSHD %~DP0 &amp;TITLE 清理系统图标缓存mode con cols=46 lines=26color 2F&gt;NUL 2&gt;&amp;1 REG.exe query "HKU\S-1-5-19" || ( ECHO SET UAC = CreateObject^("Shell.Application"^) &gt; "%TEMP%\Getadmin.vbs" ECHO UAC.ShellExecute "%~f0", "%1", "", "runas", 1 &gt;&gt; "%TEMP%\Getadmin.vbs" "%TEMP%\Getadmin.vbs" DEL /f /q "%TEMP%\Getadmin.vbs" 2&gt;NUL Exit /b)echo 按任意键开始，或者关闭本窗口 &amp; pause&gt;nulrem 结束Windows资源管理器explorertaskkill /f /im explorer.exerem 清理系统图标缓存数据库attrib -h -s -r "%userprofile%\AppData\Local\IconCache.db"del /f "%userprofile%\AppData\Local\IconCache.db"attrib /s /d -h -s -r "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\*"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_32.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_96.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_102.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_256.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_1024.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_idx.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_sr.db"rem 清理系统托盘记忆的图标echo y|reg delete "HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify" /v IconStreamsecho y|reg delete "HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify" /v PastIconsStreamrem 重启Windows资源管理器explorerstart explorerecho 执行完成！按任意键退出 &amp; pause&gt;nulexit 删除指定盘符下的空文件夹1234567891011121314151617181920ECHO OFF&amp;PUSHD %~DP0 &amp;TITLE 删除空文件夹mode con cols=46 lines=26color 2F&gt;NUL 2&gt;&amp;1 REG.exe query "HKU\S-1-5-19" || ( ECHO SET UAC = CreateObject^("Shell.Application"^) &gt; "%TEMP%\Getadmin.vbs" ECHO UAC.ShellExecute "%~f0", "%1", "", "runas", 1 &gt;&gt; "%TEMP%\Getadmin.vbs" "%TEMP%\Getadmin.vbs" DEL /f /q "%TEMP%\Getadmin.vbs" 2&gt;NUL Exit /b)set /p var=请输入要清除的盘符（C盘需谨慎，多盘使用空格分开）：for %%i in (%var%) do (if exist %%i:\ (for /f "delims=" %%a in ('dir /ad /b /s "%%i:\"^|sort /r') do (rd "%%a")))echo 执行完成！按任意键退出 &amp; pause&gt;nulexit Shell alias永久生效：https://blog.51cto.com/feihan21/12129541234567891011121314151617alias sudo='sudo 'alias ll='ls -alF'alias la='ls -A'alias l='ls -CF'alias l.='ls -d .* --color=auto'alias nis="npm install --save "alias svim='sudo nvim'alias mkcd='foo()&#123; mkdir -p "$1"; cd "$1" &#125;; foo 'alias install='sudo apt get install'alias update='sudo apt-get update; sudo apt-get upgrade'alias ..="cd .."alias ...="cd ..; cd .."alias h='history'alias ports='netstat -tulanp'alias rm='rm -I --preserve-root'alias grep="grep --color"alias grepp="grep -P --color" alias 即可显示设置的命令，和git一个道理vim ~/.bash_aliases 加入适合的alias命令 引导https://coolshell.cn/articles/19219.html建议先使用 tldr 命令，然后也可以在 github 上找有趣的 shell 工具。检查脚本：https://www.shellcheck.net/ fish 和 zshhttp://www.ruanyifeng.com/blog/2017/05/fish_shell.htmlhttps://www.jianshu.com/p/bf03bce60987fish:12helpfish_config oh-my-fish 和 oh-my-zsh我给的是 oh-my-fishhttps://github.com/oh-my-fish/oh-my-fish/blob/master/docs/zh-CN/README.mdhttps://linux.cn/article-9515-1.htmlhttps://wiki.archlinux.org/index.php/Fish_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)) 推荐脚本最好使用开源的脚本，不要使用私人的脚本。简单的一键安装脚本：https://gitee.com/chang_501/ubuntu_system_installationUbuntu 一键安装的脚本：https://github.com/SickoOrange/UbuntuAutoScript一键安装deepin-wine脚本,可用于安装TIM,QQ,迅雷等软件：https://github.com/innoob/deepin-wine-installer一些 Ubuntu 上可能有用的软件: https://github.com/the0demiurge/CharlesScripts进阶的一些 Java 和shell 的脚本：https://github.com/oldratlee/useful-scripts]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 记录]]></title>
    <url>%2F2019%2F03%2Fyuque%2Fubuntu%2F</url>
    <content type="text"><![CDATA[从索引-&gt;驱动-&gt;备份-&gt;重新安装 概述自己的 Ubuntu18.04 索引无故罢工,帮助我小小学习回顾了一下 Ubuntu18.04 的一些注意事项以及一些硬件信息。 过程记录 罢工缘由索引通过 boot-repair 修复好，但是卡在了登录界面，解决登录问题，但是显然驱动有问题，网上教程安装驱动，结果忘了两行命令，所以就 gg 了。期间，遇到了（initramfs）， grub 界面，甚至连戴尔的安全助手都跳出来了。。。我智商被轮番碾压的滋味简直不要太酸爽。 修复过程乱七八糟的教程让我头都看大了，主要是参考网上各种方法，结果越搞越乱。这边主要参考https://blog.csdn.net/qq_34562959/article/details/81095716?tdsourcetag=s_pctim_aiomsghttps://www.cnblogs.com/tanrong/p/9166595.html#wenti?tdsourcetag=s_pctim_aiomsghttps://blog.csdn.net/qq_30603195/article/details/88116757?tdsourcetag=s_pctim_aiomsg其他的不给也罢，要么过时，要么就是错的，重要的命令行就下面这些吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344# boot-repairsudo susudo add-apt-repository ppa:yannubuntu/boot-repairapt-get updateapt-get install boot-repair# recoveryAdvanced Settings -&gt; recovery mode -&gt; Resumesudo gedit /etc/initramfs-tools/modules加入fbconvesafbnvidiafb这三行sudo gedit /etc/modprobe.d/blacklist-framebuffer.conf文件，把nvidiafbvesafbvga16fb这三行注释掉，若没有则无视最后update-initramfs -uupdate-grubexit# 可能会导致设置问题sudo gedit /etc/default/grub 在文件中找到这一行： GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"改为： GRUB_CMDLINE_LINUX_DEFAULT="quiet splash nomodeset"保存，关闭文件。在命令行中输入：（更新文件） sudo update-grub# rootmount -rw -o remount# 驱动sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get update ubuntu-drivers devicessudo apt-get install nvidia-driver-415 当然我最终是失败了，走上了重装系统的光明之路。 chrome 浏览器从 http://www.ubuntuchrome.com/ 直接下载最新版，然后你会发现自己无法登录谷歌账号，于是想要去安装谷歌访问助手，安装扩展很容易获取，这里就不多说了。我从 windows 上获取的.crx文件不能用，解压缩导入也不行，于是就希望安装旧版本的可登录chrome 浏览器来实现同步，经过了一番曲折寻找，在 https://www.chromedownloads.net/chrome64linux/ 上获得了想要的 70 和 68 的版本，登录上去却发现不能进行同步，这边猜想可能是因为需要同步的 chrome 版本低于谷歌账号最近登录的 chrome 浏览器版本。于是乎，我有卸了装，装了卸，最终回到了原点—–》安装谷歌访问助手。网上浏览了一番，最终考虑试一下压缩的手段。想解压，然后压缩成 tar 文件， 最后进行解压。一切完工，自以为大功告成，结果导入解压缩文件还是出错。我那时真的一脸笑嘻嘻，幸好天无绝人之路，我将 .crx 文件拖入扩展界面竟然神奇的安装成功了。。。。真的是神(shi)一样的操作。接下来在最新版本的 chrome 浏览器下，我又迎来了一次新生。小小分析一下，这个 .crx 文件在 Windows 上也需要重新压缩再解压，大概是新版本的 chrome 浏览器更贴近其运行的系统，我们将其压缩、解压缩，使得此文件可以适应相应系统。注意，刚刚的分析都是没有根据的瞎猜测，报个玩笑的态度就好。 其他配置安装好Ubuntu18.04之后：https://blog.csdn.net/haeasringnar/article/details/81809040配置 root 用户: https://blog.csdn.net/sunxiaoju/article/details/51993091配置 idea 及熟悉快捷键：https://yangbingdong.com/2017/note-of-learning-idea-under-ubuntu/安装 SpaceVim：https://spacevim.org/cn/quick-start-guide/#linux-%E6%88%96-macos搜狗输入法设置默认英文输入法: https://blog.csdn.net/ameyume/article/details/87091652美化桌面环境：https://zhuanlan.zhihu.com/p/37852274 https://blog.csdn.net/weixin_38233274/article/details/80782483 思路及总结动手的时候要思考一下给的命令行，如果没有好好思考，嘿嘿，你会深刻理解什么叫做没有如果。如果 Ubuntu 出现了问题，还是先使用启动盘，boot-repair 一下，不行则进入 recovery 模式，再不行则进入 root ，使自己获取更改权限，进行操作。有的时候要排除错误，需要在这几个里面来回切换，非常耽误时间。如果你自己写好了一个常用安装的一键脚本，备份常用的工具后，重新安装其实挺好的(实际是因为自己太菜，三天下来实在受不了了。。。)，当然如果你能看懂它给的提示，那我说的都是废话。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vim的资源与使用]]></title>
    <url>%2F2019%2F03%2Fyuque%2Fpq6p97%2F</url>
    <content type="text"><![CDATA[概述毫无疑问，Vim对新手很不友好。但是友好的编辑器通常跟不上程序员进步的速度，谁又不想一劳永逸，一直使用同一种编辑器呢？这显然是一种辩证选择。而选择 Vim 绝对是一个明智的长期投资。Vim 又被称为神的编辑器，前身 vi 是由 BIll Joy 于 1976 年开发，其改进版 Vim 最早于 1991 年由 Bram Moolenaar 开发。关于 Vim 的其他故事，可以参考编辑器之神 &amp; 神的编辑器1。 Vim 学习资源网上有很多乱七八糟的资源，但我感觉写得都不尽如人意。主要还是靠自己去搜索资源，找到最适合自己的学习方式，显然现在我还只是入门，仍旧处于不断学习的状态中。我的学习过程大致如下: vimtutor Vim 实用技巧 笨方法学 Vimscript 关于 Vim 实用技巧，推荐自己看一遍，里面针对问题来提出 Vim 的解决方案，是一个很好的参考资料，可以参考我的写得一篇 Vim 实用技巧2，至于笨方法学Vimscript，目前还没有深入下去，仍旧在学习当中。 Vim 应用场景Vim 作为神的编辑器，自然少不了应用的地方。据我目前认知，大部分需要编辑器的地方，都能发现 Vim的身影，各种主流的 IDE 中 Vim 插件已经有大牛帮你写好了，只需要搜索进行下载就行了，我目前在这几个场景中应用 Vim： SpaceVim —-模块化的 Vim IDE Vimium —-Chrome浏览器的扩展程序 IdeaVim —-Idea中内置的插件 SpaceVim 三大主流平台都支持，是我自己轻量级写作和文件管理的工具，一开始用的不舒服，现在也还是不断学习的阶段。Vimium 是程序员的福利，Chrome 和Firefox 浏览器均有其插件，开箱即食。虽然有些按键设计不合理，但总的来说还是有所联系，毕竟这是社区推动、集思广益的。IdeaVim 则需要在 IDEA 中进行下载。我的初步使用，感觉还是有些不够灵活，其中还有一个扩展的 Vim 插件，有机会会去试试。 Vim 熟练使用熟练使用 Vim ，首先要学会盲打，SpeedCoder 是个不错的练习网站，学习了部分的 Vim 的知识，就可以通过做大量的练习来锻炼自己了，这显然是个煎熬过程，鉴于自己的学习也比价缓慢，就不过多分析。但是我还是喜欢在日常中去练习使用，而不是根据文档去刻意练习，找到自己需要编辑的地方，一律用 Vim 来编辑。比如写博客，敲代码，做记录等等。虽然我现在还是很水，但是也初步感受到了 Vim 的好处，刚开始的时候时间学习成本非常高，但回报也是巨大的。不知道是真正的效率，还是克服困难、努力得到肯定，使人感到无比强大和酣畅淋漓，反正正如大牛所说，它们会带给你渐渐强烈的快感，但你也向它们献出了自己的灵魂。这时，你只能称它们为神器。 注意以上内容，都是我个人的观点，欢迎访客提出自己的建议。另外自己显然有很多东西不懂，欢迎大佬给我些指导意见。这篇博客对于初学者来说，内容可能有些繁多，最好每个方向都入门，然后慢慢进步吧(我是如此，所以如是建议)，在学习过程中可能还要记一些与 Vim 无关的快捷键，比如在浏览器和 IDEA 中， 但我觉得这是早晚要适应的，克服一下，最终会感谢自己的选择。 引用1.http://os.51cto.com/art/201101/242518.htm2.https://www.yuque.com/tfrain/boke/vim_skill3.http://learnvimscriptthehardway.onefloweroneworld.com/4.https://spacevim.org/cn/5.https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb6.www.speedcoder.net]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[19.Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fkxgzpq%2F</url>
    <content type="text"><![CDATA[链表 题目描述Given a linked list, remove the _n_-th node from the end of list and return its head.Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and _n_ = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given _n_ will always be valid.Follow up:Could you do this in one pass? 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *///Two pass algorithmclass Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) &#123; length++; first = first.next; &#125; length -= n; first = dummy; while (length &gt; 0) &#123; length--; first = first.next; &#125; first.next = first.next.next; return dummy.next; &#125;&#125;//One pass algorithmpublic ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // Move first to the end, maintaining the gap while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next;&#125; 思路及总结不论是两遍算法，还是一遍算法，都用了一个额外空间 dummy，然后返回的是 dummy.next，一遍的算法很灵巧的避过了二遍算法的 n 的定位， 参考https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[17. Letter Combinations of a Phone Number]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_17%2F</url>
    <content type="text"><![CDATA[初步了解回溯算法 题目描述Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Example:Input: “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].Note:Although the above answer is in lexicographical order, your answer could be in any order you want. 参考代码12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits.length() != 0) backtrack("",digits); return output; &#125; Map&lt;String, String&gt; phone = new HashMap&lt;String, String&gt;() &#123;&#123; put("2", "abc"); put("3", "def"); put("4", "ghi"); put("5", "jkl"); put("6", "mno"); put("7", "pqrs"); put("8", "tuv"); put("9", "wxyz"); &#125;&#125;; List&lt;String&gt; output = new ArrayList&lt;String&gt;(); public void backtrack(String combination, String next_digits) &#123; if (next_digits.length() == 0) &#123; //意味着一条分支走到底，譬如 adg output.add(combination); &#125;else &#123; String digit = next_digits.substring(0, 1); String letters = phone.get(digit); for (int i = 0; i &lt; letters.length(); i++) &#123; //分割回溯 String letter = phone.get(digit).substring(i, i + 1); backtrack(combination + letter, next_digits.substring(1)); &#125; &#125; &#125;&#125; 思路及总结首先题目描述最好还是加上不允许重复，还有就是几个数字对应几个字母组合。。。。回溯是一种通过探索所有潜在候选者来查找所有解决方案的算法。如果候选解决方案变为不是解决方案（或者至少不是最后一个解决方案），则回溯算法通过在前一步骤上进行一些更改（即回溯然后再次尝试）来丢弃它。我怎么感觉更像 DFS 呢。。。。就是递归然后进行组合，回溯可能考虑的是得到 adg，还要回去得到 adh 参考https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[10. Regular Expression Matching]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_10%2F</url>
    <content type="text"><![CDATA[摘要里面放的是递归的方法，下面的是动态规划(Dynamic Programming)的方法。 题目描述Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:Input:s = “aa”p = “a”Output: falseExplanation: “a” does not match the entire string “aa”.Example 2:Input:s = “aa”p = “a“Output: trueExplanation: ‘‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.Example 3:Input:s = “ab”p = “.“Output: trueExplanation: “.“ means “zero or more () of any character (.)”.Example 4:Input:s = “aab”p = “cab”Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time.Therefore it matches “aab”.Example 5:Input:s = “mississippi”p = “misisp.”Output: false 参考代码123456789101112131415161718192021222324252627282930313233343536373839//递归class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) return s.isEmpty(); boolean first_match = (!s.isEmpty() &amp;&amp; (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')); if (p.length() &gt;= 2 &amp;&amp; p.charAt(1) == '*')&#123; //(isMatch(s, p.substring(2))使第 p 中第三个字符进行匹配， //(first_match &amp;&amp; isMatch(s.substring(1), p))使 p 中 * 之前的字符进行匹配 return (isMatch(s, p.substring(2)) || (first_match &amp;&amp; isMatch(s.substring(1), p))); &#125; else &#123; return first_match &amp;&amp; isMatch(s.substring(1), p.substring(1)); &#125; &#125;&#125;//DPclass Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[s.length()][p.length()] = true; for (int i = s.length(); i &gt;= 0; i--)&#123; for (int j = p.length() - 1; j &gt;= 0; j--)&#123; boolean first_match = (i &lt; s.length() &amp;&amp; (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.')); if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*')&#123; dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];// &#125; else &#123; dp[i][j] = first_match &amp;&amp; dp[i+1][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125; 思路及总结递归的思路： 大致是以 p 字段划分，两两进行递归。0,1,2个字符、纯字母和含有 . 的都较好理解。下面考虑含有 符号的。例如 aaacce 和 ace，(first_match &amp;&amp; isMatch(s.substring(1), p)) 递归到 cce 和 ace 的情况，然后 (isMatch(s, p.substring(2)) 收拾最后一步，则 p 中 ac 的匹配结束，但是删除的字符是 a*，第三个字符可能在接下来的一组进行使用。到了这一步，大致理解 If a star is present in the pattern, it will be in the second position \text{pattern[1]}pattern[1]. Then, we may ignore this part of the pattern, or delete a matching character in the text. If we have a match on the remaining strings after any of these operations, then the initial inputs matched. 是什么含义。但是看懂和写何止十万八千里，我还不知到要学习多少次，才能有这样的算法功底。复杂度有些复杂，大致应当是指空间复杂度为O(2^n)，空间复杂度是O(n^2)；DP的思路：了解一下DP：https://blog.csdn.net/zjkc050818/article/details/74532023可能更适合看是视频：https://www.bilibili.com/video/av16544031/?spm_id_from=333.788.videocard.0这里面提到了表格的DP：https://www.bilibili.com/video/av18512769?from=search&amp;seid=1441380389563731271这个 DP 的选与不选都不明显，而且很难判断出口，等做多了，想必能更好理解。啥都不会是我最大的觉悟。。。。。别人是兔派，我是兔看派，第一次遇见dp，都说dp和博弈论是神仙题，我感受到了。 参考https://leetcode.com/problems/regular-expression-matching/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5. Longest Palindromic Substring]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_5%2F</url>
    <content type="text"><![CDATA[题目描述Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.Example 1:Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2:Input: “cbbd”Output: “bb” 参考代码123456789101112131415161718192021222324252627class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i);//奇数 int len2 = expandAroundCenter(s, i, i + 1);//偶数 int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2;//确使奇偶行得通 end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1;//因为循环结束时，长度各边减一 &#125; &#125; 思路及总结偶数减一除以二(0.5-1.0)和奇数减一除以二(0.0-0.5)两者可以保持除法上的一致。官方首先提醒了最长公共子串的误区，然后列举了暴力法，动态规划，和本题的中心扩展法。详细内容直接参考官方题解。 参考https://leetcode-cn.com/problems/longest-palindromic-substring/solution/https://leetcode.com/problems/longest-palindromic-substring/solution/Manacher 算法https://segmentfault.com/a/1190000008484167]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4. Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_4%2F</url>
    <content type="text"><![CDATA[题目描述There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.Example 1:nums1 = [1, 3]nums2 = [2] The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 参考代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; if (m &gt; n) &#123; int[] tmp = nums1; nums1 = nums2; nums2 = tmp; int temp = m; m = n; n = temp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; nums2[j-1] &gt; nums1[i]) &#123; iMin = i + 1; &#125; else if (i &gt; iMin &amp;&amp; nums1[i-1] &gt; nums2[j]) &#123; iMax = i - 1; &#125; else &#123; int maxLeft = 0; if (i == 0) &#123; maxLeft = nums2[j-1];&#125; else if (j == 0) &#123;maxLeft = nums1[i-1];&#125; else &#123; maxLeft = Math.max(nums1[i-1], nums2[j-1]); &#125; if ( (m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123;minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums2[j], nums1[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;&#125; 思路及总结当找到目标对象 i_i_时，中位数为：当为奇数时，left的数字较多，可以举例来理解一下 保证奇偶都能满足最后的那个数学证明是看到头都大了，大概是那个道理。还是官方解答，最为致命。时间复杂度为log(m+n),意思就是只能单层循环一次两个数组，有点利用二分法和分治的思想。 参考https://leetcode.com/problems/median-of-two-sorted-arrays/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_2%2F</url>
    <content type="text"><![CDATA[题目描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1 == null) &#123; l1 = new ListNode(0); &#125; if(l2 == null) &#123; l2 = new ListNode(0); &#125; if(l1.next == null &amp;&amp; l2.next == null) &#123;//基准情况 int val = l1.val + l2.val; if(val &gt; 9) &#123; ListNode node = new ListNode(val%10); node.next = new ListNode(1);//最大的数字也只能是19 return node; &#125; else &#123; return new ListNode(val); &#125; &#125; else &#123; int val = l1.val + l2.val; if(val &gt; 9) &#123; val -= 10; if(l1.next != null) &#123;//将进位赋值其一 l1.next.val++; &#125; else if(l2.next != null) &#123; l2.next.val++; &#125; &#125; ListNode node = new ListNode(val); node.next = addTwoNumbers(l1.next,l2.next); //最终返回的结果 return node; &#125; &#125;&#125; 思路及总结涉及到链表和递归，感觉自己的基础实在是太差了，基础的算法思想都不会使用，还有就是自己的java基础也很薄弱，经常不知道如何来调用一些常用函数，结合自身情况，尽早提升吧。本题主要要考虑到进位的安排，使用了递归，递归问题一般都能转换为循环问题，如https://www.programcreek.com/2012/12/add-two-numbers/，复杂度为O(n)，进位只会进1。 参考https://blog.csdn.net/yanyumin52/article/details/79811375https://blog.csdn.net/w496272885/article/details/80212426]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法相关知识简介]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fwikipedia_algorithm%2F</url>
    <content type="text"><![CDATA[据说维基的知识总结很优秀 前言若hexo有小bug或不舒服之处，请移步到语雀浏览因为自己的算法基础非常薄弱，希望通过兔派刷题的方式，怀着幸存者的意识，能够迎头赶上。 数组(Array)在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。最简单的数据结构类型是一维数组。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，…2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。二维数组，对应于数学上的矩阵概念，可表示为二维矩形格。例如：在C语言中表示为int a[3][3] = {{3, 6, 2}, {0, 1, -4}, {2, -1, 0}};。在某些情况下，“向量”一词也可能代表二维数组，虽然在数学意义上更确切地称呼为元组（tuple），而不是向量。但需要注意的是：计算机科学的某些领域，如Matlab，元组是指类似C语言struct类型，具有固定的往往是不同类型的数据成员的数据结构。数组通常用于实现数据库的表格，特别是查询表；表格有时也被当作是数组的同义词。数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表（list）和字符串（string）。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是向量处理器），经常会针对数组操作进行优化。因为在程序运行时可以计算元素的索引，数组是很有用的。此外，也能以单一迭代语句就处理数组的许多元素。为此，数组数据结构的元素必须具有相同的大小，而且应该使用相同的数据类型表示。数组一词通常用于表示数组数据类型，一种大多数高端编程语言都会内置的数据类型。数组类型通常由数组结构来实现；然而在某些语言中，它们可以由散列表、链表、搜索树或其它数据结构来实现。在算法的描述中，数组一词特别着重意义为关系数组或“抽象的数组”，一种理论上的计算机科学模型（抽象数据类型或 ADT），专注于数组的基本性质上。 哈希表(Hash Table)散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名x到首字母F(x)的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。 链表(Linked List)链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针)(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（”links”）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。 数学(Math) 双指针(Two Pointers) 串(String)字符串（String），是由零个或多个字符组成的有限序列。一般记为。它是编程语言中表示文本的数据类型。通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。串的两种最基本的存储方式是顺序存储方式和链接存储方式。 二分查找(Binary Search)在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。二分搜索在情况下的复杂度是对数时间，进行次比较操作在此处是数组的元素数量，是大O记号，是对数）。二分搜索使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分搜索比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分搜索应用面更广。二分搜索有许多中变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索。分散层叠有效的解决了计算几何学和其他领域的许多搜索问题。指数搜索将二分搜索拓宽到无边界的列表。二分搜索树和B树数据结构就是基于二分搜索的。 分治算法(Divide and Conquer)在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个理论，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。分治法这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的折半搜索算法（或是在数值分析中类似的勘根算法）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用尾部递归的话，便能转换成简单的循环。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用减治法这个名称。分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。 动态规划(Dynamic Programming)动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 回溯算法(Backtracking)回溯法（英语：backtracking）是暴力搜索法中的一种。对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况： 找到一个可能存在的正确的答案 在尝试了所有可能的分步方法后宣告该问题没有答案 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。 栈(Stack)堆栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的抽象数据类型，其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外堆栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 堆(Heap)堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。堆始于 J._W._J._Williams 在 1964 年发表的堆排序（heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在戴克斯特拉算法（英语：Dijkstra’s algorithm）中亦为重要的关键。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。 贪心算法(Greedy)贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。 排序(Sort)在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则： 输出结果为递增序列（递增是针对所需的排序顺序而言） 输出结果是原输入的一种排列、或是重组 虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表） 位运算(Bit Manipulation)位操作是算法操作比字&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhjWJGcdyh6D0YqybOhRRrQm_q3weA)短的位或其他数据&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhimJkNnf1ms2G_qzxH5ThHaFXOF3w)的行为。 需要位操作的计算机编程任务包括低级设备控制， 错误检测和纠正算法， 数据压缩 ， 加密算法和优化&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhh_t9EuZt8FPWcE83nzA7-3KzopLw) 。 对于大多数其他任务，现代编程语言允许程序员直接使用抽象&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgsc5qtrh0_vT7zGYTWMCKDHxCcOA)而不是代表那些抽象的位。 执行位操作的源代码使用按位运算 ：AND，OR，XOR，NOT和位移 。在某些情况下，位操作可以消除或减少循环数据结构的需要，并且可以提供多倍的加速，因为并行处理位操作，但代码可能变得更难以编写和维护。 树(Tree)在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路(cycle) 深度优先搜索(Depth-first Search)深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树)或图)的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。因发明“深度优先搜索算法”，约翰·霍普克洛夫特与罗伯特·塔扬在1986年共同获得计算机领域的最高奖：图灵奖。 广度优先搜索(Breadth-first Search)广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。 并查集(Union Find)在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于创建单元素集合。有了这些方法，许多经典的划分问题可以被解决。为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。 图(Graph) 设计(Design) 拓扑排序(Topological Sort)在计算机科学领域，有向图的拓扑排序是其顶点的线性排序，使得对于从顶点到顶点的每个有向边，在排序中都在之前。 例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是有向无环图（DAG），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。 每个顶点出现且只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径)。 字典树(Trie)在计算机科学中，trie，又称前缀树或字典树，是一种有序树)，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。Trie这个术语来自于retrieval。根据词源学，trie的发明者Edward Fredkin把它读作/ˈtriː/ “tree”。但是，其他作者把它读作/ˈtraɪ/ “try”。在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie中的键是一串比特，可以用于表示整数或者内存地址。 树状数组(Binary Indexed Tree)树状数组或二叉索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以的时间得到任意前缀和，并同时支持在时间内支持动态单点值的修改。空间复杂度。 线段树(Segment Tree)线段树（英语：Segment tree）是一种二叉树形数据结构，1977年由Jon Louis Bentley发明，用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间。一个包含个区间的线段树，空间复杂度为，查询的时间复杂度则为，其中 是匹配条件的区间数量。此数据结构亦可推广到高维度。 二叉搜索树(Binary Search Tree)二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合)、多重集、关联数组等。二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望，最坏（数列有序，树退化成线性表）。虽然二叉查找树的最坏效率是,但它支持动态查询，且有很多改进版的二叉查找树可以使树高为,如SBT,AVL树，红黑树等。故不失为一种好的动态查找方法。 递归(Recursion)递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 脑筋急转弯(Brainteaser) 记忆化(Memoization)在计算机科学中，记忆化（英语：memoization而非memorization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。 队列(Queue)队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。 极小化极大(Minimax)Minimax算法（亦称 MinMax or MM）又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。 蓄水池抽样(Reservoir Sampinh) Map 几何(Geometry) Rendom Rejection Samping 参考以上内容均来自wikipedia]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[860. Lemonade Change]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_944%2F</url>
    <content type="text"><![CDATA[题目描述At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.Note that you don’t have any change in hand at first.Return true if and only if you can provide every customer with correct change. Example 1:Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true.Example 2:Input: [5,5,10]Output: trueExample 3:Input: [10,10]Output: falseExample 4:Input: [5,5,10,10,20]Output: falseExplanation: From the first two customers in order, we collect two $5 bills.For the next two customers in order, we collect a $10 bill and give back a $5 bill.For the last customer, we can’t give change of $15 back because we only have two $10 bills.Since not every customer received correct change, the answer is false. Note: 0 &lt;= bills.length &lt;= 10000 bills[i] will be either 5, 10, or 20.参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills[0] != 5) &#123;//若第一个不是5，则返回false return false; &#125; else &#123; int five = 1,ten = 0; int length = bills.length; for(int i = 1;i &lt; length;i++) &#123;//从第二个数据开始 if(bills[i] == 5) &#123; five++; &#125; else if(bills[i] == 10)&#123; if(five == 0) &#123; return false; &#125; else &#123;//进行相应的加减 five--; ten++; &#125; &#125; else &#123; if(five == 0) &#123; return false; &#125; else if(ten != 0) &#123;//10、5的情况 five--; ten--; &#125; else &#123; if(five &gt;= 3) &#123;//5,5,5的情况 five -= 3; &#125; else &#123; return false; &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125; 思路及总结感觉这个题目没有体现所谓贪心算法的思想，只是一些if else的语句，以及需要考虑一些边界问题。 参考https://www.smwenku.com/a/5bb2d3692b71770e645e1c2b/zh-cn/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux学习6]]></title>
    <url>%2F2019%2F02%2Fyuque%2Flinux_learning6%2F</url>
    <content type="text"><![CDATA[文件和目录属性&lt;! – more –&gt; 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html Linux目录结构 概述对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学号Linux的至关重要的一步，深入了解Linux文件目录结构的标准和每个目录的详细功能，对于我们用好Linux系统至关重要，下面我们就开始了解Linux目录结构的相关知识。当在使用Linux的时候，如果您通过ls -l/ 就会发现，在/下包含很多的目录，比如etc、usr、var、bin…等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就像树形结构，所以我们可以把文件新系统的结构形象称为树形结构。文件系统是用力啊组织和排列文件存取的，所以他是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/起始的树形结构。Linux文件系统的最顶端是/，我们称/为Linux的root，也就是Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是上级的领导者。由于Linux是开放源代码，各大公司和团体根据Linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的pc。因为你根本不知道一些基本的配置，文件在哪里。。这就造成了混乱。这就是FHS(Filesystem Hierarchy Standard )机构诞生对的原因。该机构是Linux爱好者自发组成的一个团体，主要是对Linux做一些基本的要求，不至于是操作者换一台主机就成了Linux的“文盲”。根据FHS (http://www.pathname.com/fhs/) 的官方文件指出，他们的主要目的是希望让使用者可以了解发哦已安装软件通常放置于哪个目录下，所以他们希望独立的软件开发上、操作系统制作者、以及想要维护系统的用户，都能遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做的好处非常多，因为Linux操作系统就能够与在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样： 可分享的(shareable) 不可分享的(unshareable) 不变的(static) /usr (软件放置处) /etc (配置文件) /opt (第三方协力软件) /boot (开机与核心档) 可变动的(variable) /var/mail (使用者邮件信箱) /var/run (程序相关) /var/spool/news (新闻组) /var/lock (程序相关) 四种类型 可分享的可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录； 不可分享的自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 不变的有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等； 可变动的经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：/(root，根目录)：与开机系统有关/usr (unix software resource)：与软件安装/执行有关；/var (variable)：与系统运作过程有关。 根目录(/)的意义与内容根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。根据以上原因，FHS认为根目录(/)下应该包含如下子目录： 目录 应放置档案内容 /bin 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp, / dev/hd, /dev/sd*等等 /etc 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home 这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /media media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 /opt 这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 /root 系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 /sbin Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srv srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 事实上FHS针对根目录所定义的标准就仅限与上表，不过仍旧有些目录也需要我们了解一下，具体如下： 目录 应放置文件内容 /lost+found 这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc 这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys 这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录户被挂载，其他跟去则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：/etc：配置文件/bin：重要执行档/dev：所需要的装置文件/lib：执行档所需的函式库与核心所需的模块/sbin：重要的系统执行文件这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 /usr的意义与内容依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)，如果你知道如何透过网络进行分区的挂载（例如在服务器篇会谈到的NFS服务器），那么/usr确实可以分享给局域网络内的其他主机来使用喔。/usr不是user的缩写，其实usr是Unix Software Resource的缩写，也就是Unix操作系统软件资源放置的目录，而不是用户的数据啦。这点要注意。FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr的次目录建议有底下这些： 目录 应放置文件内容 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/ 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件/usr/share/doc：软件杂项的文件说明/usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var的意义与内容如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有： 目录 应放置文件内容 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档 /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/ 非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/ 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/ 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用 由于FHS仅是定义出最上层(/)及次层(/usr,/var)的目录内容应该要放置的文件或目录数据，因此，在其他次目录层级内，就可以随开发者自行来配置了。 目录树(directory tree) :在Linux底下，所有文件与目录都是由根目录开始的。那是所有目录与文件的源头，然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directoty tree)，这个目录的主要特性有：目录树的起始点为根目录(/，root)；每一个目录不止能使用本地端的partition的文件系统，也可以使用网络上的filesystem。举例来说，可以利用Network File System(NFS)服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示： 绝对路径和相对路径除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名的写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。这两种文件名/路径的写法依据是这样的：绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？cd /var/log (absolute)cd ../var/log (relative)因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。这个.与..目录概念是很重要的，你常常会看到cd ..或./command 之类的指令下达方式，就是代表上一层与目前所在目录的工作状态。 实例网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin,/usr/bin等为正规),此时要执行指令就要严格指定该执行档。./代表某目录的意思，所以./run.sh代表执行本目录下，名为run.sh的文件。 Linux文件类型与扩展名 概述Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。我们通过一般应用程序而创建的比如file.txt、file.tar.gz，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多是常规文件（也被称为普通文件）。 文件类型Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等，现在我们进行一个简要的说明。 普通文件我们用ls -lh来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是-，这样的文件在Linux中就是普通文件。这些文件一般使用一些相关的应用程序创建，比如图像工具、文档工具、归档工具…或cp工具等。这类文件的删除方式是用rm命令。另外，依照文件的内容，有大略可以分为： 纯文本档(ASCII):这是Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令：cat ~/.bashrc看到该文件的内容。(cat是将一个文件内容读出来的指令)。 二进制文件(binary)：Linux系统其实仅认识切可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts,文字型批处理文件不算)就是这种格式的文件。刚刚使用的cat命令就是一个binary file。 数据格式文件(data)：有些程序在运作的过程中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件(data file)。举例来说，我们的Linux在使用者登录时，都会精登录的数据记录在/var/log/wtmp那个文件内，该文件是一个data file，他能够透过last这个指令读出来！但是使用cat时，会读出乱码~因为贪睡属于一种特殊格式的文件 目录文件当我们在某个目录下执行，看到有类似drwxr-xr-x，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用mkdir命令，或cp命令，cp可以把一个目录复制为另一份目录。删除用rm或rmdir命令。 字符设备或块设备文件如果你进入/dev目录，列一下文件，会看到类似如下的:[root@localhost ~]# ls -al /dev/ttycrw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty[root@localhost ~]# ls -la /dev/sda1brw-r—– 1 root disk 8, 1 11-03 07:11 /dev/sda1我们看到/dev/tty的属性是crw-rw-rw-,注意前面第一个字符是c，这表示字符设备文件。比如猫等串口设备。我们看到/dev/sdal 的属性是brw-r—-，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。这个种类的文件，使用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。与系统周边及存储相关的一些文件，通常都集中在/dev这个目录之下通常又分成两种： 区块(block)设备档就是一些存储数据，以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是啦。你可以随机的在硬盘的不同区块读写，这种装置就是成组设备！你可以自行查一下/dev/sda看看，会发现第一个属性为 [b] ！ 字符(character)设备文件亦即是一些串行端口的接口设备，例如键盘、鼠标等等！这些设备的特设就是一次性读取的，不能够结算输出。举例来说，你不可能让鼠标调到另一个画面，而是滑动到另一个地方！第一个属性为[c]。 数据接口文件(sockets)：数据接口问文件(或者：套接口文件)，这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求，而客户端就可以透过这个socket来进行数据的沟通了。第一个数次那个为[s]，最常在/var/run这个目录中看到这种文件类型了。例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。[root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock注意这个文件的属性的第一个字符是s。 符号链接文件：当我们查看文件属性时，会看到有类似lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。是通过ln -s源文件名 新文件名。上面是一个例子，表示setup.log是instal.log的软链接文件。怎么理解呢？这和Windows操作系统中的快捷方式有点相似。符号链接文件的创建方法举例：[root@localhost test]# ls -lh log2012.log-rw-r–r– 1 root root 296K 11-13 06:03 log2012.log[root@localhost test]# ln -s log2012.log linklog.log[root@localhost test]# ls -lh *.loglrwxrwxrwx 1 root root 11 11-22 06:58 linklog.log -&gt; log2012.log-rw-r–r– 1 root root 296K 11-13 06:03 log2012.log 数据输送文件(FIFO，pipe):FIFO也是一种特殊的文件了类型，他主要的目的在解决多个程序同时存取一个问价所造成的错误问题。FIFO是first-in-first-out的缩写。第一个属性为[p]。 Linux文件扩展名 扩展名类型基本上，Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的是个属性有关，与档名根本一点关系也没有。这个观念和Windows的情况不相同。在Windows底下，能被执行的文件扩展名通常是.com,.exe,.bat等等。而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ]即代表这个文件可以被执行。不过，可以被执行根可以执行成功破那个是不一样的，举例来说，在root/home 目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个问价能够真的执行成功吗？当然就要看该文件的内容。虽然如此，不过我们任然希望可以藉由扩展名来了解该文件是什么东西，所以，通常我么还是会以适当的扩展名表示该文件是什么种类的。底下有数种常用的扩展名：.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .shZ, .tar, .tar.gz, .zip, .tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！.html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。 基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件 ，如常用的/bin/ls这个显示文件属性的指令，不过，如果这个问价的权限被修改为无法执行时，那么ls就变成不能执行。上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的Linux系统中就是无法执行！呵呵！那么就是可能文件的属性被改变了。不要怀疑，从网络上床送到你的Linux系统中，文件的属性与权限确实是会被改变的。 Linux文件名长度限制在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：单一文件或目录的最大容许文件名为 255 个字符包含完整路径名称及目录 (/) 之完整档名为 4096 个字符是相当长的档名！我们希望Linux的文件名可以一看就知道该文件在干嘛的， 所以档名通常是很长很长。 Linux文件名的字符的限制由于Linux在文字接口下的一些指令操作关系，一般来说，你在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如底下这些：* ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { }因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“.”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以你最好也避免将文件档名的开头以 - 或 + 来命名。 Linux文件属性详解 概述Linux文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。具体情况如下：命令： ls -lih输出：[root@localhost test]# ls -lih总计 316K2095120 lrwxrwxrwx 1 root root 11 11-22 06:58 linklog.log -&gt; log2012.log2095112 -rw-r–r– 1 root root 296K 11-13 06:03 log2012.log2095110 -rw-r–r– 1 root root 61 11-13 06:03 log2013.log2095107 -rw-r–r– 1 root root 0 11-13 06:03 log2014.log2095117 -rw-r–r– 1 root root 0 11-13 06:06 log2015.log2095118 -rw-r–r– 1 root root 0 11-16 14:41 log2016.log2095119 -rw-r–r– 1 root root 0 11-16 14:43 log2017.log2095113 drwxr-xr-x 6 root root 4.0K 10-27 01:58 scf2095109 drwxrwxr-x 2 root root 4.0K 11-13 06:08 test32095131 drwxrwxr-x 2 root root 4.0K 11-13 05:50 test4说明：第一列：inode第二列：文件种类和权限；第三列： 硬链接个数；第四列： 属主；第五列：所归属的组；第六列：文件或目录的大小；第七列和第八列：最后访问或修改时间；第九列：文件名或目录名我们以log2012.log为例：2095112 -rw-r–r– 1 root root 296K 11-13 06:03 log2012.loginode 的值是：2095112 文件类型：文件类型是-，表示这是一个普通文件； 关于文件的类型，请参考：每天一个linux命令(24)：Linux文件类型与扩展名 文件权限：文件权限是rw-r–r– ，表示文件属主可读、可写、不可执行，文件所归属的用户组不可写，可读，不可执行，其它用户不可写，可读，不可执行；硬链接个数： log2012.log这个文件没有硬链接；因为数值是1，就是他本身；文件属主：也就是这个文件归哪于哪个用户 ，它归于root，也就是第一个root；文件属组：也就是说，对于这个文件，它归属于哪个用户组，在这里是root用户组；文件大小：文件大小是296k个字节；访问可修改时间 ：这里的时间是最后访问的时间，最后访问和文件被修改或创建的时间，有时并不是一致的；当然文档的属性不仅仅包括这些，这些是我们最常用的一些属性。 关于inodeinode 译成中文就是索引节点。每个存储设备或存储设备的分区(存储设备是硬盘、软盘、u盘等等)被格式化为文件系统后，应该有两部分，一部分是inode，另一部分是Block，Block是用来存储数据用的。而inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令，能通过inode值最快的找到相对应的文件。做个比喻，比如一本书，存储设备或跟去就相当于这本书，Block相当于书中的每一页，inode 就相当与这本书前面的目录，一本书有很多的内容，如果想查找某部分的内容，我们可以先查目录，通过目录能最快的找到我们想要看的内容。虽然不太恰当，但还是比较形象。当我们用ls查看某个目录或文件时，如果加上-i参数，就可以看到inode节点了，比如我们前面所说的例子：[root@localhost test]# ls -li log2012.log 2095112 -rw-r–r– 1 root root 302108 11-13 06:03 log2012.loglog2012.log 的inode值是 2095112 ； 查看一个文件或目录的inode，要通过ls 命令的的 -i参数。 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[264. Ugly Number II]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_264%2F</url>
    <content type="text"><![CDATA[题目描述Write a program to find the n-th ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example:Input: n = 10Output: 12Explanation: 11, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 110 ugly numbers.Note: 1 is typically treated as an ugly number. n does not exceed 1690.参考代码 12345678910111213141516171819202122class Solution &#123; public int nthUglyNumber(int n) &#123; int factors[] = &#123;2,3,5&#125;; //优先队列 Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;(); queue.offer(1L); 注意第1690个可能会超过int的范围 while (true) &#123; long min = queue.poll();//每次取最小值相乘，取得第n个数 if (n == 1) &#123; return (int)min; &#125; for (int i = 0; i &lt; 3; i++) &#123; long ugly = factors[i] * min; if(!queue.contains(ugly)) &#123;//去重 queue.offer(ugly); &#125; &#125; n--; &#125; &#125;&#125; 思路及总结利用优先队列进行排序，然后将2、3、5中最小值作为下次相乘的因子，确保没有重复的数字，queue.poll()取得的是即是第 1\2\3\4\5。。。 个数,当n = 1 时，min即是第n个数. 参考https://chuansongme.com/n/1648591652025]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LInux学习5]]></title>
    <url>%2F2019%2F01%2Fyuque%2Flinux_learning5%2F</url>
    <content type="text"><![CDATA[网络命令 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html ifconfig命令 概述许多Windows非常熟悉ipconfig命令工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有类似的工具，也就是ifconfig（interfaces config）。通常需要以root身份登录或者使用sudo以便在LInux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息等，还可以修改这些配置 命令格式ifconfig[网络设备][参数] 命令参数12345678910111213141516171819up 启动指定网络设备/网卡。down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。arp 设置指定网卡是否支持ARP协议。-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包-a 显示全部接口信息-s 显示摘要信息（类似于 netstat -i）add 给指定网卡配置IPv6地址del 删除指定网卡的IPv6地址&lt;硬件地址&gt; 配置网卡最大的传输单元mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。tunel 建立隧道dstaddr 设定一个远端地址，建立点对点通信-broadcast&lt;地址&gt; 为指定网卡设置广播协议-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议multicast 为网卡设置组播标志address 为网卡设置IPv4地址txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度 常用命令实例：显示网络设备信息（激活状态的）命令：ifconfig[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:20 inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB)说明：eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址（MAC地址）是 00:50:56:BF:26:20inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204，广播地址， Bcast:192.168.120.255，掩码地址Mask:255.255.255.0 lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）第二行：网卡的IP地址、子网、掩码第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节第四、五行：接收、发送数据包情况统计第七行：接收、发送数据字节数统计信息。 实例：启动关闭指定网卡命令：ifconfig eth0 upifconfig eth0 down说明：ifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 实例：为网卡配置和删除IPv6地址命令：ifconfig eth0 add 33ffe:3240:800:1005::2/64ifconfig eth0 del 33ffe:3240:800:1005::2/64说明：ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0配置IPv6地址；ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址；练习的时候，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 实例：用ifconfig修改MAC地址命令：ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE[root@localhost ~]# ifconfig eth0 down //关闭网卡[root@localhost ~]# ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE //修改MAC地址[root@localhost ~]# ifconfig eth0 up //启动网卡[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:AA:BB:CC:DD:EE inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB)[root@localhost ~]# ifconfig eth0 hw ether 00:50:56:BF:26:20 //关闭网卡并修改MAC地址 [root@localhost ~]# ifconfig eth0 up //启动网卡[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:20 inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB) 实例：配置IP地址命令：[root@localhost ~]# ifconfig eth0 192.168.120.56 [root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 [root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255说明：ifconfig eth0 192.168.120.56 给eth0网卡配置IP地：192.168.120.56 ifconfig eth0 192.168.120.56 netmask 255.255.255.0 给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255/给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255 实例：启动和关闭ARP协议命令：[root@localhost ~]# ifconfig eth0 arp [root@localhost ~]# ifconfig eth0 -arp说明：ifconfig eth0 arp 开启网卡eth0 的arp协议；ifconfig eth0 -arp 关闭网卡eth0 的arp协议； 实例：设置最大传输单元命令：ifconfig eth0 mtu 1500[root@localhost ~]# ifconfig eth0 mtu 1480[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:1F inet addr:192.168.120.203 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1480 Metric:1 RX packets:8712395 errors:0 dropped:0 overruns:0 frame:0 TX packets:36631 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:597062089 (569.4 MiB) TX bytes:2643973 (2.5 MiB) [root@localhost ~]# ifconfig eth0 mtu 1500[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:1F inet addr:192.168.120.203 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8712548 errors:0 dropped:0 overruns:0 frame:0 TX packets:36685 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:597072333 (569.4 MiB) TX bytes:2650581 (2.5 MiB)说明：设置能通过的最大数据包大小为1500bytes备注：用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在，要想将上述的配置信息永远的存在电脑里，那就要修改网卡的配置文件了。 route命令 概述Linux系统的toute命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在 / etc/rc.local 中添加 route 命令来保证该路由设置永久有效。 命令格式route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络连接口，如eth0。当使用参数时，路由表被修改，如果没有参数，则显示路由表当前内容 命令参数1234567891011121314151617181920-c 显示更多信息-n 不解析名字-v 显示详细的处理信息-F 显示发送信息-C 显示路由缓存-f 清除所有网关入口的路由表。 -p 与 add 命令一起使用时使路由具有永久性。add: 添加一条新路由。del: 删除一条路由。-net: 目标地址是一个网络。-host: 目标地址是一个主机。netmask: 当添加一个网络路由时，需要使用网络掩码。gw: 路由数据包通过网关。注意，你指定的网关必须能够达到。metric：设置路由跳数。Command 指定您想运行的命令 (Add/Change/Delete/Print)。 Destination 指定该路由的网络目标。 mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表 (与转发的数据包目标地址最匹配) 的多个路由中进行选择时可以使用。 if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。 常用命令实例：显示当前路由命令：routeroute -n[root@localhost ~]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.120.0 * 255.255.255.0 U 0 0 0 eth0e192.168.0.0 192.168.120.1 255.255.0.0 UG 0 0 0 eth010.0.0.0 192.168.120.1 255.0.0.0 UG 0 0 0 eth0default 192.168.120.240 0.0.0.0 UG 0 0 0 eth0[root@localhost ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.120.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0192.168.0.0 192.168.120.1 255.255.0.0 UG 0 0 0 eth010.0.0.0 192.168.120.1 255.0.0.0 UG 0 0 0 eth00.0.0.0 192.168.120.240 0.0.0.0 UG 0 0 0 eth0说明：第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240其中Flags为路由标志，标记当前网络节点的状态。Flags标志说明： 1234567U Up表示此路由当前为启动状态H Host，表示此网关为一主机G Gateway，表示此网关为一路由器aR Reinstate Route，使用动态路由重新初始化的路由D Dynamically,此路由是动态性地写入aM Modified，此路由是由路由守护程序或导向器动态修改! 表示此路由当前为关闭状态 备注：route -n (-n 表示不解析名字,列出速度会比route 快) 实例：添加网关/设置网管命令：route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0说明：增加一条 到达 244.0.0.0 的路由 实例：删除路由记录命令：route del -net 224.0.0.0 netmask 240.0.0.0route del -net 224.0.0.0 netmask 240.0.0.0 reject说明：删除224.0.0.0的路由记录 实例 ：删除和添加设置默认网关命令：route del default gw 192.168.120.240route add default gw 192.168.120.240 ping命令 概述Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说”ping一下某机器，看是不是开着“、不能打开网页时会说””你先ping网关地址192.168.1.1试试“。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样而我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。 命令格式ping [参数] [主机名或IP地址] 命令功能ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数1234567891011121314-d 使用Socket的SO_DEBUG功能。-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应。-n 只输出数值。-q 不显示任何传送封包的信息，只显示最后的结果。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。-R 记录路由过程。-v 详细显示指令的执行过程。&lt;p&gt;-c 数目：在发送指定数目的包后停止。-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-I 网络界面：使用指定的网络界面送出数据包。-l 前置载入：设置在送出要求信息之前，先行发出的数据包。-p 范本样式：设置填满数据包的范本样式。-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。-t 存活数值：设置存活数值TTL的大小。 常用命令实例：ping的通的情况命令：ping 192.168.120.205输出：[root@localhost ~]# ping 192.168.120.205PING 192.168.120.205 (192.168.120.205) 56(84) bytes of data.64 bytes from 192.168.120.205: icmp_seq=1 ttl=64 time=0.720 ms64 bytes from 192.168.120.205: icmp_seq=2 ttl=64 time=0.181 ms64 bytes from 192.168.120.205: icmp_seq=3 ttl=64 time=0.191 ms64 bytes from 192.168.120.205: icmp_seq=4 ttl=64 time=0.188 ms64 bytes from 192.168.120.205: icmp_seq=5 ttl=64 time=0.189 ms — 192.168.120.205 ping statistics —5 packets transmitted, 5 received, 0% packet loss, time 4000msrtt min/avg/max/mdev = 0.181/0.293/0.720/0.214 ms[root@localhost ~]# 实例：ping不通的情况命令：ping 192.168.120.202输出：[root@localhost ~]# ping 192.168.120.202PING 192.168.120.202 (192.168.120.202) 56(84) bytes of data.From 192.168.120.204 icmp_seq=1 Destination Host UnreachableFrom 192.168.120.204 icmp_seq=2 Destination Host Unreachable 实例：ping指定次数命令：ping -c 10 192.168.120.206 实例：时间间隔和次数限制的ping命令：ping -c 10 -i 0.5 192.168.120.206 实例：多参数使用命令：ping -i 3 -s 1024 -t 255 192.168.120.206说明：-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255 traceroute命令 概述通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname而在Windows系统下是执行tracert的命令：tracert hostname 命令格式traceroute[参数][主机] 命令功能traceroute命令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] 命令参数123456789101112131415-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。 常用命令实例1：traceroute 用法简单、最常用的用法命令：traceroute www.baidu.com输出：[root@localhost ~]# traceroute www.baidu.comtraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets 1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms 2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms 3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms 4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms 5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms 6 61.148.154.97 (61.148.154.97) 718.908 ms bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms 7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms 8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms 9 30 *[root@localhost ~]# 说明：记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。 Traceroute的工作原理Traceroute最简单的基本用法是：traceroute hostnameTraceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。 scp命令 概述scp命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp知识在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外scp还非常不占资源，不会提高多少系统负荷，在这一点上rsync就远远不及它了。虽然rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 命令格式scp [参数] [原路径] [目标路径] 命令功能scp是secure copy的缩写，scp是Linux系统基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在Linux服务器之间复制文件和目录。 命令参数1234567891011121314151617-1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 常用命令实例：从远处复制到本地/从本地复制到远处命令：scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest说明：从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fnum_155%2F</url>
    <content type="text"><![CDATA[题目描述Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041class MinStack &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; /** initialize your data structure here. */ public MinStack() &#123; stackData = new Stack&lt;Integer&gt;(); stackMin = new Stack&lt;Integer&gt;(); &#125; public void push(int x) &#123; stackData.push(x); if(stackMin.isEmpty() || x &lt;= stackMin.peek()) &#123;//最小值栈的为空或这最小值小于等于 stackMin.push(x); &#125; &#125; public void pop() &#123; Integer num = stackData.pop(); if(num.equals(stackMin.peek())) &#123;//要用equals函数 stackMin.pop(); &#125; &#125; public int top() &#123; return stackData.peek(); &#125; public int getMin() &#123; return stackMin.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 思路及总结利用两个栈，一个代表最小值，一个代表普通情况。注意最小值栈要依靠普通栈，普通栈中最小值出栈，最小值栈的最小值也要出栈。另外自己基础太差，wrong answer的时候一直没发现要用equals才能进行更合理的比较。希望自己以后更深入的时候能有更好的理解。 参考https://blog.csdn.net/loophome/article/details/83749444https://blog.csdn.net/returnzhang/article/details/78608898]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[215. 数组中的第K个最大元素]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fnum_215%2F</url>
    <content type="text"><![CDATA[题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例 1:输入: 1[3,2,1,5,6,4] 和 k = 2输出: 5示例 2:输入: 1[3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4说明:你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 参考代码123456789101112class Solution &#123; public static int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(); for(int num :nums) &#123; priorityQueue.add(num); if(priorityQueue.size() &gt; k) &#123; priorityQueue.poll(); &#125; &#125; return priorityQueue.peek(); &#125;&#125; 思路及总结主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。 参考https://www.kancloud.cn/maliming/leetcode/844880]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[11. Container With Most Water]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fnum_11%2F</url>
    <content type="text"><![CDATA[题目描述Given _n_ non-negative integers _a_, _a_, …, _a_, where each represents a point at coordinate (_i_, _a_). _n_ vertical lines are drawn such that the two endpoints of line _i_ is at (_i_, _a_) and (_i_, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and _n_ is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example:Input: [1,8,6,2,5,4,8,3,7]Output: 49 参考代码123456789101112131415class Solution &#123; public int maxArea(int[] height) &#123; int max = 0; boolean temp; for(int i = 0,j = height.length - 1;i &lt; j;) &#123; int h = (height[i] &gt; height[j]) ? height[j] : height[i]; if(h * (j - i)&gt;max) max = h * (j - i); temp = (height[i] &lt; height[j]) ? true : false; if(temp) i++; else j--; &#125; return max; &#125;&#125; 思路及总结较为简单的思路就是采用双指针，从两边往中间逼近，并没有什么边界问题，主要是注意在寻找最多水的容器过程中要一直把较深的一边留下，即沿着较小的边界进行移动（因为较小的边界不可能再产生更多的水）。 参考https://blog.csdn.net/qq_40435621/article/details/84790436]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vim实用技巧]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fvim_skill%2F</url>
    <content type="text"><![CDATA[希望由厚至薄 概述 学习Vim，最难受的就是它对新手出名的不友好，网上一大堆乱七八糟的东西，还是自己进行学习对自己的帮助最大。建议首先学习 :vimtutor 入门vim学习。最好会盲打，自己看了这本 vim 实用技巧。 第 1 章 Vim解决问题的方式{char} 是指任意字符 指cw会删除光标位置到当前词位置结尾处的文本，并进入插入模式&gt;G是首行缩进C=c$ 删除到行尾再插入o=A下一行插入s删除光标处再插入@：重复命令行命令&amp;重复替换命令f{char} 搜索，; 下一个字符，, 上一个字符* 可以查看当前光标下的单词理想模式：用一个键移动，另一键执行。又称为 “.范式”。 第一部分 模式Vim 提供一个区分模式的用户界面，就是说在 Vim 中按键盘上的任意键所产生的结果可能会不一样，而这取决于当前正处于哪种模式，以及如何在各模式间切换，是极其重要的。在本书的这一部分，我们将学习每种模式的工作方式及其用途。 第 2 章 普通模式b 把光标移动到单词开头daw 在单词末尾也能删除 在数字上执行加一，不在数字上，在当前行正向查找一个数字，10 在数字上执行减一最好不要用数字 d2w 这样，因为 . 能很好代替，但是 c3w 有用，行中间来快速进行修改g~ 反转大小写，gu 转成小写，gU转成大写。gUap 将一段转换为大写，g 当成操作符前缀gc{motion} 切换为注释状态，gcap 切换当前段落的注释状态。gcG 当前行到文件结尾间的所有内容注释掉，gcc 注释当前行，gg=G 自动缩进整个文件。 第 3 章 插入模式在输入错误时，专业打字员会建议先删除整个单词，然后再重新输入一遍。 删除前一个字符（同退格键） 删除前一个单词 删至行首。&lt;c-[&gt;切换到普通模式， 切换到插入-普通模式。在此模式中，可以执行一个普通模式命令，执行完后，马上又返回到插入模式 按键操作 缓冲区内容 yt, Practical Vim, by Drew NeilRead Drew Neil’s jA␣ Practical Vim, by Drew NeilRead Drew Neil’s 0 Practical Vim, by Drew NeilRead Drew Neil’s Practical Vim . Practical Vim, by Drew NeilRead Drew Neil’s Practical Vim. yt, 命令把“Practical Vim”复制到复制专用寄存器中,0 把刚才复制的文本粘贴到光标所在位置= 符号指明使用表达式寄存器,=6*35，将执行结果插入到文档的当前位置{code}根据字符编码插入字符，{code} 是要插入字符的编码，065插入Au{1234} 以十六进制字符编码插入字符ga 分别以十进制和十六进制的形式显示出其字符编码{char1}{char2} 插入以二合字母{char1}{char2}表示的字符，?I 表示的“¿”字符，二合字母 12 指1⁄2R 命令可以由普通模式进入替换模式，“,␣b” 替换原有的“. ␣ B”字符gR 进入虚拟替换模式(Virtual Replace mode)，把制表符当成一组空格进行处理，输入制表符占据的最后一个字符，该字符会替换制表符。 第 4 章 可视模式viw 来高亮选择这个词,用 c 命令进行修改V 激活面向行的可视模式 激活面向列块的可视模式gv 重选上次的高亮选区o 切换高亮选区的活动端，vbb ，o ，e重复执行面向行的可视命令，Vj ，&gt;.vit 可被解读为高亮选中标签内部的内容(visually select inside the tag),it 命令是一种被称为文本对象(text object)gUit 要优于 vitU 命令，首选操作符命令，再者是可是模式命令，可视模式擅长一次性处理和动作命令难以构建的文本范围技巧24 面向列块的可是模式编辑表格数据，在一行下生成分割线 yyp，Vr-列块可视模式,插入操作只影响顶行，但实际影响所有，插入模式时间很短暂I 命令把光标置于当前行的开头 第 5 章 命令行模式有些命令在插入模式和命令行模式中可以通用。例如,可以用 和 分别删除至上个单词的开头及行首,也可以用 或 来插入键盘上找不到的字符,还可以用 {register} 命令把任意寄存器的内容插入到命令行。Ex 命令可以在任意位置执行 :3d 等于 3G dd 一定程度上要比普通模式命令要快. 代表当前行的地址，:.,$d 这样的命令可能很实用% 代表当前文件中的所有行，:%s/Practical/Pragmatic/可视模式加命令行模式，VG，输入 ：命令行上就会预先填充一个范围 :’&lt;,’&gt; 。代表高亮选区的范围:6copy. 命令解读为“为第 6 行创建一份副本,并放到当前行下方”，:copy 简写:co 或是 :t:t6 把当前行复制到第 6 行下方，:t$ 把当前行复制到文本结尾快速跳回原先的位置( )，在复制距离较远的行时, :t 命令通常更加高效。: yyp 会使用寄存器，不想覆盖默认寄存器中的当前内容时，可以考虑使用 :t. 来复制行:’&lt;,’&gt;m$ 等于 :’&lt;,’&gt;m$，重复上次的 Ex 命令 @:‘&lt;,’&gt;normal . 命令可以解读为“对高亮选区中的每一行,对其执行普通模式下的 . 命令”。:%normal i// 把整个 JavaScript 文件注释掉:normal 命令则让我们可以把具有强大表现力的 Vim 普通模式命令与具有大范围影响力的 Ex 命令结合在一起遍历缓冲区列表的条目，:bn[ext] 可以在列表中逐项正向移动,而 :bp[revious] 命令则进行反向移动 逐个查看每个缓冲区 :bnext，@: 命令和:bprevious 命令可能会出现反向遍历缓冲区列表，将人搞糊涂，更好用 命令，该命令会回到跳转列表的上条记录。想往回跳,就用 命令。 命令会让 Vim 显示可用的补全列表，按 键依次显示 用于插入光标下的单词，插入光标下的字串，一般和 * 、:%s 一起使用，:%s///g命令行窗口就像是一个常规的 Vim 缓冲区,只不过它的每行内容都对应着命令历史中的一个条目。我们可以用 k 及 j 键在历史中向前或向后移动,也可以用 Vim 的查找功能查找某一行。在按下 键时,将会把当前行的内容当成 Ex 命令加以执行。好处是强大的vim编辑能力可以派上用场。q: 调出命令行窗口，J 命令合并下一行，命令行窗口处于打开状态时,它会始终拥有焦点。 从命令行模式切换到命令行窗口，已经输入到命令行上的内容仍然会得以保留:!ls 执行 Shell 中的程序，在 Vim 的命令行中,符号 % 代表当前文件名(指调用了shell程序时)执行几条命令:shell 命令来启动一个交互的 shell 会话,用 exit 命令可以退出此 shell 并返回 Vim把 Vim 置于后台，看书 p 94 命令会产生大量输出，用:read !{cmd} 命令，它让我们把命令的标准输出重定向到缓冲区。:write !{cmd} 做相反的事。它把缓冲区内容作为指定 {cmd} 的标准输入:write! sh 把缓冲区内容写到一个名为 sh 的文件，叹号放得位置不同,命令的作用]也大相径庭。:write !sh 命 令 的 作 用 是 在 shell 中 执 行 当 前 缓 冲 区 中 的 每 行 内 容Vim 把过滤器定义为“一个由标准输入读取文本,并对其进行某种形式的修改后输出到标准输出的程序”:2,$!sort -t’,’ -k2，命令行结合 shell 来对文本进行处理。Vim 提供了一种方便的快捷方式来设置 :[range]!{filter} 命令中的范围。我们可以用 !{motion} 操作符切换到命令行模式,并把指定 {motion} 所涵盖的范围预置在命令行上，如果我们把光标移到第 2 行,然后执行 !G ,Vim 就会打开命令行并把范围 :.,$! 预置在命令行上。虽然此后我们仍需输入剩下的 {filter} 命令,但这毕竟节省了部分工作。:read !{cmd} 在 shell 中执行 {cmd} ,并把其标准输出插入到光标下方:[range]write !{cmd} 在 shell 中执行 {cmd} ,以 [range] 作为其标准输入:[range]!{filter} 使用外部程序 {filter} 过滤指定的 [range] 第二部分 文件在本书的这一部分，我们将学习如何使用文件及缓冲区。Vim 允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。另外，我们还会看到在 Vim 中打开文件的机种不同方式，并掌握一些方法来解决无法把缓冲区保存到文件的问题。 第 6 章 管理多个文件我们编辑的只是内存中的映像，也就是 Vim 术语中的“缓冲区”。 :ls 命令会列出所有被载入到内存中的缓冲区的列表， :bnext 命令可以切换到列表中的下一个缓冲区，% 符号指明哪个缓冲区在当前窗口中可见，而 # 符号则代表轮换文件。按 &lt;C-^&gt; 可以在当前文件和轮换文件间快速切换。 :bprev (bp) 和 :bnext (bn)在列表中反向或正向移动；而 :bfirst 和 :blast 则分别跳到列表的开头和结尾 12《 1 # "a.txt" line 1 2 %a "b.txt" line 1 :buffer N 命令直接凭编号跳转到一个缓冲区，:buffer {bufname} 格式实现同样的功能。{bufname} 只需包含文件路径中 足以唯一标识此缓冲区的字符即可 删除缓冲区，可以用 :bdelete 命令, :5,10bd ,删除编号 5～10（包含 5 和 10）的缓冲区 用 :argdo 命令可以在参数列表中的每个文件上执行一条 Ex 命令。 当不带参数运行 :args 命令时，它会打印当前参数列表的内容。 :args {arglist} {arglist} 可以包括文件名、通配符，甚至是一条 shell 命令的输出结果 填充参数列表最简单的方式是逐一指定文件的名字：➾ :args index.html app.js 通配符也匹配 0 个或多个字符，但它可以递归进入指定目录的子目录 :args /.js , :args **/.js */.css :args cat .chapters 按 Go 在缓冲区的结尾增加一个空行,缓冲区 a.txt 前有一个 + 号，表示这个缓冲区被修改过了,被标记为 h，表示它是一个隐藏缓冲区（hidden） :w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区（即回滚所做修改） :qa[ll]! 关闭所有窗口，摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 启用‘hidden’选项,运行完 :argdo {cmd} 后,一切正常，可以运行 :argdo write （或 :wall）来保存所有的缓冲区。 用 s 命令可以水平切分此窗口，使之成 为两个高度相同的窗口；或者可以用 v 命令对其进行垂直切分，这样会产生两 个宽度相同的窗口 编辑长文件时,可以滚动其中一个窗口，使之显示缓冲区的一部分，这样，在修改第二 个窗口中缓冲区的另外一部分时，就可以参考第一个窗口中的内容。 :sp[lit] {file} 水平切分当前窗口，并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口，并在新窗口中载入{file}w 在窗口间循环切换 h 切换到左边的窗口 j 切换到下边的窗口 k 切换到上边的窗口 l 切换到右边的窗口,按住 键，然后再输入 ww （或 wj ，或上表中的其他命令）来切换活动窗口。 = 使所有窗口等宽、等高 _ 最大化活动窗口的高度 | 最大化活动窗口的宽度 [N]_ 把活动窗口的高度设为[N]行 [N]| 把活动窗口的宽度设为[N]列,用鼠标做最好 用 :edit 命令打开一个文件时，Vim 却不会自动创建一 个新标签页，而是会创建一个新缓冲区，并把该缓冲区显示到当前窗口。应该把标签页想成容纳一系 列窗口的容器 :lcd {path} 命令让我们可以设置当前窗口的本地工作目录。如果我们创建了一 个新标签页，并用 :lcd 命令切换到另一个目录，那么就可以把每个标签页限制在不 同的工程范围内。用 :tabedit {filename} 命令可以打开一个新的标签页，如果省略了 {filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区 T 命 令把当前窗口移到一个新标签页中 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页，关闭所有其他标签页 :tabmove [N] 命令可以重新排列标签页。省略了 [N]，当前标签页会被移到结尾，如果支持鼠标，则用鼠标拖拽 第 7 章 打开及保存文件:edit {file} 命令可以接受相对于工作目录的文件路径 % 符号代表活动缓冲区的完整文件路径，:h 修饰符会去除文件名，但保留路径中的其他部分 :edit %:hM $ vim . 在按 键时，Vim 会打开光标下的条 目。如果光标位于目录上，那么此窗口的内容会更新为该目录的内容；如果光标位于文件上，那么该文件会被载入一个缓冲区里，并把它显示在当前窗口中。这将导致当 前窗口中的文件管理器被该缓冲区的内容所替代 :edit . :e. 打开文件管理器，并显示当前工作目录 :Explore :E 打开文件管理器，并显示活动缓冲区所在的目录 :E 及 :e. 命令表现得有些古怪，因为它们会用文件管理器替换掉当前窗口的内容，想象成一张纸牌，如果在调出文 件管理器后，又想切换回刚才正在编辑的那个文件，此时可以使用 &lt;C-^&gt; 命令。 杀手级功能，其名字正因为此功能而来，即 netrw 可 以通过网络读写文件。该插件可以利用多种协议读写网络文件，包括 scp、ftp、curl 及 wget，这取决于你的系统上可以用哪些协议。（手动流汗） 命令用于显示当前文件的文件名及状态，以超级用户执行，tee /etc/hosts &gt; /dev/null。这条命令会把缓冲区的内容当作标准输入，并用它来覆盖 /etc/hosts 文件的内容，下面文件与缓冲区的内容刚好是完全一致的。 第三部分 更快地移动及跳转动作命令是进行 Vim 操作的最重要的一些命令。我们不仅可以用它们四处移动光标，还能够用它们与操作符待决模式配合使用，指定一段文本范围并在其上进行操作。在本书的这一部分，我们将结识一些最为有用的动作命令，另外，我们还会学习 Vim 的跳转命令，这些命令让我们可以在文件间快速地跳转。 第 8 章 用动作命令在文档中移动我们不用把手从本位行上移开，就可以上下左右移动，操作符待决模式中最出彩的明星是文本对象如果你在一行中连续按了两次以上的 h 键，那就是在浪费时间（手动流汗）。 即 j、k、0和 $ 都用于操作实际行，而如果在这些 键前加上 g 前缀的话，就会让 Vim 对屏幕行进行操作 w 正向移动到下一单词的开头 (for-)wordb 反向移动到当前单词/上一单词的开头 back-worde 正向移动到当前单词/下一单词的结尾ge 反向移动到上一单词的结尾ea 命令连在一起可被解读为“在当前单词结尾后添加”gea 命令当成“在上一单词结尾后 添加”的命令 我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对 应，这当中包括 W、B、E和 gE一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白 字符分隔，字串的定义则更简单，它由非空白字符序列组成， 字串间以空白字符分隔 Vim 会记录 上次执行过的 f{char} 命令，随后用 ; 命令就可以重复该命令了，用 , 命令就可以再跳回来f{char} 正向移动到下一个 {char} 所在之处F{char} 反向移动到上一个 {char} 所在之处t{char} 正向移动到下一个 {char} 所在之处的前一个字符上T{char} 反向移动到上一个 {char} 所在之处的后一个字符上; 重复上次的字符查找命令, 反转方向查找上次的字符查找命令 f,dt.训练成手指的下意识动作（删除 , 和 . 之间的内容） 缺省的 键是 \ 查找命令不仅限于在普通模式下使用，我们也可以在可视模式及操作符待决模式 中使用它，用来完成实际的工作删除工作会更方便，先高亮然后通过命令行模式进行大范围选择。d/ge 用 /ge 查找动作告诉 d{motion} 命令删除什么。查找命令是 一个开动作，也就是说，虽然光标是在单词“gets”开头的“g”上的，但此字符却被 排除在删除操作之外，用 v 还需要 h 一下把 d{motion} 操作符与查找动作结 合在一起使用，这是个很大的进步，你可以好好在朋友和同事们面前炫耀一番了 可以把 i 想成“inside”，而把 a 想成 “around” 或“all”。 文本对象自身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以 在可视模式及操作符待决模式中使用文本对象 ：每当在命令语法里看到 {motion} 时，你也可以在这个地方使用文本对象，常见的例子包括 d{motion}、 c{motion}和 y{motion} 把 ci” 命令解读为“修改双引号内部的内容”，把 cit 命令解读为“修 改标签内部的内容”。另外，我们也可以很容易地用 yit 命令拷贝标签内的文本，或 者是用 dit 删除这些文本。 如果说 f{char} 和 /pattern 命令如同单足飞踹， 那么文本对象则像是一次攻击两个目标的剪刀腿 iw 和 aw 之间的区别很微妙，为什么会需要这样两个文本对象呢？ciw 命令只删除该单词，而不删除其前后的空白字符，随后它会进入插入模式， 这刚好是我们想要的效果。如果用的是 caw 的话，那最后两个单词就会连在一起一般来说，d{motion} 命令和 aw、as 和 ap 配合起来使用比较好，而 c{motion} 命令和 iw 及类似的文本对象一起用效果会更好。 m{a-zA-Z} 命令会用选定的字母标记当前光标所在位置,mm 和 `m 命令是一对便于使用的命令，它们分别设置位置标记 m，以及跳转到 该标记% 命令允许我们在一组开、闭括号间跳转,在执行 % 命令时，Vim 会 自动为发生跳转的地方设置一个位置标记, % 命令只能用在配对的括号上,所以利用替换命令时最好利用位置标记，防止陷阱。 第 9 章 在文件间跳转:jumps 查看跳转列表的内容，如果我们运行 :edit 命令 打开了一个新文件，那么就可以用 和 命令在这个新文 件以及原本的文件之间来回跳转，会始终在 当前活动窗口的跳转列表范围内进行跳转， Vim 本来就把 和 当成同一个东西。映射需谨慎。 Vim 会在编辑会话期间维护一张表，里面记载我们对每个缓冲区所做的修改， 此表就是所谓的改变列表 :changes，用 g; 和 g, 命令反向或正向遍历改变列表。改变列表中则保存了多组位置。我们可以多次按 g; 命令，每次它都会把 我们带到改变列表中较早的一个位置，而 `. 则总是把我们带到改变列表的最后一项。 执行 gf 命令“go to file”加上 .rb 扩展名，用 ‘suffixesadd’ 选项做到这一点 :set suffixesadd+=.rb查看 ‘path’ 选项的值:set path?《 path=.,/usr/include,,&lt;C-]&gt; 命令的作用也类似。它也需要进行一些配置（在技巧 102 中讨论），然而 一旦正确配置好，它就允许我们从函数调用的地方直接跳到该函数定义的地方 用两次按键就可以打开你的 vimrc 文件，先打开你的 vimrc 文件，按 mV 设置一个全局标记（助记词 V 代 表 vimrc），然后切换到另一个文件中按 `V 缺省情况下，:vimgrep 会直接跳到它所找到的第一处匹配上，这或许会切换到 另外一个文件。一般来说，要养成在使用与 quickfix 列表有关的命令前，如:grep、:vimgrep 及:make，设置全局标记的习惯。另外，在执行与缓冲区列表或参数列表有关的命令前， 如:args {arglist}和:argdo（参见技巧 37），也要设置全局标记。 你总共可以设置 26 个全局位置标记，可以迅速跳回。 第四部分 寄存器Vim 的寄存器是一组用于保存文件的简单容器。它们既可像剪贴板那样，剪切、复制和粘贴文本；也可以记录一系列按键操作，把它们录制成宏。通过本书的这一部分，我们将掌握这一核心功能。 第 10 章 复制与粘贴xp，可被用于“调换光标之后的两个字符”ddp，可被用于“调换当前行和它的下一行” diw 命令不仅删除了单词，而且还将它拷贝到了无名寄存器，按 P时得到的是刚刚删除的单词，而不是之前复制的单词，给命令加 “{register} 前缀的方式指定要用的寄存器，Vim 将缺省使用无 名寄存器。”ayiw复制，用 “bdd删除，”ap粘贴，可以解决无名寄存器的问题，使用复制寄存器也可以解决，黑洞集训器从删除方面也可以解决 Vim 的 delete 命令也与标准剪切操作的作用一致。也就是说，该命令会先把 指定文本复制到寄存器后再从文档中删掉，引用黑洞寄存器，”_d{motion}会执行真正的删除操作。 无名寄存器（””）， “”p，它完全等同于 p命令，x 和 d{motion} 经常被当作“删除”命 令。这其实是用词不当，把它们理解为“剪切”命令会更合适 复制专用寄存器（”0）使用 y{motion} 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，因为专用，只有 y 能触发 检查无名寄存器和复制专用寄存器的内容，:reg “0 ，小问题用复制专用寄存器，如果碰到需要将一段或多段文本粘贴到多处的情况，有名寄存器就会大显神通。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后 如果我们在外部程序中用剪切或复制命令获取了文本，就可以通过 “+p 命令（或 在插入模式下用 +）将其粘贴到 Vim 内部。相反地，如果在 Vim 的复制或删除 命令之前加入 “+ ，相应的文本将被捕获至系统剪贴板。“+ X11 剪贴板，用剪切、复制与粘贴命令操作 “ X11 主剪贴板，用鼠标中键操作把它们粘贴出来，Windows与Mac OS X操作系统并没有主剪贴板的概念，因此 “+ 寄存器与 “ 寄 存器可以混用，它们都代表系统剪贴板。 表达式寄存器（”=）当我们从表达式寄存器获取内容时，Vim 将跳到命 令行模式，并显示提示符“=”。这时，我们可以输入一段 Vim 脚本表达式并按 执行，如果返回的是字符串（或者可被强制转换成字符串的数据），Vim 将会使用它 只读寄存器 “% 当前文件名 “# 轮换文件名 “. 上次插入的文本 “: 上次执行的Ex命令 “/ 上次查找的模式 在可视模式下使用 p 命令时，Vim 将用我们指定的寄存器内容来替换高亮选区中的文本，可视再次解决了文本”丢失”现象，我们输入 u 撤销上次的修改。然后，按 gv重选上一次高亮选区的内容，再按一次 p键。发生了什么？显然什么也没发生，第一次使用 p时，之所以成功，是因为无名寄存器恰巧包含了我们想要的 文本。但在第二次使用 p时，无名寄存器包含的是被覆盖的内容，所以可是模式替换内容也会进入无名寄存器 在 Vim 的可视模式下使用 p命令时。首先，从无名寄存器里取出内容，然后，把高亮选区中的内容存入无名寄存器。（花里胡哨） c3w命令删除“chips and fish”并重新输入“fish and chips”， 应该会更快地完成任务。但是，以上方法可被用于交换更长的短语 p 命令旨在将寄存器中的文本粘贴到光标之后，P 命令用于将文本插入到光标之前，puP 和 Pup几乎成了下意识动作。当要粘贴的内容来自于面向行的寄存器时，p 和 P 命令会把它们粘贴至当前行的 上一行或下一行。这一点比面向字符的行为更直观 在插入模式下，我们可以通过输入 “ 来插入无名寄存器的内容，或者输入 0来插入复制专用寄存器的内容gp和 gP命令也值得关注，它们会把光标的位置移到被粘贴出来的文本结尾而不是开头。 当复制多行文本时，gP命令尤为管用，P 和 gP 命令区别 如果你运行的 Vim 是已集成系统剪贴板的版本，就可以完全避免与’paste’ 选项打交道了。普通模式下的 “+p 命令用来粘贴加号寄存器中的内容，即系统剪 贴板的镜像。 第 11章 宏]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux学习4]]></title>
    <url>%2F2019%2F01%2Fyuque%2Flinux_learning4%2F</url>
    <content type="text"><![CDATA[linux文件权限设置 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html chmod命令 概述chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 -rw-r–r– 1 root root 296K 11-13 06:03 log2012.log 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。 命令格式chmod [-cfvR] [–help] [–version] mode file 命令功能用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。 命令参数 必要参数1234-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数12345--reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限--version 显示版本信息&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围1234u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限代号123456r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限 该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 文字设定法 chmod ［who］ ［+ | - | =］ ［mode］ 文件名 数字设定法我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o） chmod ［mode］ 文件名 常用命令实例：增加文件所有用户组可执行权限命令：chmod a+x log2012.log说明：即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。实例：同时修改不同用户权限命令：chmod ug+w,o-x log2012.log实例：删除文件权限命令：chmod a-x log2012.log实例：使用“=”设置权限命令：chmod u=x log2012.log说明：撤销原来所有的权限，然后使拥有者具有可读权限实例：对一个目录及其子目录所有文件添加权限命令：chmod -R u+x test4说明：递归地给test4目录下所有文件和子目录的属主分配权限命令：chmod 751 filechmod u=rwx,g=rx,o=x file说明：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限命令:chmod =r filechmod 444 filechmod a-wx,a+r file说明：所有用户分配读权限 chgrp命令 概述在Linux系统里，文件或目录的权限掌控以拥有者及所诉群组来管理。可以使用chgrp指令去变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内才行。 命令格式chgrp [选项] [组] [文件] 命令功能chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。 命令参数 必要参数123456-c 当发生改变时输出调试信息-f 不显示错误信息-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细的处理信息--dereference 作用于符号链接的指向，而不是符号链接本身--no-dereference 作用于符号链接本身 选择参数123--reference=&lt;文件或者目录&gt;--help 显示帮助信息--version 显示版本信息 常用命令实例：改变文件的群组属性命令：chgrp -v bin log2012.log说明：将log2012.log文件由root群组改为bin群组123456[root@localhost test]# ll---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chgrp -v bin log2012.log“log2012.log” 的所属组已更改为 bin[root@localhost test]# ll---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log 实例：根据指定文件改变文件的群组属性命令：chgrp –reference=log2012.log log2013.log说明：改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同实例：改变指定目录以及其子目录下的所有文件的群组属性命令：chgrp -R bin test6说明：改变指定目录以及其子目录下的所有文件的群组属性实例4：通过群组识别码改变文件群组属性命令：chgrp -R 100 test6说明：通过群组识别码改变文件群组属性，100为users群组的识别码，具体群组和群组识别码可以去/etc/group文件中查看 chown命令 概述chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以使组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将问价拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 命令格式chown [选项]… [所有者][:[组]] 文件… 命令功能通过chown改变文件的拥有组和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者，其操作权限一般为管理员。 命令参数 必要参数123456-c 显示更改的部分的信息-f 忽略错误信息-h 修复符号链接-R 处理指定目录以及其子目录下的所有文件-v 显示详细的处理信息-deference 作用于符号链接的指向，而不是链接文件本身 选择参数1234--reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组--from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变--help 显示帮助信息--version 显示版本信息 常用命令实例：改变拥有者和群组命令：chown mail:mail log2012.log 实例：改变文件拥有者和群组命令：chown root: log2012.log 实例：改变文件群组命令：chown :mail log2012.log 实例：改变指定目录以及其子目录下的所有文件的拥有者和群组命令：chown -R -v root:mail test6 /etc/group文件详解 概述Linux /etc/group文件与/etc/passwd和/etc/shadow文件都是有关于系统管理员对用户和用户组管理时相关的文件。linux /etc/group文件是有关于系统管理员对用户和用户组管理的文件,linux用户组的所有信息都存放在/etc/group文件中。具有某种共同特征的用户集合起来就是用户组（Group）。用户组（Group）配置文件主要有 /etc/group和/etc/gshadow，其中/etc/gshadow是/etc/group的加密信息文件。将用户分组是LInux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 格式用户组的所有信息都存放在/etc/group文件中。此文件的格式是由冒号(:)隔开若干个字段，这些字段具体如下1组名:口令:组标识号:组内用户列表 组名：组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。口令：口令字段存放的是用户加密后的口令字。一般LInux系统的用户组都没有口令，即这个字段一般为空，或者是*。组标识号：组标识号与用户表示号类似，也是一个整数，被系统内部用来标识组，别称GID组内用户列表：是属于这个组的所有用户的列表，不同的用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 使用实例[root@localhost test6]# cat /etc/grouproot:x:0:root,linuxsirbin:x:1:root,bin,daemondaemon:x:2:root,bin,daemonsys:x:3:root,bin说明：我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[servlet学习ing]]></title>
    <url>%2F2018%2F11%2Fservlet%2F</url>
    <content type="text"><![CDATA[http协议：超文本传输协议概念和作用特点作用：规范浏览器（客户端）与服务器之间的数据交互 特点：简单、快捷、灵活、无连接（http1.1后支持可持续连接）、无状态（没有记忆，数据量大，新应答快速） 交互流程、请求格式、请求方式交互流程：客户端和服务器建立连接客户端法发送请求到服务器端服务器端接收到请求后进行处理，然后将处理结果相应客户端关闭客户端和服务器端的连接（HTTP1.1后不会立即关闭）请求格式：结构：请求头、请求行、空行、请求数据​​请求方式（结构大致一样，方式可能不同）：HTTP1.0：GET（？后有请求数据，不安全）、POST、HEAD方法HTTP1.1：OPTIONS、PUT、DELETE、TRACE、CONNECT方法​ 响应格式的结构和常见的状态码响应行（状态行）：HTTP版本、状态码、状态消息响应头：消息报头、客户端使用的附加信息空行：响应头和响应实体之间必须的响应实体：正文，服务器返回浏览器的信息​​常见的状态码（告诉浏览器）：​​ 服务器（主流是Tomcat）：本质：实际上就是java网络编程用代码编写的一个容器Tomcat目录结构：​​因为含有class文件，所以一定要依靠jdk，java虚拟环境 Servlet技术：概念和介绍 程序员在编写代码的时候如果能够按照服务器能够识别的规则进行编写，浏览器按照指定的规则进行发送请求（服务器识别就类似于JVM找main（）方法似的，有指定的规则），那么服务器就可以调用并执行响应的逻辑代码进行请求处理了。 ​​ 本质上就是服务器能够识别的接口规范1.创建普通的java类并继承HttpServlet方法2.覆写service方法3.在service方法中书写逻辑代码就行4.在webRoot下的WEB-INF文件夹下的web.xml文件中配置servlet（确保能找到）现在很多IDE环境不需要将class文件移交到相应的Tomcat下 运行（访问）流程：URL: http://localhost:8080/01.MyServlet/my2组成：服务器地址：端口号/服务器下webapps下的文件夹的名称（虚拟项目名）/（servlet的别名）要执行的servlet的url-pattern（因为防止包名类名被黑客利用，需有一定的隐藏，所以采用url-pattern的规则） URI：虚拟项目名/ servlet的别名123456789&lt;servlet&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjsxt.servlet.MyServlet2&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;url-pattern&gt;/my2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 相当于起一个别名，通过web.xml下找到my2，再找到包类名，找不到则404（my2相当于暗号）服务器会加载一下本地的文件，删除文件并关闭服务器再打开会提示报错信息 Servlet生命周期：1.第一次调用到服务器关闭2.如果servlet在web.xml中配置了load-on-startup之间的数字表示顺序，生命周期为从服务器启动到服务器关闭3.注意：Init方法是对servlet进行初始化的一个方法，会在servlet第一次加载进行存储时进行Destroy方法是在servlet销毁时执行 Jsp中的表单数据：​​ Service和doGet和doPost方法的区别： Service方法:可以处理get、post方式的请求，如果servlet中包含service方法，优先调用service方法对请求进行处理 doGet方法:处理get方式的请求 doPost方法:处理post方式的请求注意：如果在覆写的service方法中调用了父类的service方法（super.service（arg0,arg1））,则service方法处理后，会再次根据请求方式响应的doGet和doPost方法执行。一般情况下，不在service中调用父类的service方法，避免出现405错误 Servlet常见错误：404错误：资源未找到在请求地址中的servlet的别名书写错误虚拟项目名称拼写错误500错误：不可预估的错误在web.xml中校验servlet类的全限定路径是否拼写错误。service方法体的代码执行错误所致，根据错误提示对service方法体中的代码进行更改405错误：请求方式不支持请求方式和servlet中的方法不匹配所导致的，尽量使用service方法进行请求处理，并且不要在service方法中调用父类的service。 Request对象：介绍和获取请求头信息 服务器接收到浏览器的请求后，会创建一个request对象，对象中存储了此次请求相关的请求数据。服务器在调用servlet时会将创建好的request对象作为实参传递给servlet的方法，比如service方法。 使用：获取请求头数据、请求行数据、用户数据作用：request对象中封存了当前请求的多有请求信息注意：request对象由Tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法 Service中的形参以req为例子 获取请求头数据：获取请求方式12String method = req.getMethod();Sout(method); 获取请求URL12StringBuffer url = req.getRequestURL()l;Sout(url); 获取URI12String uri = req.getRequestURI();Sout(uri); 获取协议12String h = req.getScheme();Sout(h); 获取请求行数据;获取指定的请求行信息1String value = req.getHeader(“User-Agent”);//根据F12浏览器端找到的键值，加入想要获取666但是你没有，那么你在控制台后收到null 获取所有的请求行的键的枚举12Enumeration e = req.getHeaderNames();while(e.hasMoreElements())&#123; 获取所有键值1sout(e.nextElement()); 获取所有信息123String name = (String)e. nextElement();String value2= req.getHeader(name);Sout(name+”:”+value2); 获取用户数据：req.getParameter(“键名”);(返回指定的用户数据，不能获得同键不同值的多项选择数据，会漏值)​​ 避免漏值​​12req.getParameterValue(“键名”);(返回同键不同值的请求数据（多选），返回数组)req.getParameterNames(“键名”);(返回所有请求数据的枚举集合) 注意：如过要获取的请求数据不存在，不会报错，返回null。 request对象学习问题：在使用request对象获取请求数据并进行处理后，处理的结果如何显示到浏览器中？总结：Service请求处理代码流程：设置响应编码格式、获取请求数据、处理请求数据、数据库操作（MVC思想）、响应处理结果响应实体里面可以设置具体的html代码（无JSP的麻烦之处）乱码问题：记得服务器到浏览器，浏览器到服务器两个半流程中的编码规范问题servlet流程总结： Request作用域问题：使用请求转发后，不同的servlet之间怎么进行数据共享呢？或者说数据怎么从一个servlet流转给另外一个servlet呢？解决：使用request对象的作用域 请求转发：问题：服务器在接收到浏览器的请求后，仅仅使用一个servlet进行请求处理，会造成不同的servlet逻辑代码冗余，servlet的职责不明确解决：使用请求转发特点：一次请求、地址栏信息不改变 重定向学习问题：如果当前的请求servlet无法处理怎么办？如果使用请求转发，造成表单数据重复提交怎么办？解决：使用重定向 Cookie学习Cookie介绍、使用、设置有效期、信息获取 Cookie三天免登录 session学习session介绍及原理问题：request对象解决了一次请求内的不同servlet的数据共享问题，那么一个用户的不同请求的处理需要使用相同的数据怎么办呢？解决：使用session技术原理：用户使用浏览器第一次向服务器发送请求，服务器在接收到请求后，调用响应的servlet进行处理。在处理过程中会给用户创建一个session对象，用来存储用户请求处理相关的公共数据，并将此session对象的JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效）。用户在发起第二次请求及后续请求能够获取同一个session对象，也保证了不同请求能够获取到共享的数据。 session特点及使用特点：存储在服务器端、服务器进行创建、依赖cookie技术、一次会话作用：解决了一个用户不同请求的数据共享问题使用： 创建session对象/获取session对象 设置session存储时间（一般为30分钟） 设置session强制失效hs.invalidate(); 注意JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效） session数据流转和总结存储和获取数据使用时机：一般用户在登录web项目时会将用户的个人信息存储到session中，供该用户的其他请求使用总结：session解决了有个用户的不同请求的数据共享问题，只要在JSESSIONID不失效和session对象不失效的情况下，用户的任意请求在处理时都能获取到同一个session对象。作用域：一次会话（在JSESSIONID不失效和session对象不失效的情况下为整个项目内）session失效处理：将用户请求中的JSESSIONID和后台获取到的session对象JSESSIONID进行对比，如果一致则session没有失效，否则证明session失效了。重定向到登录界面，让用户重新登录。 解决主页面用户名显示为null的问题原因：因为在用户登录成功后使用重定向显示主页面，两次请求，而用户的信息在第一次请求中，第二次请求中没有用户数据，所以显示为null解决：使用session ServletContext对象学习问题：request解决了一次请求内的数据共享问题，session解决了用户不同请求的数据共享问题，那么不同的用户的数据共享该怎么办呢？解决：使用ServletContext对象作用：解决了不同用户的数据共享问题原理：ServletContext对象由服务器进行创建，一个项目只有一个对象。不管在项目的任意位置进行获取得到的都是同一个对象，那么不同用户发起请求获取到的也就是同一个对象了，该对象由用户共同拥有特点：服务器创建、用户共享、一个项目只有一个生命周期：服务器启动到关闭作用域：项目内使用：获取ServletContext对象/使用ServletContext对象完成数据共享获取项目中web.xml文件中的全局配置数据获取项目webroot下的资源的绝对路径/流对象使用ServletContext对象完成网页计数器在用户登录校验中创建计数器并自增，然后存储到ServletContext对象中，在主页面中取出计数器数据并显示给用户即可 ServletConfig对象问题：使用ServletConfig对象可以获取web.xml中的全局配置文件，在web.xml中每个servlet也可以进行单独的配置，那么该怎么获取配置信息呢？解决：使用ServletConfig对象作用：ServletConfig对象是servlet的专属配置对象，每个servlet都单独拥有一个ServletConfig对象用来获取web.xml中的配置信息使用： web.xml文件作用：存储项目相关的配置信息，保护servlet。解耦一些数据对程序的依赖使用位置：每个web项目中、tomcat服务器中（在服务器目录conf目录中）区别：web项目下的web.xml文件为局部配置，针对本项目的位置tomcat下的web.xml文件为全局配置，配置公共信息内容（核心组件）：全局上下文配置（全局配置参数）、servlet配置、过滤器配置、监听器配置加载顺序：web容器会按照ServletContext-&gt;context-param-&gt;listener-&gt;filter-&gt;servlet这个顺序加载组件，这些元素可配置在web.xml中的任意位置加载时机：服务器启动时 server.xml文件问题：浏览器发起请求后服务器根据请求在webapps目录下调用对应的servlet进行请求处理。那么为什么是webapps目录而不是其他的目录呢？解决：了解server.xml文件的配置信息server.xml文件核心组件：热部署：1&lt;Context path=&quot;/Pet&quot; reloadable=&quot;false&quot; docBase=&quot;F:/PetWeb&quot; /&gt; 参考链接：B站菜鸟教程]]></content>
      <categories>
        <category>Java</category>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2018%2F08%2Ffirst_hexo%2F</url>
    <content type="text"><![CDATA[你不能一直做一些烂事，然后自己后悔，好像后悔有用一样，你需要变好 想法 2017给了我很多最最美好的经历，目前对我最重要的年份是这一年,希望能继往开来希望自己能多给自己一些惊喜，少管些闲事，累了就休息，再也不失眠希望自己能跟着大佬学点东西，不要别人一张嘴你就一头雾水、一脸尴尬多看点书，学点东西，然后写一些对自己有用的博文 你要是无聊，它可以让你学不动，给你省了时间和金钱 计算机相关技术资料整理 https://github.com/EZLippi/practical-programming-books 编程书籍的整理和收集 https://github.com/KeKe-Li/book java 的书多一些 https://github.com/huangbaoquan/books 现在没太多时间读书，但可以整理一下，大家有好的链接不妨推荐一下放在这个博客中，方便以后有时间阅读寄语（鸡汤）没有不可治愈的伤痛，没有不能结束的沉沦，所有失去的，都会以另一种方式归来人生亦如逆旅，一切美好与温暖沉默如影，静立你的身后，不会迎头遇见，只要你不断走向远方，它便一路相随]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+nexT中的其他内容]]></title>
    <url>%2F2018%2F08%2Fhexo%2BnexT%2Bsomething%2F</url>
    <content type="text"><![CDATA[建议直接看最根本的东西 限于本人英语水平有限，建议大家直接到github上阅读相应的仓库获取最新知识，这样能避免很多错误，也不会被网上很多已经过时的东西影响。本人的版本： Theme versionversion: 5.1.4 hexo 版本 东拼西凑的东西每次输入都需要重新输入github帐号和密码？参考设置 SSH 使用 hexo deploy 时免输用户名密码设置好的状态： 版权声明之前的版本声明我觉得有点丑，除了有最新更新时间没有别的好处，而且那些声明明显落后于现在版本更新的速度，建议使用新版本里面的简洁声明 打开主题配置文件找到post_copyright1234post_copyright: enable: true #将false改成true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 设置gitment评论系统尝试过valine评论，但是决定作为程序员还是使用gitment比较好 最新版里面不需要添加配置文件只需要有app即可操作如下： 注册OAuth Application点击https://github.com/settings/applications/new注册参数说明：1234Application name： #应用名称Homepage URL： #网站URLApplication description #描述Authorization callback URL：#网站URL 修改themes/next/_config.yml在其中添加：12345678910111213141516# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: 不添加则跟随默认语言# Force language, or auto switch by theme跟随默认语言 github_user: Github名 # MUST HAVE, Your Github ID github_repo: .github.io的仓库 # MUST HAVE, The repo you use to store Gitment comments client_id: App id # MUST HAVE, Github client id for the Gitment client_secret: App secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 链接消除汉语在文章量不是很大的情况下建议直接设置链接的英文名，网上有相关教程我采用了转换，但是出了些小bug，但还能应付的过来 关于用自己的页面做页面请参考jacklightChenHexo-用自己的页面做首页 主题内添加相册功能（可能会出现卡顿）请参考asdfv1929Hexo NexT主题内添加相册功能 添加网页标题崩溃欺骗搞怪特效请参考asdfv1929Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效 添加加载效果打开主题配置文件搜索pace_theme看到下面这些效果，有很多种，挑选一个自己喜欢的就好了12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-loading-bar 最后 鉴于很多大佬都有相应的分享我就老老实实做一个搬运工，希望有更多人能有一个自己满意的博客网上有更多好的效果和实现方式欢迎与我交流 —-&gt;传送门]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github+ubuntu搭建个人博客]]></title>
    <url>%2F2018%2F08%2Fhexo%2Bhithub_pages%2BnexT%2F</url>
    <content type="text"><![CDATA[菜鸟初步搭建须知（是我没错，备忘）相应知识 会一些基本的Linux命令和vim的操作命令。可以在实验楼上入门学习 网上已经浏览了 官方文档 安装ubuntu和git（因为最近在学习用ubuntu，而且很多操作ubuntu上会更简单） 安装Node.js并拥有github账号 github上新建好一个专门的仓库，并最好熟悉github及其基本操作比如SSH密钥 以上知识网上有比较完善的信息，搜索关键字学习并进行必要的搭建前提已经完成下图： 建议大家选择不同的博客建站，可以参考有哪些好看的 Hexo 主题? 新手初步搭建可能有用搭建nexT主题可能有帮助的链接： https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.jianshu.com/p/a0a27d840992 https://www.jianshu.com/p/24cb74aeb0a3 http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 深入搭建，安装NexT主题Hexo 安装主题的方式非常简单，新建blog文档（命名随意）在其下打开终端操作即可，具体到 NexT 来说，安装步骤如下。 安装主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 具体还有以下步骤（自行网上搜索）： hexo init(第一次需要) hexo clean hexo g hexo s hexo d 启动主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件（官方文档中给出站点配置文件解释）， ctrl+f 搜索到 theme 字段，并将其值更改为 next，主题默认为landscape，建议选择Pisces或Gemini 1theme: next 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug，dubug会帮助你更好找到安装过程的错误），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 改动hexo 站点配置文件我们打开站点下的_config.yml文件 深入站点配置文件，事先变动RSS订阅 1.在hexo的根目录下执行命令： 1npm install hexo-generator-feed --save 2在根目录下的/theme/next/_config.yml文件中添加配置 123456feed: type: rss2 path: rss2.xml limit: 5 hub: content: 'true' 加入站点内容搜索功能 1.安装hexo-generator-searchdb 注意：安装时应在站点根目录下，即blog目录下 1$ npm install hexo-generator-searchdb --save 2.添加search字段，在站点blog/_config.yml中添加search字段，如下 12345search: path: search.xml field: post format: html limit: 10000 编辑远程部署 ，添加代码块 1234deploy: type: git repository: https://github.com/Thunderforrain/Thunderforrain.github.io.git branch: master 方便写博客，自动生成图片文档 1post_asset_folder: true 如果是flase 改成true 参考文章内添加图片 注意 : : 使用英文的，并且后面要有空格 执行完以上步骤，查找关键字来更改其他信息，最后结果大致如下(仅作最后的参考)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: Thunderforrain's Blog #网站标题subtitle: 实迷途其未远,觉今是而昨非 #网站副标题description: 菜鸟的 尝试，笨鸟的先飞 #网站描述keywords:author: Thunderforrain #博主的名字language: zh-Hans #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://thunderforrain.github.io/ ** #你网站的urlroot: /blog/ #子目录permalink: :year/:month/:day/:title/ #生成文件名字的格式permalink_defaults:# Directory 目录配置source_dir: source public_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章new_post_name: :title.md # File name of new posts （新建文章链接形式）default_layout: post # 默认布局（官方文档中给出其他布局）titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 render_drafts: false post_asset_folder: true #启动 Asset 文件夹,方便管理文章图片relative_link: false future: true highlight: #代码块设为true enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: # Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页（非全屏不显示）## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page search: path: search.xml field: post format: html limit: 10000# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next## Rss订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有) hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:Tenke007/Tenke007.github.io.git branch: master 改动hexo 主题配置文件建议参考网址，网上有比较好的教程:Never_yu’s Blog主题配置参考知了笔记Elegant theme for Hexo建议看一下我下一篇博客我们打开主题下的_config.yml文件 深入主题配置文件，里面可以添加很多东西（参考上述网址）： 在右上角或者左上角实现fork me on github 背景配置 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改“代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加Gitment评论系统 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 hexo 添加百度站长推送 hexo NexT主题首页title链接的优化 Hexo NexT主题修改文章标题样式 hexo 添加百度站长推送 参考上文知了笔记的hexo框架基于next主题定制 下文可作为理解帮助（仅作为最后的参考）:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexofavicon: ##网站的头像 small: /images/avatar.jpg medium: /images/avatar.jpg apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "记录耕耘"##网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml # 需要安装插件# Specify the date when the site was setupsince: 2015 网站时间，类似 2015-2016 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: #我的是自己设置可否评论，可以使用统一u形式，不同的评论方式不同 # ------------------------------------------------------------- # Hexo link (Powered by Hexo).#管理底部驱动信息，个人去了版本号 powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / categories: /categories #分类 tags: /tags #标签 archives: /archives #归档 #about: /about # 关于我 #sitemap: /sitemap.xml #这个可以不用开启，给搜索引擎用的，需要安装插件 #commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #上面menu的iconmenu_icons: enable: true home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next主题的三个schemes(默认是Muse)#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini #个人比较喜欢Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.#social: #社交链接，可以放github,weibo,qq等 GitHub: https://github.com/Thunderforrain || github CSDN: https://blog.csdn.net/Thunderforrain #微博: #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: #对应的社交icon enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo Wechat: wechat# Blog rolls #相关链接links_icon: linklinks_title: 友情链接links: git学习: http://github.phodal.com/ 馨客栈: http://www.mackxin.com/ CSL's Blog 的链接: http://cubercsl.cn/links/ jacklightChen's Blog: http://blog.lightina.cn/links_layout: block #Title: http://example.com/# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /images/avatar.jpg #博主头像（可以放外链）# Table Of Contents in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: #侧边栏，只对Pisces、Gemini有效 # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).像素菜单条边栏偏移量 offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: #设置为true,首页文章会显示 阅读全文，建议使用 &lt;!-- more --&gt; enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber #文章内显示微信二维码wechat_subscriber: enabled: true qcode: /images/wechat.png #微信二维码图片路径 description: 随便说点 #微信二维码描述#Reward #打赏功能，图片相应目录有或者外链reward_comment: 捐助菜鸡，提携笨鸟wechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on posts # 版权声明post_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme 代码高丽风格，个人喜欢默认版本# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: # ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key #第三方搜索（根据喜好选择，不举例了）#swiftype_key:# Baidu Analytics ID #百度分析#baidu_analytics:# Duoshuo ShortName #多说评论，已成为过去，不可使用duoshuo_shortname: tenke# Disqus #来必力评论#disqus_shortname:# changyan #畅言评论changyan: enable: false appid: appkey: # Hypercomments#hypercomments_id:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: #下面有东西，暂不举例，涉及隐私 # Gitment #需要github账号才能留言# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled:# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share #废弃duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: #弃用 ua_enable: true admin_enable: true user_id: admin_nickname: # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: #facebook相关 enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# --------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: #第三方用户访问插件，直接开启，根据喜好添加文字 # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp阅读数 page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search #自己添加# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0 #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-center-simple# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 最后一些想法1.科学上网（你懂的） 2.逐步升级博客（一次性弄好不现实） 3.先理解站点和主题配置文件（有些东西随着版本的更新，没有必要进行很麻烦的操作） 4.还有一部分东西可以自己查,希望对大家有所帮助 欢迎互加友情链接 ，互相交流—–&gt;传送门 一些博客实例： IIssNan’s NotesKevin Pu’s Blog Showo^^e吴小龙同學]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
