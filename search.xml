<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux学习4]]></title>
    <url>%2F2019%2F01%2Fyuque%2Flinux_learning4%2F</url>
    <content type="text"><![CDATA[linux文件权限设置 编译：peida&lt;br /&gt; 链接：[https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html](https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html) chmod命令概述chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 -rw-r–r– 1 root root 296K 11-13 06:03 log2012.log 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。 命令格式chmod [-cfvR] [–help] [–version] mode file 命令功能用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。 命令参数必要参数1234-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数12345--reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限--version 显示版本信息&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围1234u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限代号123456r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限 该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 文字设定法 chmod ［who］ ［+ | - | =］ ［mode］ 文件名 数字设定法我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o） chmod ［mode］ 文件名 常用命令实例：增加文件所有用户组可执行权限命令：chmod a+x log2012.log说明：即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。实例：同时修改不同用户权限命令：chmod ug+w,o-x log2012.log实例：删除文件权限命令：chmod a-x log2012.log实例：使用“=”设置权限命令：chmod u=x log2012.log说明：撤销原来所有的权限，然后使拥有者具有可读权限实例：对一个目录及其子目录所有文件添加权限命令：chmod -R u+x test4说明：递归地给test4目录下所有文件和子目录的属主分配权限命令：chmod 751 filechmod u=rwx,g=rx,o=x file说明：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限命令:chmod =r filechmod 444 filechmod a-wx,a+r file说明：所有用户分配读权限 chgrp命令概述在Linux系统里，文件或目录的权限掌控以拥有者及所诉群组来管理。可以使用chgrp指令去变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内才行。 命令格式chgrp [选项] [组] [文件] 命令功能chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。 命令参数必要参数123456-c 当发生改变时输出调试信息-f 不显示错误信息-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细的处理信息--dereference 作用于符号链接的指向，而不是符号链接本身--no-dereference 作用于符号链接本身 选择参数123--reference=&lt;文件或者目录&gt;--help 显示帮助信息--version 显示版本信息 常用命令实例：改变文件的群组属性命令：chgrp -v bin log2012.log说明：将log2012.log文件由root群组改为bin群组123456[root@localhost test]# ll---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chgrp -v bin log2012.log“log2012.log” 的所属组已更改为 bin[root@localhost test]# ll---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log 实例：根据指定文件改变文件的群组属性命令：chgrp –reference=log2012.log log2013.log说明：改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同实例：改变指定目录以及其子目录下的所有文件的群组属性命令：chgrp -R bin test6说明：改变指定目录以及其子目录下的所有文件的群组属性实例4：通过群组识别码改变文件群组属性命令：chgrp -R 100 test6说明：通过群组识别码改变文件群组属性，100为users群组的识别码，具体群组和群组识别码可以去/etc/group文件中查看 chown命令概述chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以使组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将问价拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 命令格式chown [选项]… [所有者][:[组]] 文件… 命令功能通过chown改变文件的拥有组和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者，其操作权限一般为管理员。 命令参数必要参数123456-c 显示更改的部分的信息-f 忽略错误信息-h 修复符号链接-R 处理指定目录以及其子目录下的所有文件-v 显示详细的处理信息-deference 作用于符号链接的指向，而不是链接文件本身 选择参数1234--reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组--from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变--help 显示帮助信息--version 显示版本信息 常用命令实例：改变拥有者和群组命令：chown mail:mail log2012.log 实例：改变文件拥有者和群组命令：chown root: log2012.log 实例：改变文件群组命令：chown :mail log2012.log 实例：改变指定目录以及其子目录下的所有文件的拥有者和群组命令：chown -R -v root:mail test6 /etc/group文件详解概述Linux /etc/group文件与/etc/passwd和/etc/shadow文件都是有关于系统管理员对用户和用户组管理时相关的文件。linux /etc/group文件是有关于系统管理员对用户和用户组管理的文件,linux用户组的所有信息都存放在/etc/group文件中。具有某种共同特征的用户集合起来就是用户组（Group）。用户组（Group）配置文件主要有 /etc/group和/etc/gshadow，其中/etc/gshadow是/etc/group的加密信息文件。将用户分组是LInux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 格式用户组的所有信息都存放在/etc/group文件中。此文件的格式是由冒号(:)隔开若干个字段，这些字段具体如下1组名:口令:组标识号:组内用户列表 组名：组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。口令：口令字段存放的是用户加密后的口令字。一般LInux系统的用户组都没有口令，即这个字段一般为空，或者是*。组标识号：组标识号与用户表示号类似，也是一个整数，被系统内部用来标识组，别称GID组内用户列表：是属于这个组的所有用户的列表，不同的用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 使用实例[root@localhost test6]# cat /etc/grouproot:x:0:root,linuxsirbin:x:1:root,bin,daemondaemon:x:2:root,bin,daemonsys:x:3:root,bin说明：我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux学习3]]></title>
    <url>%2F2019%2F01%2Flinux_learning3%2F</url>
    <content type="text"><![CDATA[文件查找命令 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html which命令概述我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：which查看可执行文件的位置whereis查看文件的位置locate配合数据库查看文件位置find实际搜寻硬盘查询文件名称which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 命令格式which 可执行文件名称 命令功能which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 命令参数1234-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名-p 与-n参数相同，但此处包含了文件的路径-w 指定输出时栏位的宽度-V 显示版本的信息 常用命令实例：用 which 去找出 which命令：which which which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！ whereis命令概述whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 命令格式whereis [-bmsu] [BMS 目录名 -f ] 文件名 命令功能whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 命令参数1234567-b 定位可执行文件。-m 定位帮助文件。-s 定位源代码文件。-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。-B 指定搜索可执行文件的路径。-M 指定搜索帮助文件的路径。-S 指定搜索源代码文件的路径。 常用命令实例：将和**文件相关的文件都查找出来命令：whereis man 实例：只将二进制文件 查找出来命令：whereis -b manwhereis -m man 查出说明文档路径，whereis -s man 找source源文件。 locate命令概述locate让使用者可以很快速搜索档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的distribution之中，数据库的建立都被放在crontab中自动执行。 命令格式locate [选择参数] [样式] 命令功能locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”” 或”?”等）来指定范本样式，如指定范本为kcpaner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库 命令参数123456789101112-e 将排除在寻找的范围之外。-1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会使速度减慢，因为 locate 必须至实际的档案系统中取得档案的权限资料。-f 将特定的档案系统排除在外，例如我们没有道理要把 proc 档案系统中的档案放在资料库中。-q 安静模式，不会显示任何错误讯息。-n 至多显示 n个输出。-r 使用正规运算式 做寻找的条件。-o 指定资料库存的名称。-d 指定资料库的路径-h 显示辅助讯息-V 显示程式的版本讯息 常用命令实例:查找和pwd相关的所有文件命令：locate pwd 实例： 搜索etc目录下所有以sh开头的文件命令：locate /etc/sh find命令概览概述Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 命令格式find pathname -options [-print -exec -ok …] 命令功能用于在文件树中查找文件，并做出相应的处理 命令参数1234pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&apos;command&apos; &#123; &#125; ;，注意&#123; &#125;和；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项12345678910111213141516171819202122232425262728-name 按照文件名查找文件-perm 按照文件权限来查找文件-prune 使用这一选项可以是find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略-user 按照文件所属主来查找文件。-group 按照文件所属的组来查找文件-mtime -n +n 按照文件的更改时间来查找文件，-n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项-nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。-type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。-mount：在查找文件时不跨越文件系统mount点。-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。另外,下面三个的区别:-amin n 查找系统中最后N分钟访问的文件-atime n 查找系统中最后n*24小时访问的文件-cmin n 查找系统中最后N分钟被改变文件状态的文件-ctime n 查找系统中最后n*24小时被改变文件状态的文件-mmin n 查找系统中最后N分钟被改变文件数据的文件-mtime n 查找系统中最后n*24小时被改变文件数据的文件 常用命令实例：查找指定时间内修改过的文件命令：find -atime -2说明：超找48小时内修改过的文件 实例：根据关键字查找命令：find . -name “*.log”说明：在当前目录查找 以.log结尾的文件。 “. “代表当前目录 实例：按照目录或文件的权限来查找文件命令：find /opt/soft/test/ -perm 777说明：查找/opt/soft/test/目录下 权限为 777的文件 实例：按类型查找命令：find . -type f -name “*.log”说明：查找当前目录，以.log结尾的普通文件 实例：查找当前所有目录并排序命令：find . -type d | sort 实例6：按大小查找文件命令：find . -size +1000c -print说明：查找当前目录大于1K的文件 find命令之exec概述find是我们很常用的一个Linux命令，但是我们一般查找出来的并不仅仅是看看而已，还会有进一步的操作，这个时候exec的作用就显现出来了。 exec解释-exec参数后面跟的是command命令，它的终止是以；为结束标志的，所以这句命令后面的分号是比不可少的，考虑到各个系统中分浩会有不同的意义，所以前面加反斜杠。{}花括号代表前面find查找出来的文件名使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用命令实例：ls -l命令放在find命令的-exec选项中命令：find . -type f -exec ls -l {} \;说明：上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。 实例：在目录中查找更改时间在n日以前的文件并删除它们命令：find . -type f -mtime +14 -exec rm {} \;说明：在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。 实例：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示命令：find . -name “*.log” -mtime +5 -ok rm {} \;说明：在上面的例子中， find命令在当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除。 实例：-exec中使用grep命令命令：find /etc -name “passwd“ -exec grep “root” {} \;说明：任何形式的命令都可以在-exec选项中使用。 在上面的例子中我们使用grep命令。find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 实例：查找文件移动到指定目录命令：find . -name “*.log” -exec mv {} .. \; 实例6：用exec选项执行cp命令命令：find . -name “*.log” -exec cp {} test3 \;说明: 当前目录中.log文件移动到该目录下的test3目录下 find命令之xargs概述在使用find命令的-exec选项处理匹配到的文件时，find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。find命令把匹配到的文件传递给xarg命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样，这样他可以最先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行，这样在有些情况就会出现进程过多，系统性能下降的问题，因而效率不高，而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数买还是分批取得所有参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 常用命令实例：查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件命令：find . -type f -print | xargs file 实例：在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中命令：find / -name “core” -print | xargs echo “” &gt;/tmp/core.log 实例:在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限命令：find . -perm -7 -print | xargs chmod o-w说明：执行命令后，相应的权限都发生改变 实例：用grep命令在所有的普通文件中搜索hostname这个词命令：find . -type f -print | xargs grep “hostname” 实例：用grep命令在当前目录下的所有普通文件中搜索hostnames这个词命令：find . -name * -type f -print | xargs grep “hostnames”说明：注意，在上面的例子中， \用来取消find命令中的*在shell中的特殊含义 实例：使用xargs执行mv命令：find . -name “*.log” | xargs -i mv {} test4 实例：find后执行xargs提示xargs: argument line too long解决方法命令：find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f说明：-l1是一次处理一个；-t是处理之前打印出命令 实例：使用-i参数默认的前面输出用{}代替，-I参数可以指定其他代替字符，如例子中的[]命令： find . -name “file” | xargs -I [] cp [] ..说明：使用-i参数默认的前面输出用{}代替，-I参数可以指定其他代替字符，如例子中的[] 实例9：xargs的-p参数的使用命令：find . -name “*.log” | xargs -p -i mv {} ..说明：-p参数会提示让你确认是否执行后面的命令,y执行，n不执行。 find命令的参数详解概述find一些常用参数的常用实例和一些具体方法和注意事项 使用name选项文件名选项是find命令最常用的选项，要么蛋酥使用该选项，要么和其他选项一起使用。可以使用某种文件名模式来匹配文件，记住要用引用将文件名模式引用起来。 不管当前路径是什么，如果想要在自己的根目录$HOME中查找文件名符合.log的文件，使用作为’pathname’参数，波浪号~代表了你的$HOME目录。find ~ -name “.log” -print 想要在当前目录及子目录中查找所有的‘ .log‘文件，可以用：find . -name “.log” -print 想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：find . -name “[A-Z]*” -print 想要在/etc目录中查找文件名以host开头的文件，可以用：find /etc -name “host*” -print 想要查找$HOME目录中的文件，可以用：find ~ -name “*” -print 或find . -print 要想让系统高负荷运行，就从根目录开始查找所有的文件。（手动狗头）find / -name “*” -print 如果想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件：命令：find . -name “[a-z]*[4-9].log” -print 使用perm选项按照文件权限模式用-perm选项，按文件权限模式来查看文件的话。最好使用八进制的权限表示法。 如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：find . -perm 755 -print 还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-005相当于555命令：find . -perm -005 使用-prune选项如果在查找文件希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你使用了-depth选项，那么-prune选项就会被find命令忽略。 如果希望在test目录下查找文件，但不希望在test/test3目录下查找命令：find test -path “test/test3” -prune -o -print 实例：在test 目录下查找不在test4子目录之内的所有文件命令：find test -path “test/test4” -prune -o -print说明：find [-path ..] [expression] 在路径列表的后面的是表达式-path “test” 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 -path “test” -a -prune 为假，则求值 -print ，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。 实例：避开多个文件夹:命令：find test ( -path test/test4 -o -path test/test3 ) -prune -o -print说明：圆括号表示表达式的结合。 \ 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。 实例：查找某一确定文件，-name等选项加在-o 之后命令：find test (-path test/test4 -o -path test/test3 ) -prune -o -name “*.log” -print 使用user和nouser选项按文件属主查找文件：实例1：在$HOME目录中查找文件属主为peida的文件命令：find ~ -user peida -print 实例2：在/etc目录下查找文件属主为peida的文件:命令：find /etc -user peida -print说明： 实例3：为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/home目录下查找所有的这类文件命令：find /home -nouser -print说明：这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。 使用group和nogroup选项就像user和nouser选项一样，针对文件所属于的用户组，find命令也具有同样的选项，为了在/apps目录下查找属于gem用户组的文件，可以用：find /apps -group gem -print 要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件：find / -nogroup-print 按照更改时间或访问时间等查找文件如果希望按照更改时间来查找文件，可以使用mtime，atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件，用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 希望在系统根目录下查找更改时间在5日以内的文件，可以用：find / -mtime -5 -print 为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:find /var/adm -mtime +3 -print 查找比某个文件新或旧的文件如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 它的一般形式为： newest_file_name ! oldest_file_name其中，！是逻辑非符号。 实例：查找更改时间比文件log2012.log新但比文件log2017.log旧的文件命令：find -newer log2012.log ! -newer log2017.log 实例：查找更改时间在比log2012.log文件新的文件命令：find . -newer log2012.log -print 使用type选项实例：在/etc目录下查找所有的目录命令：find /etc -type d -print 实例：在当前目录下查找除目录以外的所有类型的文件命令：find . ! -type d -print 实例：在/etc目录下查找所有的符号链接文件命令：find /etc -type l -print 使用size选项可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。 实例：在当前目录下查找文件长度大于1 M字节的文件命令：find . -size +1000000c -print 实例：在/home/apache目录下查找文件长度恰好为100字节的文件:命令：find /home/apache -size 100c -print 实例：在当前目录下查找长度超过10块的文件（一块等于512字节）命令：find . -size +10 -print 使用depth选项在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件 实例：find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。命令：find / -name “CON.FILE” -depth -print说明：它将首先匹配所有的文件然后再进入子目录中查找 使用mount选项在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。 实例:从当前目录开始查找位于本文件系统中文件名以XC结尾的文件命令：find . -name “*.XC” -mount -print 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习2]]></title>
    <url>%2F2018%2F12%2Flinux-learning2%2F</url>
    <content type="text"><![CDATA[文件目录操作命令(9-15） 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html touch命令概述linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。 命令格式touch [选项]… 文件… 命令参数1234567-a 或--time=atime或--time=access或--time=use 只更改存取时间。-c 或--no-create 不建立任何文档。-d 使用指定的日期时间，而非现在的时间。-f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。-m 或--time=mtime或--time=modify 只更改变动时间。-r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。-t 使用指定的日期时间，而非现在的时间。 命令功能touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 常用命令实例：更新log.log的时间和log2012.log时间戳相同命令：touch -r log.log log2012.log 实例：设定文件的时间戳命令：touch -t 201211142234.50 log.log 说明-t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] 这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch 将把年数CCYY限定在1969–2068之内．MM为月数，DD为天将把年数CCYY限定在1969–2068之内．MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数．此处秒的设定范围是0–61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时 间．由于系统的限制，早于1970年1月1日的时间是错误的。 cat命令概述cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 命令格式cat [选项] [文件]… 命令功能cat主要有三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file 命令参数12345678910-A, --show-all 等价于 -vET-b, --number-nonblank 对非空输出行编号-e 等价于 -vE-E, --show-ends 在每行结束处显示 $-n, --number 对输出的所有行编号,由1开始对所有输出的行数编号-s, --squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价-T, --show-tabs 将跳格字符显示为 ^I-u (被忽略)-v, --show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 常用命令实例：把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里。命令：cat -b log2012.log log2013.log log.log 实例：使用here doc来生成文件输出： [root@localhost test]# cat &gt;log.txt &lt;&lt;EOF &gt; Hello &gt; World &gt; Linux &gt; PWD=$(pwd) &gt; EOF [root@localhost test]# ls -l log.txt -rw-r--r-- 1 root root 37 10-28 17:07 log.txt [root@localhost test]# cat log.txt Hello World Linux PWD=/opt/soft/test [root@localhost test]# 实例：tac (反向列示)命令：tac log.txt 说明：tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！ nl命令概述nl 命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 命令格式nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 命令参数123456789-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种：-n ln ：行号在萤幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数。-p 在逻辑定界符处不重新开始计算。 命令功能nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 常用命令实例：用 nl 列出 log2012.log 的内容命令：nl log2012.log 实例：用 nl 列出 log2012.log 的内容，空本行也加上行号命令：nl -b a log2012.log 实例3：让行号前面自动补上0,统一输出格式命令： nl -b a -n rz -w 3 log2014.log说明：nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w 3 调整为3位。 more命令概述more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 命令格式more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ] 命令功能more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。 命令参数123456789+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉 常用操作命令Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 常用命令实例：从文件中查找第一个出现”day3”字符串的行，并从该处前两行开始显示输出命令：more +/day3 log2012.log 实例4：列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来命令：ls -l | more -5说明：每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息。 less命令概述less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在more的时候，我们并没有办法向前面翻，只能往后面看，但若使用了less时，就可以使用[pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容，除此之外，在less可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 命令格式less [参数] 文件 命令功能less与more类似，但使用less可以随意浏览文件。而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件。 命令参数1234567891011121314151617181920212223242526-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 常用命令实例：查看文件命令：less linux_learning.md 实例：浏览多个文件命令：less linux_learning.md java_entry_learning.md说明：输入 ：n后，切换到 log2014.log输入 ：p 后，切换到log2013.log 实例：查看命令历史使用记录并通过less分页显示命令：history | less 实例2：ps查看进程信息并通过less分页显示命令：ps -ef |lessLinux进程的基本概念 附加备注全屏导航ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 单行导航j - 向前移动一行k - 向后移动一行 其它导航123G - 移动到最后一行g - 移动到第一行q / ZZ - 退出 less 命令 其它有用的命令123v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件 标记导航当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：ma - 使用 a 标记文本的当前位置‘a - 导航到标记 a 处 head命令概述head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然就是看档案的结尾。 命令格式head [参数]… [文件]… 命令功能head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 命令参数1234-q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数 常用命令实例：显示文件的前n行命令：head -n 5 log2014.log 实例：文件的除了最后n个字节以外的内容命令：head -c -32 log2014.log 实例：输出文件除了最后n行的全部内容命令：head -n -6 log2014.log tail命令概述tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 命令格式tail[必要参数][选择参数][文件] 命令功能用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 命令参数12345678-f 循环读取-q 不显示处理信息-v 显示详细的处理信息-c&lt;数目&gt; 显示的字节数-n&lt;行数&gt; 显示行数--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. -q, --quiet, --silent 从不输出给出文件名的首部 -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 常用命令实例：循环查看文件内容命令：tail -f test.log [root@localhost ~]# ping 192.168.120.204 &gt; test.log &amp; [1] 11891[root@localhost ~]# tail -f test.log PING 192.168.120.204 (192.168.120.204) 56(84) bytes of data. 64 bytes from 192.168.120.204: icmp_seq=1 ttl=64 time=0.038 ms 64 bytes from 192.168.120.204: icmp_seq=2 ttl=64 time=0.036 ms 64 bytes from 192.168.120.204: icmp_seq=3 ttl=64 time=0.033 ms 64 bytes from 192.168.120.204: icmp_seq=4 ttl=64 time=0.027 ms 64 bytes from 192.168.120.204: icmp_seq=5 ttl=64 time=0.032 ms 64 bytes from 192.168.120.204: icmp_seq=6 ttl=64 time=0.026 ms 64 bytes from 192.168.120.204: icmp_seq=7 ttl=64 time=0.030 ms 64 bytes from 192.168.120.204: icmp_seq=8 ttl=64 time=0.029 ms 64 bytes from 192.168.120.204: icmp_seq=9 ttl=64 time=0.044 ms 64 bytes from 192.168.120.204: icmp_seq=10 ttl=64 time=0.033 ms 64 bytes from 192.168.120.204: icmp_seq=11 ttl=64 time=0.027 ms [root@localhost ~]# 说明：ping 192.168.120.204 &gt; test.log &amp; //在后台ping远程主机。并输出文件到test.log；这种做法也使用于一个以上的档案监视。用Ctrl＋c来终止。 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习1]]></title>
    <url>%2F2018%2F12%2Flinux_learning1%2F</url>
    <content type="text"><![CDATA[文档目录操作命令(1-8) 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html ls命令概述ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单。如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多! 命令格式：ls [选项] [目录名 命令功能：列出目标目录中所有的子目录和文件。 命令参数：12345678910111213141516171819202122232425262728293031323334353637383940414243-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。-c 配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序-C 每栏由上至下列出项目–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一-d, –directory 将目录象文件一样显示，而不是显示其下的文件。-D, –dired 产生适合 Emacs 的 dired 模式使用的结果-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效-g 类似 -l,但不列出所有者-G, –no-group 不列出任何有关组的信息-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)–si 类似 -h,但文件大小取 1000 的次方而不是 1024-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)-i, –inode 印出每个文件的 inode 号-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息-m 所有项目以逗号分隔，并填满整行行宽-o 类似 -l,显示文件的除组信息外的详细信息。-r, –reverse 依相反次序排列-R, –recursive 同时列出所有子目录层-s, –size 以块大小为单位列出所有文件的大小-S 根据文件大小排序–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：extension -X status -cnone -U time -tsize -S atime -utime -t access -uversion -v use -u-t 以文件修改时间排序-u 配合 -lt:显示访问时间而且依访问时间排序配合 -l:显示访问时间但根据名称排序否则：根据访问时间排序-U 不进行排序;依文件系统原有的次序列出项目-v 根据版本进行排序-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值-x 逐行列出项目而不是逐栏列出-X 根据扩展名排序-1 每行只列出一个文件–help 显示此帮助信息并离开–version 显示版本信息并离开 常用命令实例：列出目录下的所有文件的权限等信息命令：ls -al 实例：列出/home/peidachang文件夹下的所有文件和目录的详细资料命令：ls -l -R /home/peidachang 实例：列出目前工作目录下所有档案及目录;目录于名称后加”/”, 可执行档于名称后加”*”命令：ls -AF 实例：计算当前目录下的文件数和目录数命令：ls -l |grep “^-“|wc -l —文件个数ls -l |grep “^d”|wc -l —目录个数 实例: 在ls中列出文件的绝对路径命令：ls | sed “s:^:pwd/:” 显示彩色目录列表Ubuntu1804具备此功能，如果不满足，可以在/etc/bashrc, 加入一行: alias ls=”ls –color” 1. 蓝色–&gt;目录 2. 绿色–&gt;可执行文件 3. 红色–&gt;压缩文件 4. 浅蓝色–&gt;链接文件 5. 灰色–&gt;其他文件 cd命令概述Linux cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。 命令格式cd [目录名] 命令功能切换当前目录至dirName 常用命令123456cd / 进入系统根目录cd .. 退至上一个目录cd or cd ~ 进入当前用户主目录cd – 返回进入此目录之前所在的目录cd !$ 把上个命令的参数作为cd参数使用注意：跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可 pwd命令概述Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。 命令格式pwd [选项] 命令功能查看”当前工作目录“的完整路径 命令参数123一般情况下不带任何参数如果目录是链接时：格式：pwd -P 显示出实际路径，而非使用连接（link）路径。 理解 Linux 的硬链接与软链接 常用命令实例：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令：find $PWD -maxdepth 1 | xargs ls -ld mkdir命令概述linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 命令格式mkdir [选项] 目录… 命令功能通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写) 命令参数12345-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask-p, --parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;-v, --verbose 每次创建新目录都显示信息--help 显示此帮助信息并退出--version 输出版本信息并退出 常用命令实例：创建权限为777的目录命令： mkdir -m 777 test3 rm命令rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。 命令格式 rm [选项] 文件… 命令功能删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 命令参数123456-f, --force 忽略不存在的文件，从不给出提示。-i, --interactive 进行交互式删除 -r, -R, --recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。 -v, --verbose 详细显示进行的步骤--help 显示此帮助信息并退出 --version 输出版本信息并退出 参考 常用命令实例：删除任何.log文件；删除前逐一询问确认命令：rm -i *.log 实例：将 test1子目录及子目录中所有档案删除命令：rm -r test1 or rm -rf test1 rmdir命令概述rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm – r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。 命令格式rmdir [选项]… 目录… 命令功能该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。 命令参数123- p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。-v, --verbose 显示指令执行过程 常用命令实例：rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除命令：rmdir -p logs/product mv命令概述mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。 命令格式mv [选项] 源文件或目录 目标文件或目录 命令功能视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。 命令参数12345-b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 常用命令实例：移动当前文件夹下的所有文件到上一级目录命令：mv * ../ 实例：把当前目录的一个子目录里的文件移动到另一个子目录里命令：mv test3/*.txt test5 实例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉。命令： mv -f log3.txt log2.txt cp命令概述cp命令既是copy用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同 命令格式 cp [选项]… [-T] 源 目的或：cp [选项]… 源… 目录或：cp [选项]… -t 目录 源… 命令功能将源文件复制至目标文件，或将多个源文件复制至目标目录。 命令参数123456789101112131415-a, –archive 等于-dR –preserve=all–backup[=CONTROL 为每个已存在的目标文件创建备份-b 类似–backup 但不接受参数–copy-contents 在递归处理是复制特殊文件内容-d 等于–no-dereference –preserve=links-f, –force 如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项)-i, –interactive 覆盖前询问(使前面的 -n 选项失效)-H 跟随源文件中的命令行符号链接-l, –link 链接文件而不复制-L, –dereference 总是跟随符号链接-n, –no-clobber 不要覆盖已存在的文件(使前面的 -i 选项失效)-P, –no-dereference 不跟随源文件中的符号链接-p 等于–preserve=模式,所有权,时间戳–preserve[=属性列表 保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：环境、链接、xattr 等-R, -r, –recursive 复制目录及目录内的所有项目 常用命令实例：复制的文件建立一个连结档命令：cp -s db.json db_link.json 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型及BFC]]></title>
    <url>%2F2018%2F12%2FCSS-Box-BFC%2F</url>
    <content type="text"><![CDATA[前言确实是因为菜，感觉自己没什么东西可以写，最近被迫学习一些前端的东西，为了防止日后遗忘，方便有用之时再次学习并加深印象，就记录一些比较基础的东西。 基础知识内容（CONTENT）就是盒子里装的东西；填充(PADDING)就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框(BORDER)就是盒子本身了；边界(MARGIN)则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出。在网页设计上，内容常指文字、图片等元素，但是也可以是小盒子（DIV嵌套），与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子，否则盒子会被撑坏的，而CSS盒子具有弹性，里面的东西大过盒子本身最多把它撑大，但它不会损坏的。填充只有宽度属性，每个HTML标记都可看作一个盒子；更多基础知识参考：w3school：http://www.w3school.com.cn/ 两种模式盒模型的组成:由里向外：content、padding、border、margin 在标准模型（默认）中，盒模型的宽高只是内容（content）的宽高 而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高 模式使用：12 box-sizing: content-box 是W3C盒子模型 box-sizing: border-box 是IE盒子模型 BFC(Block Formatting Context)前端的页面设计，实现一些常见的布局必须要掌握BFC的规律 概念BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 形成BFC的条件（满足四条之一即可）1、浮动元素，float 除 none 以外的值； 2、定位元素，position（absolute，fixed）； 3、display 为以下其中之一的值 inline-block，table-cell，table-caption； 4、overflow 除了 visible 以外的值（hidden，auto，scroll）； BFC的特性1.内部的Box会在垂直方向上一个接一个的放置。 2.垂直方向上的距离由margin决定 3.bfc的区域不会与float的元素区域重叠。 4.计算bfc的高度时，浮动元素也参与计算 5.bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 功能实现1.内部的Box会在垂直方向上一个接一个的放置。 2.垂直方向上的距离由两个盒子的margin相加或重叠决定 3.随浏览器自适应，防止出现这一行跑到下一行的状况 4.防止字体环绕图片 5.防止浮动元素脱离常规流 https://www.cnblogs.com/chen-cong/p/7862832.html 日常搬运 In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 在BFC中，每个盒子的左外边框紧挨着左边框的包含块（从右到左的格式化时，则为右边框紧挨）。即使在浮动里也是这样的（尽管一个盒子的边框会因为浮动而萎缩），除非这个盒子的内部创建了一个新的BFC（这种情况下,由于浮动，盒子本身将会变得更窄） W3C 原文 © w3cplus.com前因后果、细节重点讲解较为仔细 掘金这篇文章进行了更多的拓展，算是加强巩固一下]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记]]></title>
    <url>%2F2018%2F11%2FNotes_of_Struts2%2F</url>
    <content type="text"><![CDATA[struts2概述struts2框架应用javaee三层结构中web层框架struts2框架在struts1和webwork基础之上发展全新框架用servlet和struts框架的基本比较web层框架：1.struts 2.spring struts2入门案例1.每次访问servlet时候，都会执行service方法 写类继承HttpServlet，重写类里面的方法 在web.xml中配置servlet访问路径2.每次访问action时候，默认执行execute方法 配置action访问路径 第一步 导入jar包1.在lib中jar包，不能把这些jar都导入到项目中2.到apps目录里面，找到实例程序，从示例程序中复制相关的jar包 第二步 创建action 第三步 配置action类访问路径1.创建struts2核心配置文件 核心配置文件吗名称和位置是固定的 位置必须在src下面，名称struts.xml2.引入dtd约束3.action配置 第四步 配置struts2过滤器根据配置显示的是相应的hello.jsp文件 基本执行过程过滤器在服务器启动时候创建，创建过滤器时候执行init方法，在init方法中主要加载配置文件，包含自己创建的和struts2自带的配置文件struts.xml和web.xml 常见多变的方法动态方法的调用动态方法调用就是为了解决一个Action对应多个请求的处理，以免Action太多通常有三种方式： 指定method属性感叹号方式（不推荐）通配符方式 接收参数 使用Action的属性接收参数使用DomainModel接收参数使用ModelDriven接收参数 处理结果类型 局部结果将作为元素的子元素配置全局结果将作为元素的子元素配置 Action三种创建方式 创建普通类，不继承任何类，不实现任何接口创建类，实现接口Action创建类，继承类ActionSupport(一般使用这种方式) 获取表单数据使用ActionContext(推荐) 使用ServletActionContext类使用接口注入方式ServletAPI解藕方式 为了避免与Servlet API耦合在一起，方便Action类做单元测试，Struts2对HttpServletRequest、 HttpSession和ServletContext进行了封装，构造了三个Map对象来替代这三种对象。可以通过com.opensymphony.xwork2.ActionContext类来得到这三个对象。ActionContext是 Action执行的上下文，保存了很多对象如parameters、request、session、application和locale等。 获取request、session等方法创建方式 1Map&lt;String,Object&gt; attributes = ActionContext.getContext().getSession(); 或者 12ActionContext context = ActionContext.getContext();Map&lt;String, Object&gt; session = context.getSession(); 1session.put(&quot;str2&quot;, str1); 意思是将str1这个变量的内容赋给str2这个变量在jsp中有两种输出方式（大致上没有区别，除非对应直接输入，会有一定的差别） 12 $&#123;requestScope.str2&#125; &lt;%= ActionContext.getContext().get(&quot;str2&quot;) %&gt; 参考网址：https://www.yiibai.com/struts_2/https://www.w3cschool.cn/struts_2/]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet学习ing]]></title>
    <url>%2F2018%2F11%2Fservlet%2F</url>
    <content type="text"><![CDATA[http协议：超文本传输协议概念和作用特点作用：规范浏览器（客户端）与服务器之间的数据交互 特点：简单、快捷、灵活、无连接（http1.1后支持可持续连接）、无状态（没有记忆，数据量大，新应答快速） 交互流程、请求格式、请求方式交互流程：客户端和服务器建立连接客户端法发送请求到服务器端服务器端接收到请求后进行处理，然后将处理结果相应客户端关闭客户端和服务器端的连接（HTTP1.1后不会立即关闭）请求格式：结构：请求头、请求行、空行、请求数据​​请求方式（结构大致一样，方式可能不同）：HTTP1.0：GET（？后有请求数据，不安全）、POST、HEAD方法HTTP1.1：OPTIONS、PUT、DELETE、TRACE、CONNECT方法​ 响应格式的结构和常见的状态码响应行（状态行）：HTTP版本、状态码、状态消息响应头：消息报头、客户端使用的附加信息空行：响应头和响应实体之间必须的响应实体：正文，服务器返回浏览器的信息​​常见的状态码（告诉浏览器）：​​ 服务器（主流是Tomcat）：本质：实际上就是java网络编程用代码编写的一个容器Tomcat目录结构：​​因为含有class文件，所以一定要依靠jdk，java虚拟环境 Servlet技术：概念和介绍 程序员在编写代码的时候如果能够按照服务器能够识别的规则进行编写，浏览器按照指定的规则进行发送请求（服务器识别就类似于JVM找main（）方法似的，有指定的规则），那么服务器就可以调用并执行响应的逻辑代码进行请求处理了。 ​​ 本质上就是服务器能够识别的接口规范1.创建普通的java类并继承HttpServlet方法2.覆写service方法3.在service方法中书写逻辑代码就行4.在webRoot下的WEB-INF文件夹下的web.xml文件中配置servlet（确保能找到）现在很多IDE环境不需要将class文件移交到相应的Tomcat下 运行（访问）流程：URL: http://localhost:8080/01.MyServlet/my2组成：服务器地址：端口号/服务器下webapps下的文件夹的名称（虚拟项目名）/（servlet的别名）要执行的servlet的url-pattern（因为防止包名类名被黑客利用，需有一定的隐藏，所以采用url-pattern的规则） URI：虚拟项目名/ servlet的别名123456789&lt;servlet&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjsxt.servlet.MyServlet2&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;url-pattern&gt;/my2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 相当于起一个别名，通过web.xml下找到my2，再找到包类名，找不到则404（my2相当于暗号）服务器会加载一下本地的文件，删除文件并关闭服务器再打开会提示报错信息 Servlet生命周期：1.第一次调用到服务器关闭2.如果servlet在web.xml中配置了load-on-startup之间的数字表示顺序，生命周期为从服务器启动到服务器关闭3.注意：Init方法是对servlet进行初始化的一个方法，会在servlet第一次加载进行存储时进行Destroy方法是在servlet销毁时执行 Jsp中的表单数据：​​ Service和doGet和doPost方法的区别： Service方法:可以处理get、post方式的请求，如果servlet中包含service方法，优先调用service方法对请求进行处理 doGet方法:处理get方式的请求 doPost方法:处理post方式的请求注意：如果在覆写的service方法中调用了父类的service方法（super.service（arg0,arg1））,则service方法处理后，会再次根据请求方式响应的doGet和doPost方法执行。一般情况下，不在service中调用父类的service方法，避免出现405错误 Servlet常见错误：404错误：资源未找到在请求地址中的servlet的别名书写错误虚拟项目名称拼写错误500错误：不可预估的错误在web.xml中校验servlet类的全限定路径是否拼写错误。service方法体的代码执行错误所致，根据错误提示对service方法体中的代码进行更改405错误：请求方式不支持请求方式和servlet中的方法不匹配所导致的，尽量使用service方法进行请求处理，并且不要在service方法中调用父类的service。 Request对象：介绍和获取请求头信息 服务器接收到浏览器的请求后，会创建一个request对象，对象中存储了此次请求相关的请求数据。服务器在调用servlet时会将创建好的request对象作为实参传递给servlet的方法，比如service方法。 使用：获取请求头数据、请求行数据、用户数据作用：request对象中封存了当前请求的多有请求信息注意：request对象由Tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法 Service中的形参以req为例子 获取请求头数据：获取请求方式12String method = req.getMethod();Sout(method); 获取请求URL12StringBuffer url = req.getRequestURL()l;Sout(url); 获取URI12String uri = req.getRequestURI();Sout(uri); 获取协议12String h = req.getScheme();Sout(h); 获取请求行数据;获取指定的请求行信息1String value = req.getHeader(“User-Agent”);//根据F12浏览器端找到的键值，加入想要获取666但是你没有，那么你在控制台后收到null 获取所有的请求行的键的枚举12Enumeration e = req.getHeaderNames();while(e.hasMoreElements())&#123; 获取所有键值1sout(e.nextElement()); 获取所有信息123String name = (String)e. nextElement();String value2= req.getHeader(name);Sout(name+”:”+value2); 获取用户数据：req.getParameter(“键名”);(返回指定的用户数据，不能获得同键不同值的多项选择数据，会漏值)​​ 避免漏值​​12req.getParameterValue(“键名”);(返回同键不同值的请求数据（多选），返回数组)req.getParameterNames(“键名”);(返回所有请求数据的枚举集合) 注意：如过要获取的请求数据不存在，不会报错，返回null。 request对象学习问题：在使用request对象获取请求数据并进行处理后，处理的结果如何显示到浏览器中？总结：Service请求处理代码流程：设置响应编码格式、获取请求数据、处理请求数据、数据库操作（MVC思想）、响应处理结果响应实体里面可以设置具体的html代码（无JSP的麻烦之处）乱码问题：记得服务器到浏览器，浏览器到服务器两个半流程中的编码规范问题servlet流程总结： Request作用域问题：使用请求转发后，不同的servlet之间怎么进行数据共享呢？或者说数据怎么从一个servlet流转给另外一个servlet呢？解决：使用request对象的作用域 请求转发：问题：服务器在接收到浏览器的请求后，仅仅使用一个servlet进行请求处理，会造成不同的servlet逻辑代码冗余，servlet的职责不明确解决：使用请求转发特点：一次请求、地址栏信息不改变 重定向学习问题：如果当前的请求servlet无法处理怎么办？如果使用请求转发，造成表单数据重复提交怎么办？解决：使用重定向 Cookie学习Cookie介绍、使用、设置有效期、信息获取 Cookie三天免登录 session学习session介绍及原理问题：request对象解决了一次请求内的不同servlet的数据共享问题，那么一个用户的不同请求的处理需要使用相同的数据怎么办呢？解决：使用session技术原理：用户使用浏览器第一次向服务器发送请求，服务器在接收到请求后，调用响应的servlet进行处理。在处理过程中会给用户创建一个session对象，用来存储用户请求处理相关的公共数据，并将此session对象的JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效）。用户在发起第二次请求及后续请求能够获取同一个session对象，也保证了不同请求能够获取到共享的数据。 session特点及使用特点：存储在服务器端、服务器进行创建、依赖cookie技术、一次会话作用：解决了一个用户不同请求的数据共享问题使用： 创建session对象/获取session对象 设置session存储时间（一般为30分钟） 设置session强制失效hs.invalidate(); 注意JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效） session数据流转和总结存储和获取数据使用时机：一般用户在登录web项目时会将用户的个人信息存储到session中，供该用户的其他请求使用总结：session解决了有个用户的不同请求的数据共享问题，只要在JSESSIONID不失效和session对象不失效的情况下，用户的任意请求在处理时都能获取到同一个session对象。作用域：一次会话（在JSESSIONID不失效和session对象不失效的情况下为整个项目内）session失效处理：将用户请求中的JSESSIONID和后台获取到的session对象JSESSIONID进行对比，如果一致则session没有失效，否则证明session失效了。重定向到登录界面，让用户重新登录。 解决主页面用户名显示为null的问题原因：因为在用户登录成功后使用重定向显示主页面，两次请求，而用户的信息在第一次请求中，第二次请求中没有用户数据，所以显示为null解决：使用session ServletContext对象学习问题：request解决了一次请求内的数据共享问题，session解决了用户不同请求的数据共享问题，那么不同的用户的数据共享该怎么办呢？解决：使用ServletContext对象作用：解决了不同用户的数据共享问题原理：ServletContext对象由服务器进行创建，一个项目只有一个对象。不管在项目的任意位置进行获取得到的都是同一个对象，那么不同用户发起请求获取到的也就是同一个对象了，该对象由用户共同拥有特点：服务器创建、用户共享、一个项目只有一个生命周期：服务器启动到关闭作用域：项目内使用：获取ServletContext对象/使用ServletContext对象完成数据共享获取项目中web.xml文件中的全局配置数据获取项目webroot下的资源的绝对路径/流对象使用ServletContext对象完成网页计数器在用户登录校验中创建计数器并自增，然后存储到ServletContext对象中，在主页面中取出计数器数据并显示给用户即可 ServletConfig对象问题：使用ServletConfig对象可以获取web.xml中的全局配置文件，在web.xml中每个servlet也可以进行单独的配置，那么该怎么获取配置信息呢？解决：使用ServletConfig对象作用：ServletConfig对象是servlet的专属配置对象，每个servlet都单独拥有一个ServletConfig对象用来获取web.xml中的配置信息使用： web.xml文件作用：存储项目相关的配置信息，保护servlet。解耦一些数据对程序的依赖使用位置：每个web项目中、tomcat服务器中（在服务器目录conf目录中）区别：web项目下的web.xml文件为局部配置，针对本项目的位置tomcat下的web.xml文件为全局配置，配置公共信息内容（核心组件）：全局上下文配置（全局配置参数）、servlet配置、过滤器配置、监听器配置加载顺序：web容器会按照ServletContext-&gt;context-param-&gt;listener-&gt;filter-&gt;servlet这个顺序加载组件，这些元素可配置在web.xml中的任意位置加载时机：服务器启动时 server.xml文件问题：浏览器发起请求后服务器根据请求在webapps目录下调用对应的servlet进行请求处理。那么为什么是webapps目录而不是其他的目录呢？解决：了解server.xml文件的配置信息server.xml文件核心组件：热部署：1&lt;Context path=&quot;/Pet&quot; reloadable=&quot;false&quot; docBase=&quot;F:/PetWeb&quot; /&gt; 参考链接：B站菜鸟教程]]></content>
      <categories>
        <category>Java</category>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群聊初步学习实现过程]]></title>
    <url>%2F2018%2F10%2FThinking-of-Chat%2F</url>
    <content type="text"><![CDATA[看学习视频所得 Chat0.1:客户端：先写一个简易的窗口，采用extends Frame Chat0.2:客户端：给窗口添加TextArea在BorderLayout北面，添加TextField在BorderLayout南面，注意pack()、add(); Chat0.3:客户端：匿名类改写windowClosing()使其System.exit(0)（可以关闭） Chat0.4:客户端：使用内部类给框架添加监听事件，改写actionPerformed(ActionEvent e)使Field内容显示到Area中，清空Field Chat0.5:客户端：不变服务器端：建立ServerSocket serverSocket = new ServerSocket(8088);当有连接时Socket s = serverSocket.accept(); Chat0.6:客户端：设置connect函数建立 socket = new Socket(“127.0.0.1”, 8088);连接，connect()置于launchFrame()框架建立同时连接上端口号服务器端：不变 Chat0.7:客户端：利用DataOutputStream dos = new DataOutputStream(s.getOutputStream()); dos.writeUTF(str);将输入内容写入流中，内容储存在流中方便通信。服务器端：利用 DataInputStream dis = new DataInputStream(s.getInputStream()); Stringstr; dis.readUTF(); System.out.println(str);将内容接收过来并在控制台打印出来 Chat0.8:客户端：将DataOutputStream设为全局变量,设置disconnect函数,当关闭窗口时应断开连接服务器端：不变 Chat0.9:客户端：不变服务器端：增加容错性，添加BindException、EOFException、以及finally判断来关闭Socket和DataInputStream，出现EOFException表示前面有客户端占用端口，所以应当写出提示语句最后在finally中关闭之前的占用 Chat1.0:客户端：不变服务器端：使用内部类增加多线程Client，重写run()、创建函数start(),main()函数中只有一句话，在start()中创建端口使其监听好，设置started为true，并设置BindException，再接收端口，调用Client类构造函数接受到流中的内容并bConnected = true;最后生成新的线程（在run()中进行）来读取流中的内容并打印出来，初步实现多客户端的功能 Chat1.1:客户端：不变服务器端：将客户端的信息通过服务端存储并发给每个客户端,但客户端没有接收 Chat1.2:客户端：利用多线程来接收发过来的字符串,后面再打印在TextArea上服务器端：不变 Chat1.3:客户端：不变服务器端：修正关闭一个客户端报错的问题,应当将去除的客户端从集合中删去,这时候移除的客户端应当是要发送的那个线程的客户端,此时客户端也就不会接收到信息,而不是当前客户端,删去的客户端应当要注意区分 学习的代码–&gt;源文件日后有机会将逐步完善]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度云加速的一些方式]]></title>
    <url>%2F2018%2F09%2FBaidu_cloud_acceleration%2F</url>
    <content type="text"><![CDATA[有常见的几种方式 1.Pan Download2.度盘下载器 DpDownload3.BaiduPCS-Go4.proxyee-down5.速盘详情可以参考：https://blog.csdn.net/tsvico/article/details/80659361 proxy-downgithub地址：https://github.com/proxyee-down-org/proxyee-down Pan Downloadgithub网址： https://github.com/Accelerider/BaiduPanDownloadWinform教程：http://pandownload.com/ 建议Pan Download易被屏蔽，建议采用其他方式，博主用的是proxy-down 效果 速盘SpeedPan现在还是用速盘感觉还行，其他方式不推荐了下载链接：https://www.weidown.com/xiazai/1448.html]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网学习]]></title>
    <url>%2F2018%2F09%2FJava_further_study%2F</url>
    <content type="text"><![CDATA[要每天都有收获 局部类匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。静态内部类不能直接访问外部类的非静态成员，但可以通过new外部类（）.成员的方式访问。 Collection接口 类方法有如下一些限制： 1 在类方法中不能引用对象变量。2 在类方法中不能使用super、this关键字。3 类方法不能调用类中的对象方法。与类方法相比，实例方法几乎没有什么限制：1 实例方法可以引用对象变量（这是显然的），也可以引用类变量。2 实例方法中可以使用super、this关键字。3 实例方法中可以调用类方法。 抽象类和接口特点:1.抽象类中可以构造方法2.抽象类中可以存在普通属性，方法，静态属性和方法。3.抽象类中可以存在抽象方法。4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。6,抽象类不能被实例化，抽象类和抽象方法必须被abstract修饰 关键字使用注意：抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。接口 1.在接口中只有方法的声明，没有方法体。2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final，接口中的变量默认是public static final 的，方法默认是public abstract 的3.在接口中的方法，永远都被public来修饰。4.接口中没有构造方法，也不能实例化接口的对象。（所以接口不能继承类）5.接口可以实现多继承6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。7.接口可以继承接口，用extends 构造过程class A{ static { System.out.println(“父类静态代码块”); } public A(){ System.out.println(“父类构造方法”); } { System.out.println(“父类初始化块”); }}public class B extends A{ static{ System.out.println(“子类静态代码块”); } public B(){ System.out.println(“子类构造方法”); } { System.out.println(“子类初始化块”); } public static void main(String[] args){ new B(); }}父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法； object类的方法： final final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。final修饰的方法不能被重写而不是重载！final修饰属性，此属性就是一个常量，不能被再次赋值！ for循环的执行顺序用如下表达式：for(expression1;expression2;expression3){expression4;}执行的顺序应该是：1）第一次循环，即初始化循环。首先执行表达式expression1（一般为初始化语句）；再执行expression2（一般为条件判断语句），判断expression1是否符合expression2的条件；如果符合，则执行expression4，否则，停止执行；最后执行expression3。 2）第N（N&gt;=2）次循环首先执行expression2，判断在expression3是否符合在expression2要求；如果符合，则继续执行在expression4，否则，停止执行。最后执行在expression3。如此往复，直至expression3不满足在expression2条件是为止。 总结：总的来说，执行的顺序是一致的。先条件判断（expression2），再函数体执行（expression4），最后for执行（expression3）。往复……区别在于，条件判断的对象。第一次判断时，对象为初始化语句（expression1），后续的判断对象为执行后的结果（expression3）。 volatile 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。而对该变量的修改，volatile并不提供原子性的保证。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况多线程下计数器必须使用锁保护。 BooleanBoolean修饰的变量为包装类型，初始化值为false,进行赋值时会调用Boolean.valueOf(boolean b)方法自动拆箱为基本数据类型，因此赋值后flag值为true，输出文本true。 如果使用==比较,则输出文本false。if的语句比较，除boolean外的其他类型都不能使用赋值语句，否则会提示无法转成布尔值。 String 类 finally语句块:结论：1、不管有木有出现异常，finally块中代码都会执行；2、当try和catch中有return时，finally仍然会执行；3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。举例：情况1：try{} catch(){}finally{} return;显然程序按顺序执行。 情况2:try{ return; }catch(){} finally{} return;程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，最后执行try中return;finally块之后的语句return，因为程序在try中已经return所以不再执行。 情况3:try{ } catch(){return;} finally{} return;程序先执行try，如果遇到异常执行catch块，有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，最后执行catch块中return. finally之后也就是4处的代码不再执行。无异常：执行完try再finally再return. 情况4:try{ return; }catch(){} finally{return;}程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 情况5:try{} catch(){return;}finally{return;}程序执行catch块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 情况6:try{ return;}catch(){return;} finally{return;}程序执行try块中return之前（包括return语句中的表达式运算）代码；有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；则再执行finally块，因为finally块中有return所以提前退出。无异常：则再执行finally块，因为finally块中有return所以提前退出。 最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。 Java表达式转型规则由低到高转换：1、所有的byte,short,char型的值将被提升为int型；2、如果有一个操作数是long型，计算结果是long型；3、如果有一个操作数是float型，计算结果是float型；4、如果有一个操作数是double型，计算结果是double型；5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化 Socket ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。Socket(InetAddress address , int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。 socket和servletSocket的交互如下图所示：参考链接 JSP内置对象1.request对象 客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。2.response对象 response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。3.session对象 session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.4.out对象 out对象是JspWriter类的实例,是向客户端输出内容常用的对象5.page对象 page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例6.application对象 application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。7.exception对象 exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象8.pageContext对象pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。9.config对象config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象） 面向对象五大基本原则五个基本原则：单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口 小点1.switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型 2.捕获到的异常不仅可以在当前方法中处理，还可以将异常抛给调用它的上一级方法来处理。 3.HashMap的底层是由数组加链表实现的，对于每一个key值，都需要计算哈希值，然后通过哈希值来确定顺序，并不是按照加入顺序来存放的，因此可以认为是无序的，但不管是有序还是无序，它都一个自己的顺序。故A错。最开始有Hashtable，Hashtable是不允许key和value的值为空的，但后来开发者认为有时候也会有key值为空的情况，因为可以允许null为空，通过查看HashMap的源代码就知道：if(key = null) {putForNullKey(value);};Map底层都是用key/value键值对的形式存放的 4.Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 L ist 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复5.public Method[] getDeclaredMethods()返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。public Method[] getMethods()返回类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。 6.0xFFFFFFFFFFFFFFFF 转为源码 = -1 7.URL u =new URL(http://www.123.com).如果 www.123.com 不存在，则返回 http://www.123.com 8.InputStreamReader可用于处理 Unicode，bufferedReader主要起装饰作用。 9.HashMap是线程安全的HashMapVector是线程安全的ArrayListTreeSet和LinkedList都不是线程安全的 10.Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 11.不同的编码之间是可以转换的，通常流程如下：将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。例：String newUTF8Str = new String(oldGBKStr.getBytes(“GBK”), “UTF8”); 12.Java虚拟机中通常使用UTF-16的方式保存一个字符 13.ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。 14.Math.cos为计算弧度的余弦值，Math.toRadians函数讲角度转换为弧度double d=Math.cos（Math.toDegrees（42）） 15.hashcode和equals的约定关系如下： 1、如果两个对象相等，那么他们一定有相同的哈希值（hash code）。 2、如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断） 16.加载驱动方法 1、Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); 2、 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 3、System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”); 17.运算符中优先级最高:口诀：淡云一笔安洛三福 单目&gt;算数运算符&gt;移位&gt;比较&gt;按位&gt;逻辑&gt;三目&gt;赋值 18.所有异常都是Exception的子类 19.String classFile = “com.jd.”. replaceAll(“.”, “/“) + “MyClass.class”;///////MyClass.class由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\.” 20.注解 Override 注解指明被注解的方法需要覆写超类中的方法.如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.Deprecated 注解可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。 个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。 当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。Suppresswarnings 注解可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。 21.两个数值进行二元操作时，会有如下的转换操作：如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，如果其中一个操作数是float类型，另一个将会转换为float类型。否则，如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。 22. 23.sleep()是Thread类中的方法，而wait()则是Object类中的方法。sleep()方法导致了程序暂停，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。wait()方法会导致线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。注意是准备获取对象锁进入运行状态，而不是立即获得 24.Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。 25.hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表进行锁定即让线程独享整张hash表，在安全同时造成了浪费。concurrentHashMap采用分段加锁的机制来确保安全 26.Properties 继承了Hashtable，因为Hashtable是线程安全的，所以Properties是线程安全的，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder，Arraylist是非线程安全的，其对应的线程安全类是Vector 27.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落后的vim简易设计]]></title>
    <url>%2F2018%2F09%2Fjava_entry_learning%2F</url>
    <content type="text"><![CDATA[还是要发点博客 暑假关于Java的学习主要是实现vim的简易功能，很简陋，以后有时间再更改 最终目标用Java实现简单的Vim编辑器功能为什么是Vim?Vim以其强大的功能在程序员中间被尊为编辑器之神。它设计为完全用键盘操纵电脑,减少了双手频繁地在鼠标和键盘间切换的时间,在你熟练掌握它之后,你的编辑效率将会成倍增加Vim是一款高度可定制的软件,它充分体现了自由的程序思想,你可以根据个人喜好,自由地改变Vim的行为,也可以使用别人的配置将Vim打造成强大的集成开发环境Vim几乎是处处可用的,在其它主流的编辑器中你也可以使用Vim的编辑模式,甚至于浏览器中都有Vim插件,你可以用Vim浏览网页在你远程登陆服务器修改代码时Vim几乎是唯一的选择(远程登陆服务器没有图形界面,无法使用鼠标)具体安排1.第一周:(基本字符串操作)按i进入编辑模式(文本可编辑),按esc进入普通模式(文本不可编辑,所有按键都是快捷键)普通模式中按h,j,k,l光标左,下,上,右移动(其中上下移动为难点)2.第二周:(IO流,文件操作)按w保存文件,但不退出按x保存并退出,未保存退出要有提示,提示显示在下方状态栏按dd删除一行按yy复制一行到粘贴板按p将粘贴板内容粘贴在下一行3.第三周:(多线程,网络操作,字符串高级操作)定时备份文件(尽力做) 远程编辑文件(这台电脑编辑另外一台电脑上的文件)按/匹配字符串(如/foo,匹配文本中的foo字符串)按/foo/foo1,用foo1替换所有foo字符串4.第四周:(高级功能,代码重构、完善、总结)(选做)宏录制:qa,开始记录键盘操作,并录入a寄存器中。再按q完成录制。再按@a,重复a中记录的动作没完成的功能继续完善减少重复代码,使用面向对象的设计方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365import javax.swing.*;import javax.swing.text.BadLocationException;import javax.swing.text.DefaultHighlighter;import javax.swing.text.Highlighter;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;class UpdateFile implements Runnable&#123; public void run() &#123; while(true)&#123; try&#123; String fname = "Write1.txt"; String childdir = "backup"; File f1,f2,child; f1 = new File(fname); child = new File(childdir); if(f1.exists()) &#123; if(!child.exists())&#123; child.mkdir(); &#125; f2 = new File(child, fname); if(!f2.exists()||f2.exists()&amp;&amp;(f1.lastModified() &gt; f2.lastModified())) &#123; copy(f1, f2); &#125; getinfo(f1); getinfo(child); &#125; else&#123; System.out.println(f1.getName() + " file not found!"); &#125; &#125;catch (IOException e)&#123; System.out.println("error"); &#125; try&#123; Thread.sleep(60000); &#125;catch(Exception e)&#123;&#125; &#125; &#125; public void copy(File f1, File f2) throws IOException&#123; FileInputStream rf = new FileInputStream(f1); FileOutputStream wf = new FileOutputStream(f2); int count,n = 512; byte buffer[] = new byte[n]; count = rf.read(buffer,0,n); while (count != -1) &#123; wf.write(buffer,0,count); count = rf.read(buffer,0,n); &#125; System.out.println("CopyFile " + f2.getName() + "!"); rf.close(); wf.close(); &#125; public static void getinfo(File f1) throws IOException&#123; SimpleDateFormat sdf; sdf = new SimpleDateFormat("yyyy年 MM 月 dd 日 hh 时 mm 分"); if(f1.isFile()) &#123; System.out.println("&lt;File&gt;\t" + f1.getAbsolutePath() + "\t" + f1.length() + "\t" + sdf.format(new Date())); &#125; else&#123; System.out.println("&lt;Dir&gt;\t" + f1.getAbsolutePath()); File[] files = f1.listFiles(); for(int i = 0;i&lt;files.length; i++) &#123; getinfo(files[i]); &#125; &#125; &#125;&#125;class Read&#123; String key="i 键被按下"; String word=" "; int d=0; int y=0; String psg = " "; Read(JTextArea ja) &#123; ja.addKeyListener(new KeyListener() &#123; public void keyPressed(KeyEvent e) &#123;&#125; public void keyTyped(KeyEvent e)&#123; int location = ja.getCaretPosition(); switch (e.getKeyChar()) &#123; case 'h': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" h 键被按下"); if (location==0) &#123;&#125; else ja.setCaretPosition(location - 1); &#125; break; &#125; case 'l': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" l键被按下"); mouse(ja, location, 'l',psg); &#125; break; &#125; case 'j': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" j键被按下"); mouse(ja, location, 'j',psg); &#125; break; &#125; case 'k': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" k键被按下"); mouse(ja, location, 'k',psg); &#125; break; &#125; case 'i': &#123; System.out.println("i 键被按下"); key = "i 键被按下"; ja.setEditable(true); break; &#125; case 'w': &#123; if (!key.equals("i 键被按下")) &#123; System.out.print("保存文件\n"); WriteInto(ja.getText()); word = "保存文件"; &#125; break; &#125; case 'x': &#123; if (!key.equals("i 键被按下")) &#123; System.out.print("保存文件并退出\n"); WriteInto(ja.getText()); System.exit(0); &#125; break; &#125; case KeyEvent.VK_ESCAPE: &#123; System.out.print("Esc键被按下\n"); key = "Esc键被按下"; ja.setEditable(false); break; &#125; case'd':&#123; d++; if (!key.equals("i 键被按下")&amp;&amp;d==2) &#123; System.out.println(" d键被按下"); mouse(ja, location, 'd',psg); d=0; &#125; break; &#125; case'y':&#123; y++; if (!key.equals("i 键被按下")&amp;&amp;y==2) &#123; System.out.println(" y键被按下"); psg = mouse(ja, location, 'y',psg); y=0; &#125; break; &#125; case'p':&#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" p键被按下"); psg = mouse(ja, location, 'p',psg); &#125; break; &#125; case'/':&#123; Scanner s = new Scanner(System.in); String str = null; System.out.println("请输入您想输入的字符串："); str = s.nextLine(); HighLighter(ja,str); &#125; default: break; &#125; &#125; public void keyReleased(KeyEvent e) &#123;&#125; &#125;); &#125; public String mouse(JTextArea jas,int pos,char letter,String text)&#123; int lineOfC,aline,col; try &#123; //获取行数 lineOfC = jas.getLineOfOffset(pos);// 上面的字符总数 aline = jas.getLineStartOffset(lineOfC); //获取列数 col = pos - aline + 1;// System.out.println("当前光标位置" + lineOfC + "行 , " + col + " 列 "); switch (letter)&#123; case'l':&#123; if(pos==jas.getLineEndOffset(jas.getLineCount()-1)) &#123;&#125; else jas.setCaretPosition(pos+1); break; &#125; case'j':&#123; if(lineOfC == jas.getLineCount()-1)&#123;&#125; else&#123; int chance1 = jas.getLineEndOffset(lineOfC)-aline; int chance2 = jas.getLineEndOffset(lineOfC+1)-jas.getLineStartOffset(lineOfC+1); if(chance2 &gt; col) &#123; jas.setCaretPosition(pos+chance1); &#125; else&#123; jas.setCaretPosition(pos+chance2); &#125; &#125; break; &#125; case'k':&#123; if(lineOfC == 0)&#123;&#125; else&#123; int chance = jas.getLineEndOffset(lineOfC-1)-jas.getLineStartOffset(lineOfC-1); if(chance&gt;col)&#123; jas.setCaretPosition(pos-chance); &#125; else&#123; jas.setCaretPosition(pos-col); &#125; &#125; break; &#125; case'y':&#123; int chance = jas.getLineEndOffset(lineOfC)-aline; text=jas.getText(jas.getLineStartOffset(lineOfC),chance-1); return text; &#125; case'd':&#123; jas.replaceRange("",aline,jas.getLineEndOffset(lineOfC)); break; &#125; case'p':&#123; String tex=text+'\n'; jas.insert(tex,jas.getLineEndOffset(lineOfC)); return text; &#125; default: &#125; &#125; catch(Exception ex) &#123; System.out.println( "无法获得当前光标位置 "); &#125; return text; &#125; public void WriteInto(String line)&#123; try&#123; FileOutputStream fw = new FileOutputStream("Write1.txt");//向指定文本内写入 fw.write(line.getBytes()); fw.close(); System.out.println(); &#125;catch(Exception e)&#123;System.out.println("error");&#125; &#125; public String getKey() &#123; return key;&#125; public String getWord()&#123; return word;&#125; public void HighLighter(JTextArea ta, String keyWord)&#123; int key=0,i; String s="",s1=""; for(i=0;i&lt;keyWord.length();i++) &#123; if(keyWord.charAt(i)=='/') &#123; key=1; break; &#125; s1+=keyWord.charAt(i); &#125; Highlighter highLighter = ta.getHighlighter(); String text = ta.getText(); DefaultHighlighter.DefaultHighlightPainter p = new DefaultHighlighter.DefaultHighlightPainter(Color.RED); int pos = 0; if(key==0)&#123; while ((pos = text.indexOf(keyWord, pos)) &gt;= 0) &#123; try &#123; highLighter.addHighlight(pos, pos + keyWord.length(), p); pos += keyWord.length(); &#125; catch (BadLocationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; else&#123; for(int j=i+1;j&lt;keyWord.length();j++) &#123; s += keyWord.charAt(j); &#125; while ((pos = text.indexOf(s1, pos)) &gt;= 0) &#123; ta.replaceRange(s,pos,pos + s1.length()); pos += keyWord.length(); &#125; &#125; &#125;&#125;public class Vim implements WindowListener &#123; JTextField tB; JTextArea tA; Read a ; JFrame jf; public static void main(String[] args) &#123; Vim test = new Vim(); &#125; public Vim() &#123; String s = "hfciuwfoouierhf\nchbaohdfooequfh\ndsiuyfoogaerwiuyfooghui\nweichgengcheng\nfoohguewoiuryefoohalfhdfoohel\njhfiufooasergfure"; jf = new JFrame("Vim"); // 创建一个文本区域和一个文本框 tA = new JTextArea(s, 8, 8); tB = new JTextField(5); // 设置自动换行 tA.setLineWrap(true); // 添加到内容面板 JScrollPane scrollPane = new JScrollPane(tA); jf.add(scrollPane, BorderLayout.CENTER); jf.add(tB,BorderLayout.SOUTH); jf.setLocation(new Point(200, 200)); tA.setEditable(true); tB.setEditable(false); jf.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE); jf.addWindowListener(this);// 向文本对象添加窗口事件监听 jf.setVisible(true); jf.setSize(400, 400); a = new Read(tA); UpdateFile updateFile = new UpdateFile(); Thread a = new Thread(updateFile); a.start(); &#125; @Override public void windowActivated(WindowEvent e) &#123;&#125; @Override public void windowClosed(WindowEvent e) &#123;&#125; @Override public void windowClosing(WindowEvent e) &#123; if(a.getKey().equals("Esc键被按下")&amp;&amp;a.getWord().equals("保存文件"))&#123; System.exit(0);// 系统退出 &#125; else &#123; tB.setText(": 未保存"); &#125; &#125; @Override public void windowDeactivated(WindowEvent e) &#123;&#125; @Override public void windowDeiconified(WindowEvent e) &#123;&#125; @Override public void windowIconified(WindowEvent e) &#123;&#125; @Override public void windowOpened(WindowEvent e) &#123; tB.setText(": 窗口被激活"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2018%2F08%2Ffirst_hexo%2F</url>
    <content type="text"><![CDATA[你不能一直做一些烂事，然后自己后悔，好像后悔有用一样，你需要变好 想法 2017给了我很多最最美好的经历，目前对我最重要的年份是这一年,希望能继往开来希望自己能多给自己一些惊喜，少管些闲事，累了就休息，再也不失眠希望自己能跟着大佬学点东西，不要别人一张嘴你就一头雾水、一脸尴尬多看点书，学点东西，然后写一些对自己有用的博文 你要是无聊，它可以让你学不动，给你省了时间和金钱 计算机相关技术资料整理 https://github.com/EZLippi/practical-programming-books 编程书籍的整理和收集 https://github.com/KeKe-Li/book java 的书多一些 https://github.com/huangbaoquan/books 现在没太多时间读书，但可以整理一下，大家有好的链接不妨推荐一下放在这个博客中，方便以后有时间阅读寄语（鸡汤）没有不可治愈的伤痛，没有不能结束的沉沦，所有失去的，都会以另一种方式归来人生亦如逆旅，一切美好与温暖沉默如影，静立你的身后，不会迎头遇见，只要你不断走向远方，它便一路相随]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+nexT中的其他内容]]></title>
    <url>%2F2018%2F08%2Fhexo%2BnexT%2Bsomething%2F</url>
    <content type="text"><![CDATA[建议直接看最根本的东西 限于本人英语水平有限，建议大家直接到github上阅读相应的仓库获取最新知识，这样能避免很多错误，也不会被网上很多已经过时的东西影响。本人的版本： Theme versionversion: 5.1.4 hexo 版本 东拼西凑的东西每次输入都需要重新输入github帐号和密码？参考设置 SSH 使用 hexo deploy 时免输用户名密码设置好的状态： 版权声明之前的版本声明我觉得有点丑，除了有最新更新时间没有别的好处，而且那些声明明显落后于现在版本更新的速度，建议使用新版本里面的简洁声明 打开主题配置文件找到post_copyright1234post_copyright: enable: true #将false改成true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 设置gitment评论系统尝试过valine评论，但是决定作为程序员还是使用gitment比较好 最新版里面不需要添加配置文件只需要有app即可操作如下： 注册OAuth Application点击https://github.com/settings/applications/new注册参数说明：1234Application name： #应用名称Homepage URL： #网站URLApplication description #描述Authorization callback URL：#网站URL 修改themes/next/_config.yml在其中添加：12345678910111213141516# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: 不添加则跟随默认语言# Force language, or auto switch by theme跟随默认语言 github_user: Github名 # MUST HAVE, Your Github ID github_repo: .github.io的仓库 # MUST HAVE, The repo you use to store Gitment comments client_id: App id # MUST HAVE, Github client id for the Gitment client_secret: App secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 链接消除汉语在文章量不是很大的情况下建议直接设置链接的英文名，网上有相关教程我采用了转换，但是出了些小bug，但还能应付的过来 关于用自己的页面做页面请参考jacklightChenHexo-用自己的页面做首页 主题内添加相册功能（可能会出现卡顿）请参考asdfv1929Hexo NexT主题内添加相册功能 添加网页标题崩溃欺骗搞怪特效请参考asdfv1929Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效 添加加载效果打开主题配置文件搜索pace_theme看到下面这些效果，有很多种，挑选一个自己喜欢的就好了12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-loading-bar 最后 鉴于很多大佬都有相应的分享我就老老实实做一个搬运工，希望有更多人能有一个自己满意的博客网上有更多好的效果和实现方式欢迎与我交流 —-&gt;传送门]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github+ubuntu搭建个人博客]]></title>
    <url>%2F2018%2F08%2Fhexo%2Bhithub_pages%2BnexT%2F</url>
    <content type="text"><![CDATA[菜鸟初步搭建须知（是我没错，备忘）相应知识 会一些基本的Linux命令和vim的操作命令。可以在实验楼上入门学习 网上已经浏览了 官方文档 安装ubuntu和git（因为最近在学习用ubuntu，而且很多操作ubuntu上会更简单） 安装Node.js并拥有github账号 github上新建好一个专门的仓库，并最好熟悉github及其基本操作比如SSH密钥 以上知识网上有比较完善的信息，搜索关键字学习并进行必要的搭建前提已经完成下图： 建议大家选择不同的博客建站，可以参考有哪些好看的 Hexo 主题? 新手初步搭建可能有用搭建nexT主题可能有帮助的链接： https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.jianshu.com/p/a0a27d840992 https://www.jianshu.com/p/24cb74aeb0a3 http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 深入搭建，安装NexT主题Hexo 安装主题的方式非常简单，新建blog文档（命名随意）在其下打开终端操作即可，具体到 NexT 来说，安装步骤如下。 安装主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 具体还有以下步骤（自行网上搜索）： hexo init(第一次需要) hexo clean hexo g hexo s hexo d 启动主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件（官方文档中给出站点配置文件解释）， ctrl+f 搜索到 theme 字段，并将其值更改为 next，主题默认为landscape，建议选择Pisces或Gemini 1theme: next 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug，dubug会帮助你更好找到安装过程的错误），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 改动hexo 站点配置文件我们打开站点下的_config.yml文件 深入站点配置文件，事先变动RSS订阅 1.在hexo的根目录下执行命令： 1npm install hexo-generator-feed --save 2在根目录下的/theme/next/_config.yml文件中添加配置 123456feed: type: rss2 path: rss2.xml limit: 5 hub: content: 'true' 加入站点内容搜索功能 1.安装hexo-generator-searchdb 注意：安装时应在站点根目录下，即blog目录下 1$ npm install hexo-generator-searchdb --save 2.添加search字段，在站点blog/_config.yml中添加search字段，如下 12345search: path: search.xml field: post format: html limit: 10000 编辑远程部署 ，添加代码块 1234deploy: type: git repository: https://github.com/Thunderforrain/Thunderforrain.github.io.git branch: master 方便写博客，自动生成图片文档 1post_asset_folder: true 如果是flase 改成true 参考文章内添加图片 注意 : : 使用英文的，并且后面要有空格 执行完以上步骤，查找关键字来更改其他信息，最后结果大致如下(仅作最后的参考)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: Thunderforrain's Blog #网站标题subtitle: 实迷途其未远,觉今是而昨非 #网站副标题description: 菜鸟的 尝试，笨鸟的先飞 #网站描述keywords:author: Thunderforrain #博主的名字language: zh-Hans #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://thunderforrain.github.io/ ** #你网站的urlroot: /blog/ #子目录permalink: :year/:month/:day/:title/ #生成文件名字的格式permalink_defaults:# Directory 目录配置source_dir: source public_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章new_post_name: :title.md # File name of new posts （新建文章链接形式）default_layout: post # 默认布局（官方文档中给出其他布局）titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 render_drafts: false post_asset_folder: true #启动 Asset 文件夹,方便管理文章图片relative_link: false future: true highlight: #代码块设为true enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: # Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页（非全屏不显示）## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page search: path: search.xml field: post format: html limit: 10000# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next## Rss订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有) hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:Tenke007/Tenke007.github.io.git branch: master 改动hexo 主题配置文件建议参考网址，网上有比较好的教程:Never_yu’s Blog主题配置参考知了笔记Elegant theme for Hexo建议看一下我下一篇博客我们打开主题下的_config.yml文件 深入主题配置文件，里面可以添加很多东西（参考上述网址）： 在右上角或者左上角实现fork me on github 背景配置 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改“代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加Gitment评论系统 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 hexo 添加百度站长推送 hexo NexT主题首页title链接的优化 Hexo NexT主题修改文章标题样式 hexo 添加百度站长推送 参考上文知了笔记的hexo框架基于next主题定制 下文可作为理解帮助（仅作为最后的参考）:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexofavicon: ##网站的头像 small: /images/avatar.jpg medium: /images/avatar.jpg apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "记录耕耘"##网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml # 需要安装插件# Specify the date when the site was setupsince: 2015 网站时间，类似 2015-2016 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: #我的是自己设置可否评论，可以使用统一u形式，不同的评论方式不同 # ------------------------------------------------------------- # Hexo link (Powered by Hexo).#管理底部驱动信息，个人去了版本号 powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / categories: /categories #分类 tags: /tags #标签 archives: /archives #归档 #about: /about # 关于我 #sitemap: /sitemap.xml #这个可以不用开启，给搜索引擎用的，需要安装插件 #commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #上面menu的iconmenu_icons: enable: true home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next主题的三个schemes(默认是Muse)#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini #个人比较喜欢Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.#social: #社交链接，可以放github,weibo,qq等 GitHub: https://github.com/Thunderforrain || github CSDN: https://blog.csdn.net/Thunderforrain #微博: #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: #对应的社交icon enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo Wechat: wechat# Blog rolls #相关链接links_icon: linklinks_title: 友情链接links: git学习: http://github.phodal.com/ 馨客栈: http://www.mackxin.com/ CSL's Blog 的链接: http://cubercsl.cn/links/ jacklightChen's Blog: http://blog.lightina.cn/links_layout: block #Title: http://example.com/# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /images/avatar.jpg #博主头像（可以放外链）# Table Of Contents in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: #侧边栏，只对Pisces、Gemini有效 # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).像素菜单条边栏偏移量 offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: #设置为true,首页文章会显示 阅读全文，建议使用 &lt;!-- more --&gt; enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber #文章内显示微信二维码wechat_subscriber: enabled: true qcode: /images/wechat.png #微信二维码图片路径 description: 随便说点 #微信二维码描述#Reward #打赏功能，图片相应目录有或者外链reward_comment: 捐助菜鸡，提携笨鸟wechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on posts # 版权声明post_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme 代码高丽风格，个人喜欢默认版本# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: # ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key #第三方搜索（根据喜好选择，不举例了）#swiftype_key:# Baidu Analytics ID #百度分析#baidu_analytics:# Duoshuo ShortName #多说评论，已成为过去，不可使用duoshuo_shortname: tenke# Disqus #来必力评论#disqus_shortname:# changyan #畅言评论changyan: enable: false appid: appkey: # Hypercomments#hypercomments_id:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: #下面有东西，暂不举例，涉及隐私 # Gitment #需要github账号才能留言# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled:# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share #废弃duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: #弃用 ua_enable: true admin_enable: true user_id: admin_nickname: # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: #facebook相关 enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# --------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: #第三方用户访问插件，直接开启，根据喜好添加文字 # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp阅读数 page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search #自己添加# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0 #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-center-simple# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 最后一些想法1.科学上网（你懂的） 2.逐步升级博客（一次性弄好不现实） 3.先理解站点和主题配置文件（有些东西随着版本的更新，没有必要进行很麻烦的操作） 4.还有一部分东西可以自己查,希望对大家有所帮助 欢迎互加友情链接 ，互相交流—–&gt;传送门 一些博客实例： IIssNan’s NotesKevin Pu’s Blog Showo^^e吴小龙同學]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
