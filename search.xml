<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu18.04 配置ssr(酸酸乳)]]></title>
    <url>%2F2019%2F03%2Fyuque%2Ftsw1x0%2F</url>
    <content type="text"><![CDATA[告别扩展,拥抱酸酸乳 概述Ubuntu18.04也已经告别了命令行界面(或许早就告别了但是现在才知道)，迎来了配置 ss 或者 ssr 的图形化界面，对于我这样的小白简直不能太友好。 下载安装 electron-ssr 或者 shadowsocks-qt5下载可以去github：electron-ssrshadowsocks-qt5也可以从我的分享里下载:electron-ssr-0.2.6.AppImage：https://nbccadminedupl-my.sharepoint.com/:u:/g/personal/w0412_x2_tn/EbgJR8ATiFBNqzTZTdtEeTIBm5EOEDLIfmydh6ZS9eyn6Q?e=JxszOrShadowsocks-Qt5-3.0.1-x86_64.AppImage：https://nbccadminedupl-my.sharepoint.com/:u:/g/personal/w0412_x2_tn/EcB6EsWxmYBIkSka75Bj6t4BPciAtEAde13vs4M4n-M5PA?e=qwnl6Z安装就是命令行下面赋予执行权限后双击一下，例如1chmod a+x electron-ssr-0.2.6.AppImage 打开之后的界面（这里就不给主页面了，你懂的）这边安利一下 electron-ssr ，没啥原因，就是页面好看，配置方便。 ssr 配置参考 github 上给出的方法shadowsocks-qt5：https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C#%E7%BC%96%E8%BE%91%E9%85%8D%E7%BD%AEelectron-ssr：https://github.com/erguotou520/electron-ssr 配置 SwitchyOmega auto switch配置完毕如下关于如何使用 SwitchyOmega,参考:https://blog.csdn.net/u010658816/article/details/85782272 ，配置完毕不影响访问网站，同时一定程度上节省了流量。火狐浏览器同样下载此插件进行同样的操作，但是要正常访问可能要关闭 PAC 代理，这个问题之后再解决吧，实际上就是因为菜。通过 https://vimcaw.github.io/blog/2018/03/12/Shadowsocks(R)%E8%AE%BE%E7%BD%AE%EF%BC%9A%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81PAC%E3%80%81%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99/ 初步判断和下图的两层判断的 PAC 文件起了冲突。~~ 总结关于订阅，就要靠自己去找或者去买了，本篇教程面对小白，纯属技术交流，如有不妥之处，望指出。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell 周会分享]]></title>
    <url>%2F2019%2F03%2Fyuque%2Frcibso%2F</url>
    <content type="text"><![CDATA[shell脚本使用 c#、一键执行 git、黑客、bash、fish、底层、云服务器、举出信安和程、vim、投屏回放、需要什么功能去学什么功能、你稍了解的东西都已经这么有用，更别说外国更多的好东西，主要是我们无知，开源的东西都在那里，却没有动力。git的功能是为真的写代码的人设计的。shell的bash和fish的冲突、 fish:http://www.ruanyifeng.com/blog/2017/05/fish_shell.html从windows的麻烦之处介绍shell，一键执行 alias，对于目录可以用alias或者nl，推荐alias， 永久生效：https://blog.51cto.com/feihan21/12129541234567891011121314151617alias sudo='sudo 'alias ll='ls -alF'alias la='ls -A'alias l='ls -CF'alias l.='ls -d .* --color=auto'alias nis="npm install --save "alias svim='sudo nvim'alias mkcd='foo()&#123; mkdir -p "$1"; cd "$1" &#125;; foo 'alias install='sudo apt get install'alias update='sudo apt-get update; sudo apt-get upgrade'alias ..="cd .."alias ...="cd ..; cd .."alias h='history'alias ports='netstat -tulanp'alias rm='rm -I --preserve-root'alias grep="grep --color"alias grepp="grep -P --color" alias 即可显示设置的命令，和git一个道理vim ~/.bash_aliases 加入适合的alias命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 记录]]></title>
    <url>%2F2019%2F03%2Fyuque%2Fubuntu%2F</url>
    <content type="text"><![CDATA[从索引-&gt;驱动-&gt;备份-&gt;重新安装 概述自己的 Ubuntu18.04 索引无故罢工,帮助我小小学习回顾了一下 Ubuntu18.04 的一些注意事项以及一些硬件信息。 过程记录 罢工缘由索引通过 boot-repair 修复好，但是卡在了登录界面，解决登录问题，但是显然驱动有问题，网上教程安装驱动，结果忘了两行命令，所以就 gg 了。期间，遇到了（initramfs）， grub 界面，甚至连戴尔的安全助手都跳出来了。。。我智商被轮番碾压的滋味简直不要太酸爽。 修复过程乱七八糟的教程让我头都看大了，主要是参考网上各种方法，结果越搞越乱。这边主要参考https://blog.csdn.net/qq_34562959/article/details/81095716?tdsourcetag=s_pctim_aiomsghttps://www.cnblogs.com/tanrong/p/9166595.html#wenti?tdsourcetag=s_pctim_aiomsghttps://blog.csdn.net/qq_30603195/article/details/88116757?tdsourcetag=s_pctim_aiomsg其他的不给也罢，要么过时，要么就是错的，重要的命令行就下面这些吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344# boot-repairsudo susudo add-apt-repository ppa:yannubuntu/boot-repairapt-get updateapt-get install boot-repair# recoveryAdvanced Settings -&gt; recovery mode -&gt; Resumesudo gedit /etc/initramfs-tools/modules加入fbconvesafbnvidiafb这三行sudo gedit /etc/modprobe.d/blacklist-framebuffer.conf文件，把nvidiafbvesafbvga16fb这三行注释掉，若没有则无视最后update-initramfs -uupdate-grubexit# 可能会导致设置问题sudo gedit /etc/default/grub 在文件中找到这一行： GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"改为： GRUB_CMDLINE_LINUX_DEFAULT="quiet splash nomodeset"保存，关闭文件。在命令行中输入：（更新文件） sudo update-grub# rootmount -rw -o remount# 驱动sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get update ubuntu-drivers devicessudo apt-get install nvidia-driver-415 当然我最终是失败了，走上了重装系统的光明之路。 chrome 浏览器从 http://www.ubuntuchrome.com/ 直接下载最新版，然后你会发现自己无法登录谷歌账号，于是想要去安装谷歌访问助手，安装扩展很容易获取，这里就不多说了。我从 windows 上获取的.crx文件不能用，解压缩导入也不行，于是就希望安装旧版本的可登录chrome 浏览器来实现同步，经过了一番曲折寻找，在 https://www.chromedownloads.net/chrome64linux/ 上获得了想要的 70 和 68 的版本，登录上去却发现不能进行同步，这边猜想可能是因为需要同步的 chrome 版本低于谷歌账号最近登录的 chrome 浏览器版本。于是乎，我有卸了装，装了卸，最终回到了原点—–》安装谷歌访问助手。网上浏览了一番，最终考虑试一下压缩的手段。想解压，然后压缩成 tar 文件， 最后进行解压。一切完工，自以为大功告成，结果导入解压缩文件还是出错。我那时真的一脸笑嘻嘻，幸好天无绝人之路，我将 .crx 文件拖入扩展界面竟然神奇的安装成功了。。。。真的是神(shi)一样的操作。接下来在最新版本的 chrome 浏览器下，我又迎来了一次新生。小小分析一下，这个 .crx 文件在 Windows 上也需要重新压缩再解压，大概是新版本的 chrome 浏览器更贴近其运行的系统，我们将其压缩、解压缩，使得此文件可以适应相应系统。注意，刚刚的分析都是没有根据的瞎猜测，报个玩笑的态度就好。 其他配置安装好Ubuntu18.04之后：https://blog.csdn.net/haeasringnar/article/details/81809040配置 root 用户: https://blog.csdn.net/sunxiaoju/article/details/51993091配置 idea 及熟悉快捷键：https://yangbingdong.com/2017/note-of-learning-idea-under-ubuntu/安装 SpaceVim：https://spacevim.org/cn/quick-start-guide/#linux-%E6%88%96-macos搜狗输入法设置默认英文输入法: https://blog.csdn.net/ameyume/article/details/87091652美化桌面环境：https://zhuanlan.zhihu.com/p/37852274 https://blog.csdn.net/weixin_38233274/article/details/80782483 思路及总结动手的时候要思考一下给的命令行，如果没有好好思考，嘿嘿，你会深刻理解什么叫做没有如果。如果 Ubuntu 出现了问题，还是先使用启动盘，boot-repair 一下，不行则进入 recovery 模式，再不行则进入 root ，使自己获取更改权限，进行操作。有的时候要排除错误，需要在这几个里面来回切换，非常耽误时间。如果你自己写好了一个常用安装的一键脚本，备份常用的工具后，重新安装其实挺好的(实际是因为自己太菜，三天下来实在受不了了。。。)，当然如果你能看懂它给的提示，那我说的都是废话。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vim的资源与使用]]></title>
    <url>%2F2019%2F03%2Fyuque%2Fpq6p97%2F</url>
    <content type="text"><![CDATA[概述毫无疑问，Vim对新手很不友好。但是友好的编辑器通常跟不上程序员进步的速度，谁又不想一劳永逸，一直使用同一种编辑器呢？这显然是一种辩证选择。而选择 Vim 绝对是一个明智的长期投资。Vim 又被称为神的编辑器，前身 vi 是由 BIll Joy 于 1976 年开发，其改进版 Vim 最早于 1991 年由 Bram Moolenaar 开发。关于 Vim 的其他故事，可以参考编辑器之神 &amp; 神的编辑器1。 Vim 学习资源网上有很多乱七八糟的资源，但我感觉写得都不尽如人意。主要还是靠自己去搜索资源，找到最适合自己的学习方式，显然现在我还只是入门，仍旧处于不断学习的状态中。我的学习过程大致如下: vimtutor Vim 实用技巧 笨方法学 Vimscript 关于 Vim 实用技巧，推荐自己看一遍，里面针对问题来提出 Vim 的解决方案，是一个很好的参考资料，可以参考我的写得一篇 Vim 实用技巧2，至于笨方法学Vimscript，目前还没有深入下去，仍旧在学习当中。 Vim 应用场景Vim 作为神的编辑器，自然少不了应用的地方。据我目前认知，大部分需要编辑器的地方，都能发现 Vim的身影，各种主流的 IDE 中 Vim 插件已经有大牛帮你写好了，只需要搜索进行下载就行了，我目前在这几个场景中应用 Vim： SpaceVim —-模块化的 Vim IDE Vimium —-Chrome浏览器的扩展程序 IdeaVim —-Idea中内置的插件 SpaceVim 三大主流平台都支持，是我自己轻量级写作和文件管理的工具，一开始用的不舒服，现在也还是不断学习的阶段。Vimium 是程序员的福利，Chrome 和Firefox 浏览器均有其插件，开箱即食。虽然有些按键设计不合理，但总的来说还是有所联系，毕竟这是社区推动、集思广益的。IdeaVim 则需要在 IDEA 中进行下载。我的初步使用，感觉还是有些不够灵活，其中还有一个扩展的 Vim 插件，有机会会去试试。 Vim 熟练使用熟练使用 Vim ，首先要学会盲打，SpeedCoder 是个不错的练习网站，学习了部分的 Vim 的知识，就可以通过做大量的练习来锻炼自己了，这显然是个煎熬过程，鉴于自己的学习也比价缓慢，就不过多分析。但是我还是喜欢在日常中去练习使用，而不是根据文档去刻意练习，找到自己需要编辑的地方，一律用 Vim 来编辑。比如写博客，敲代码，做记录等等。虽然我现在还是很水，但是也初步感受到了 Vim 的好处，刚开始的时候时间学习成本非常高，但回报也是巨大的。不知道是真正的效率，还是克服困难、努力得到肯定，使人感到无比强大和酣畅淋漓，反正正如大牛所说，它们会带给你渐渐强烈的快感，但你也向它们献出了自己的灵魂。这时，你只能称它们为神器。 注意以上内容，都是我个人的观点，欢迎访客提出自己的建议。另外自己显然有很多东西不懂，欢迎大佬给我些指导意见。这篇博客对于初学者来说，内容可能有些繁多，最好每个方向都入门，然后慢慢进步吧(我是如此，所以如是建议)，在学习过程中可能还要记一些与 Vim 无关的快捷键，比如在浏览器和 IDEA 中， 但我觉得这是早晚要适应的，克服一下，最终会感谢自己的选择。 引用1.http://os.51cto.com/art/201101/242518.htm2.https://www.yuque.com/tfrain/boke/vim_skill3.http://learnvimscriptthehardway.onefloweroneworld.com/4.https://spacevim.org/cn/5.https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb6.www.speedcoder.net]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[19.Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fkxgzpq%2F</url>
    <content type="text"><![CDATA[链表 题目描述Given a linked list, remove the _n_-th node from the end of list and return its head.Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and _n_ = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given _n_ will always be valid.Follow up:Could you do this in one pass? 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *///Two pass algorithmclass Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) &#123; length++; first = first.next; &#125; length -= n; first = dummy; while (length &gt; 0) &#123; length--; first = first.next; &#125; first.next = first.next.next; return dummy.next; &#125;&#125;//One pass algorithmpublic ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // Move first to the end, maintaining the gap while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next;&#125; 思路及总结不论是两遍算法，还是一遍算法，都用了一个额外空间 dummy，然后返回的是 dummy.next，一遍的算法很灵巧的避过了二遍算法的 n 的定位， 参考https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[17. Letter Combinations of a Phone Number]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_17%2F</url>
    <content type="text"><![CDATA[初步了解回溯算法 题目描述Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Example:Input: “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].Note:Although the above answer is in lexicographical order, your answer could be in any order you want. 参考代码12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits.length() != 0) backtrack("",digits); return output; &#125; Map&lt;String, String&gt; phone = new HashMap&lt;String, String&gt;() &#123;&#123; put("2", "abc"); put("3", "def"); put("4", "ghi"); put("5", "jkl"); put("6", "mno"); put("7", "pqrs"); put("8", "tuv"); put("9", "wxyz"); &#125;&#125;; List&lt;String&gt; output = new ArrayList&lt;String&gt;(); public void backtrack(String combination, String next_digits) &#123; if (next_digits.length() == 0) &#123; //意味着一条分支走到底，譬如 adg output.add(combination); &#125;else &#123; String digit = next_digits.substring(0, 1); String letters = phone.get(digit); for (int i = 0; i &lt; letters.length(); i++) &#123; //分割回溯 String letter = phone.get(digit).substring(i, i + 1); backtrack(combination + letter, next_digits.substring(1)); &#125; &#125; &#125;&#125; 思路及总结首先题目描述最好还是加上不允许重复，还有就是几个数字对应几个字母组合。。。。回溯是一种通过探索所有潜在候选者来查找所有解决方案的算法。如果候选解决方案变为不是解决方案（或者至少不是最后一个解决方案），则回溯算法通过在前一步骤上进行一些更改（即回溯然后再次尝试）来丢弃它。我怎么感觉更像 DFS 呢。。。。就是递归然后进行组合，回溯可能考虑的是得到 adg，还要回去得到 adh 参考https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小的尝试]]></title>
    <url>%2F2019%2F02%2Fyuque%2Ftry_test1%2F</url>
    <content type="text"><![CDATA[一些相关的计算机资料，侵删 获取下载链接：https://www.fageka.com/i/T8PXVDj0040 目录树 ├─Algorithm │ Algorihms 4th Edition by Robert Sedgewick, Kevin Wayne.pdf │ 剑指 Offer.pdf │ 挑战程序设计竞赛(第2版).巫泽俊.扫描版.pdf │ 程序员代码面试指南 IT 名企算法与数据结构题目最优解 左程云著.pdf │ 算法 第四版.pdf │ 编程之美.pdf │ ├─Architecture │ NoSQL 精粹.pdf │ 从 PAXOS 到 ZOOKEEPER 分布式一致性原理与实践.pdf │ 大型网站技术架构：核心原理与案例分析+李智慧.pdf │ 大规模分布式存储系统：原理解析与架构实战.pdf │ 实现领域驱动设计.pdf │ 微服务设计.epub │ 淘宝技术这十年.pdf │ ├─C++ │ C 和指针.pdf │ C++ Primer 第五版.pdf │ Linux 多线程服务端编程：使用 muduo C++网络库.pdf │ ├─Computer Network │ HTTP 权威指南.pdf │ 图解 HTTP.pdf │ 图解 TCP IP 第五版.pdf │ 计算机网络 第七版.pdf │ ├─Database │ MySQL 必知必会.pdf │ MySQL 技术内幕 InnoDB 存储引擎 第 2 版.pdf │ O’Reilly.High.Performance.MySQL.3rd.Edition.M.pdf │ Redis 实战.pdf │ Redis 设计与实现.pdf │ 数据库系统概论.pdf │ 高性能 MySQL 第三版.pdf │ ├─Interview │ │ 王道程序员面试宝典.pdf │ │ │ └─Java 校招面试 Google 面试官亲授 │ │ project.zip │ │ │ ├─第10章谷歌在线笔试题解 │ │ 10-1 解小数据集.wmv │ │ 10-2 估算算法时间.wmv │ │ 10-3 解大数据集（上）.wmv │ │ 10-4 解大数据集（下）.wmv │ │ 10-5 运气和异常.wmv │ │ │ ├─第11章面试的软技巧和总结 │ │ 11-1 面试过程和注意点.wmv │ │ 11-2 总结.wmv │ │ │ ├─第1章课程引言 │ │ 1-1 导学.wmv │ │ 1-2 校招录取率和在线笔试.wmv │ │ 1-3 从一道谷歌在线笔试开始.wmv │ │ │ ├─第2章操作系统 │ │ 2-1 操作系统概述.wmv │ │ 2-2 进程和线程.wmv │ │ 2-3 存储和寻址.wmv │ │ 2-4 操作系统例题.wmv │ │ │ ├─第3章网络 │ │ 3-1 网络基础.wmv │ │ 3-2 滑动窗口问题.wmv │ │ 3-3 网络抓包演示.wmv │ │ 3-4 网络例题.wmv │ │ │ ├─第4章数据库 │ │ 4-1 数据库概述.wmv │ │ 4-2 JOIN和GROUP BY.wmv │ │ 4-3 事务和乐观锁.wmv │ │ 4-4 数据库例题.wmv │ │ │ ├─第5章程序设计语言基础 │ │ 5-1 程序设计语言基础归类.wmv │ │ 5-2 数据类型、整数和补码.wmv │ │ 5-3 浮点数和定点数简述.wmv │ │ 5-4 Java数据类型、拆箱和装箱.wmv │ │ │ ├─第7章面向对象 │ │ 7-1 面向对象概述.wmv │ │ 7-10 面向对象不可变性.wmv │ │ 7-11 泛型（上）.wmv │ │ 7-12 泛型（下）.wmv │ │ 7-13 虚函数表.wmv │ │ 7-14 面向对象小结.wmv │ │ 7-2 面向对象类与对象.wmv │ │ 7-3 对象的特殊函数（上）.wmv │ │ 7-4 对象的特殊函数（下）.wmv │ │ 7-5 接口与抽象类.wmv │ │ 7-6 实现Iterable接口.wmv │ │ 7-7 继承.wmv │ │ 7-8 封装.wmv │ │ 7-9 面向对象例题.wmv │ │ │ ├─第8章设计模式 │ │ 8-1 设计模式简介.wmv │ │ 8-2 State模式.wmv │ │ 8-3 Decorator模式.wmv │ │ 8-4 创建对象.wmv │ │ │ └─第9章高级知识点 │ 9-1 高级知识点.wmv │ 9-2 外部排序分析.wmv │ 9-3 死锁分析.wmv │ 9-4 线程池介绍.wmv │ 9-5 线程池_Java Excutor Framework演示（上）.wmv │ 9-6 线程池_Java Excutor Framework演示（下）.wmv │ 9-7 资源管理.wmv │ ├─Java │ Java Concurrency in Practice.pdf │ Java 编程思想 第四版.pdf │ Thinking in Java 4th Edition.pdf │ 分布式 Java 应用基础与实践.pdf │ 深入理解 Java 虚拟机 2.pdf │ 精通Spring 4.x 企业应用开发实战.pdf │ ├─Middleware │ Kafka权威指南.epub │ RabbitMQ 实战指南.pdf │ ├─OOP │ head first design patterns.pdf │ Head First 设计模式.pdf │ 深入浅出面向对象分析与设计.扫描版.pdf │ ├─Operating System │ Modern Operating Systems.pdf │ 深入理解计算机系统 第三版.pdf │ ├─Popularization │ 编码：隐匿在计算机软硬件背后的语言.pdf │ 计算机程序的构造和解释.pdf │ ├─Python │ Flask Web开发：基于Python的Web应用开发实战.pdf │ Python 编程：从入门到实践.pdf │ ├─Software Construction │ 人月神话.mobi │ 代码大全.epub │ 代码大全.pdf │ 代码整洁之道.mobi │ 程序员的职业素养.pdf │ 编写可读代码的艺术.pdf │ 重构 改善既有代码的设计.pdf │ ├─Tools │ git-cheat-sheet.pdf │ Pro Git.pdf │ 正则表达式必知必会.pdf │ └─Unix-Linux The Linux Command Line.pdf UNIX 环境高级编程.pdf UNIX 网络编程.pdf Unix-Linux 编程实践教程.pdf 鸟哥的 Linux 私房菜 基础篇 第四版.pdf]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[10. Regular Expression Matching]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_10%2F</url>
    <content type="text"><![CDATA[摘要里面放的是递归的方法，下面的是动态规划(Dynamic Programming)的方法。 题目描述Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:Input:s = “aa”p = “a”Output: falseExplanation: “a” does not match the entire string “aa”.Example 2:Input:s = “aa”p = “a“Output: trueExplanation: ‘‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.Example 3:Input:s = “ab”p = “.“Output: trueExplanation: “.“ means “zero or more () of any character (.)”.Example 4:Input:s = “aab”p = “cab”Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time.Therefore it matches “aab”.Example 5:Input:s = “mississippi”p = “misisp.”Output: false 参考代码123456789101112131415161718192021222324252627282930313233343536373839//递归class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) return s.isEmpty(); boolean first_match = (!s.isEmpty() &amp;&amp; (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')); if (p.length() &gt;= 2 &amp;&amp; p.charAt(1) == '*')&#123; //(isMatch(s, p.substring(2))使第 p 中第三个字符进行匹配， //(first_match &amp;&amp; isMatch(s.substring(1), p))使 p 中 * 之前的字符进行匹配 return (isMatch(s, p.substring(2)) || (first_match &amp;&amp; isMatch(s.substring(1), p))); &#125; else &#123; return first_match &amp;&amp; isMatch(s.substring(1), p.substring(1)); &#125; &#125;&#125;//DPclass Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[s.length()][p.length()] = true; for (int i = s.length(); i &gt;= 0; i--)&#123; for (int j = p.length() - 1; j &gt;= 0; j--)&#123; boolean first_match = (i &lt; s.length() &amp;&amp; (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.')); if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*')&#123; dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];// &#125; else &#123; dp[i][j] = first_match &amp;&amp; dp[i+1][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125; 思路及总结递归的思路： 大致是以 p 字段划分，两两进行递归。0,1,2个字符、纯字母和含有 . 的都较好理解。下面考虑含有 符号的。例如 aaacce 和 ace，(first_match &amp;&amp; isMatch(s.substring(1), p)) 递归到 cce 和 ace 的情况，然后 (isMatch(s, p.substring(2)) 收拾最后一步，则 p 中 ac 的匹配结束，但是删除的字符是 a*，第三个字符可能在接下来的一组进行使用。到了这一步，大致理解 If a star is present in the pattern, it will be in the second position \text{pattern[1]}pattern[1]. Then, we may ignore this part of the pattern, or delete a matching character in the text. If we have a match on the remaining strings after any of these operations, then the initial inputs matched. 是什么含义。但是看懂和写何止十万八千里，我还不知到要学习多少次，才能有这样的算法功底。复杂度有些复杂，大致应当是指空间复杂度为O(2^n)，空间复杂度是O(n^2)；DP的思路：了解一下DP：https://blog.csdn.net/zjkc050818/article/details/74532023可能更适合看是视频：https://www.bilibili.com/video/av16544031/?spm_id_from=333.788.videocard.0这里面提到了表格的DP：https://www.bilibili.com/video/av18512769?from=search&amp;seid=1441380389563731271这个 DP 的选与不选都不明显，而且很难判断出口，等做多了，想必能更好理解。啥都不会是我最大的觉悟。。。。。别人是兔派，我是兔看派，第一次遇见dp，都说dp和博弈论是神仙题，我感受到了。 参考https://leetcode.com/problems/regular-expression-matching/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5. Longest Palindromic Substring]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_5%2F</url>
    <content type="text"><![CDATA[题目描述Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.Example 1:Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2:Input: “cbbd”Output: “bb” 参考代码123456789101112131415161718192021222324252627class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i);//奇数 int len2 = expandAroundCenter(s, i, i + 1);//偶数 int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2;//确使奇偶行得通 end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1;//因为循环结束时，长度各边减一 &#125; &#125; 思路及总结偶数减一除以二(0.5-1.0)和奇数减一除以二(0.0-0.5)两者可以保持除法上的一致。官方首先提醒了最长公共子串的误区，然后列举了暴力法，动态规划，和本题的中心扩展法。详细内容直接参考官方题解。 参考https://leetcode-cn.com/problems/longest-palindromic-substring/solution/https://leetcode.com/problems/longest-palindromic-substring/solution/Manacher 算法https://segmentfault.com/a/1190000008484167]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4. Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_4%2F</url>
    <content type="text"><![CDATA[题目描述There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.Example 1:nums1 = [1, 3]nums2 = [2] The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 参考代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; if (m &gt; n) &#123; int[] tmp = nums1; nums1 = nums2; nums2 = tmp; int temp = m; m = n; n = temp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; nums2[j-1] &gt; nums1[i]) &#123; iMin = i + 1; &#125; else if (i &gt; iMin &amp;&amp; nums1[i-1] &gt; nums2[j]) &#123; iMax = i - 1; &#125; else &#123; int maxLeft = 0; if (i == 0) &#123; maxLeft = nums2[j-1];&#125; else if (j == 0) &#123;maxLeft = nums1[i-1];&#125; else &#123; maxLeft = Math.max(nums1[i-1], nums2[j-1]); &#125; if ( (m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123;minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums2[j], nums1[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;&#125; 思路及总结当找到目标对象 i_i_时，中位数为：当为奇数时，left的数字较多，可以举例来理解一下 保证奇偶都能满足最后的那个数学证明是看到头都大了，大概是那个道理。还是官方解答，最为致命。时间复杂度为log(m+n),意思就是只能单层循环一次两个数组，有点利用二分法和分治的思想。 参考https://leetcode.com/problems/median-of-two-sorted-arrays/solution/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_2%2F</url>
    <content type="text"><![CDATA[题目描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1 == null) &#123; l1 = new ListNode(0); &#125; if(l2 == null) &#123; l2 = new ListNode(0); &#125; if(l1.next == null &amp;&amp; l2.next == null) &#123;//基准情况 int val = l1.val + l2.val; if(val &gt; 9) &#123; ListNode node = new ListNode(val%10); node.next = new ListNode(1);//最大的数字也只能是19 return node; &#125; else &#123; return new ListNode(val); &#125; &#125; else &#123; int val = l1.val + l2.val; if(val &gt; 9) &#123; val -= 10; if(l1.next != null) &#123;//将进位赋值其一 l1.next.val++; &#125; else if(l2.next != null) &#123; l2.next.val++; &#125; &#125; ListNode node = new ListNode(val); node.next = addTwoNumbers(l1.next,l2.next); //最终返回的结果 return node; &#125; &#125;&#125; 思路及总结涉及到链表和递归，感觉自己的基础实在是太差了，基础的算法思想都不会使用，还有就是自己的java基础也很薄弱，经常不知道如何来调用一些常用函数，结合自身情况，尽早提升吧。本题主要要考虑到进位的安排，使用了递归，递归问题一般都能转换为循环问题，如https://www.programcreek.com/2012/12/add-two-numbers/，复杂度为O(n)，进位只会进1。 参考https://blog.csdn.net/yanyumin52/article/details/79811375https://blog.csdn.net/w496272885/article/details/80212426]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell脚本学习]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fshell_learning1%2F</url>
    <content type="text"><![CDATA[shell脚本初步 前言寒假在家不如学习一下shell的基本语法，也只能怪我看springboot的视频很容易睡觉，寒假准备为这个寒冬做准备学学springboot，结果老师的安排的东西我现在还没看，springboot也是看了个什么都不会的程度。总而言之，就是在滚蛋的边缘疯狂的试探？shell脚本和Python脚本都有学习的必要，如果往后端方向发展，shell和Python都要涉猎，当然主语言还是Java，shell脚本对自动化部署有很大的帮助，有利于我学习一些Linux知识。 语雀上有shell脚本的资料链接：https://www.yuque.com/allenlei/ia7uhw/edyrfz bilibili视频学习链接：https://www.bilibili.com/video/av17384556 实验楼实战操作链接：https://www.shiyanlou.com/courses/944文档: https://www.shiyanlou.com/courses/944/labs/3558/document Linux温习实验楼上同样有相应的基础学习教程Linux命令实例练习 Linux 基础入门（新版）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法相关知识简介]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fwikipedia_algorithm%2F</url>
    <content type="text"><![CDATA[据说维基的知识总结很优秀 前言若hexo有小bug或不舒服之处，请移步到语雀浏览因为自己的算法基础非常薄弱，希望通过兔派刷题的方式，怀着幸存者的意识，能够迎头赶上。 数组(Array)在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。最简单的数据结构类型是一维数组。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，…2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。二维数组，对应于数学上的矩阵概念，可表示为二维矩形格。例如：在C语言中表示为int a[3][3] = {{3, 6, 2}, {0, 1, -4}, {2, -1, 0}};。在某些情况下，“向量”一词也可能代表二维数组，虽然在数学意义上更确切地称呼为元组（tuple），而不是向量。但需要注意的是：计算机科学的某些领域，如Matlab，元组是指类似C语言struct类型，具有固定的往往是不同类型的数据成员的数据结构。数组通常用于实现数据库的表格，特别是查询表；表格有时也被当作是数组的同义词。数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表（list）和字符串（string）。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是向量处理器），经常会针对数组操作进行优化。因为在程序运行时可以计算元素的索引，数组是很有用的。此外，也能以单一迭代语句就处理数组的许多元素。为此，数组数据结构的元素必须具有相同的大小，而且应该使用相同的数据类型表示。数组一词通常用于表示数组数据类型，一种大多数高端编程语言都会内置的数据类型。数组类型通常由数组结构来实现；然而在某些语言中，它们可以由散列表、链表、搜索树或其它数据结构来实现。在算法的描述中，数组一词特别着重意义为关系数组或“抽象的数组”，一种理论上的计算机科学模型（抽象数据类型或 ADT），专注于数组的基本性质上。 哈希表(Hash Table)散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名x到首字母F(x)的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。 链表(Linked List)链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针)(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（”links”）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。 数学(Math) 双指针(Two Pointers) 串(String)字符串（String），是由零个或多个字符组成的有限序列。一般记为。它是编程语言中表示文本的数据类型。通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。串的两种最基本的存储方式是顺序存储方式和链接存储方式。 二分查找(Binary Search)在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。二分搜索在情况下的复杂度是对数时间，进行次比较操作在此处是数组的元素数量，是大O记号，是对数）。二分搜索使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分搜索比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分搜索应用面更广。二分搜索有许多中变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索。分散层叠有效的解决了计算几何学和其他领域的许多搜索问题。指数搜索将二分搜索拓宽到无边界的列表。二分搜索树和B树数据结构就是基于二分搜索的。 分治算法(Divide and Conquer)在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个理论，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。分治法这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的折半搜索算法（或是在数值分析中类似的勘根算法）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用尾部递归的话，便能转换成简单的循环。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用减治法这个名称。分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。 动态规划(Dynamic Programming)动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 回溯算法(Backtracking)回溯法（英语：backtracking）是暴力搜索法中的一种。对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况： 找到一个可能存在的正确的答案 在尝试了所有可能的分步方法后宣告该问题没有答案 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。 栈(Stack)堆栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的抽象数据类型，其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外堆栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 堆(Heap)堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。堆始于 J._W._J._Williams 在 1964 年发表的堆排序（heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在戴克斯特拉算法（英语：Dijkstra’s algorithm）中亦为重要的关键。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。 贪心算法(Greedy)贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。 排序(Sort)在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则： 输出结果为递增序列（递增是针对所需的排序顺序而言） 输出结果是原输入的一种排列、或是重组 虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表） 位运算(Bit Manipulation)位操作是算法操作比字&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhjWJGcdyh6D0YqybOhRRrQm_q3weA)短的位或其他数据&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhimJkNnf1ms2G_qzxH5ThHaFXOF3w)的行为。 需要位操作的计算机编程任务包括低级设备控制， 错误检测和纠正算法， 数据压缩 ， 加密算法和优化&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhh_t9EuZt8FPWcE83nzA7-3KzopLw) 。 对于大多数其他任务，现代编程语言允许程序员直接使用抽象&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgsc5qtrh0_vT7zGYTWMCKDHxCcOA)而不是代表那些抽象的位。 执行位操作的源代码使用按位运算 ：AND，OR，XOR，NOT和位移 。在某些情况下，位操作可以消除或减少循环数据结构的需要，并且可以提供多倍的加速，因为并行处理位操作，但代码可能变得更难以编写和维护。 树(Tree)在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路(cycle)深度优先搜索(Depth-first Search)深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树)或图)的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。因发明“深度优先搜索算法”，约翰·霍普克洛夫特与罗伯特·塔扬在1986年共同获得计算机领域的最高奖：图灵奖。广度优先搜索(Breadth-first Search)广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。并查集(Union Find)在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于创建单元素集合。有了这些方法，许多经典的划分问题可以被解决。为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。 图(Graph) 设计(Design) 拓扑排序(Topological Sort)在计算机科学领域，有向图的拓扑排序是其顶点的线性排序，使得对于从顶点到顶点的每个有向边，在排序中都在之前。 例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是有向无环图（DAG），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。 每个顶点出现且只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径)。字典树(Trie)在计算机科学中，trie，又称前缀树或字典树，是一种有序树)，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。Trie这个术语来自于retrieval。根据词源学，trie的发明者Edward Fredkin把它读作/ˈtriː/ “tree”。但是，其他作者把它读作/ˈtraɪ/ “try”。在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie中的键是一串比特，可以用于表示整数或者内存地址。树状数组(Binary Indexed Tree)树状数组或二叉索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以的时间得到任意前缀和，并同时支持在时间内支持动态单点值的修改。空间复杂度。线段树(Segment Tree)线段树（英语：Segment tree）是一种二叉树形数据结构，1977年由Jon Louis Bentley发明，用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间。一个包含个区间的线段树，空间复杂度为，查询的时间复杂度则为，其中 是匹配条件的区间数量。此数据结构亦可推广到高维度。二叉搜索树(Binary Search Tree)二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合)、多重集、关联数组等。二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望，最坏（数列有序，树退化成线性表）。虽然二叉查找树的最坏效率是,但它支持动态查询，且有很多改进版的二叉查找树可以使树高为,如SBT,AVL树，红黑树等。故不失为一种好的动态查找方法。 递归(Recursion)递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 脑筋急转弯(Brainteaser) 记忆化(Memoization)在计算机科学中，记忆化（英语：memoization而非memorization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。 队列(Queue)队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。 极小化极大(Minimax)Minimax算法（亦称 MinMax or MM）又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。 蓄水池抽样(Reservoir Sampinh) Map 几何(Geometry) Rendom Rejection Samping 参考以上内容均来自wikipedia]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[860. Lemonade Change]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_944%2F</url>
    <content type="text"><![CDATA[题目描述At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.Note that you don’t have any change in hand at first.Return true if and only if you can provide every customer with correct change. Example 1:Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true.Example 2:Input: [5,5,10]Output: trueExample 3:Input: [10,10]Output: falseExample 4:Input: [5,5,10,10,20]Output: falseExplanation: From the first two customers in order, we collect two $5 bills.For the next two customers in order, we collect a $10 bill and give back a $5 bill.For the last customer, we can’t give change of $15 back because we only have two $10 bills.Since not every customer received correct change, the answer is false. Note: 0 &lt;= bills.length &lt;= 10000 bills[i] will be either 5, 10, or 20.参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills[0] != 5) &#123;//若第一个不是5，则返回false return false; &#125; else &#123; int five = 1,ten = 0; int length = bills.length; for(int i = 1;i &lt; length;i++) &#123;//从第二个数据开始 if(bills[i] == 5) &#123; five++; &#125; else if(bills[i] == 10)&#123; if(five == 0) &#123; return false; &#125; else &#123;//进行相应的加减 five--; ten++; &#125; &#125; else &#123; if(five == 0) &#123; return false; &#125; else if(ten != 0) &#123;//10、5的情况 five--; ten--; &#125; else &#123; if(five &gt;= 3) &#123;//5,5,5的情况 five -= 3; &#125; else &#123; return false; &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125; 思路及总结感觉这个题目没有体现所谓贪心算法的思想，只是一些if else的语句，以及需要考虑一些边界问题。 参考https://www.smwenku.com/a/5bb2d3692b71770e645e1c2b/zh-cn/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux学习6]]></title>
    <url>%2F2019%2F02%2Fyuque%2Flinux_learning6%2F</url>
    <content type="text"><![CDATA[文件和目录属性 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html Linux目录结构 概述对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学号Linux的至关重要的一步，深入了解Linux文件目录结构的标准和每个目录的详细功能，对于我们用好Linux系统至关重要，下面我们就开始了解Linux目录结构的相关知识。当在使用Linux的时候，如果您通过ls -l/ 就会发现，在/下包含很多的目录，比如etc、usr、var、bin…等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就像树形结构，所以我们可以把文件新系统的结构形象称为树形结构。文件系统是用力啊组织和排列文件存取的，所以他是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/起始的树形结构。Linux文件系统的最顶端是/，我们称/为Linux的root，也就是Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是上级的领导者。由于Linux是开放源代码，各大公司和团体根据Linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的pc。因为你根本不知道一些基本的配置，文件在哪里。。这就造成了混乱。这就是FHS(Filesystem Hierarchy Standard )机构诞生对的原因。该机构是Linux爱好者自发组成的一个团体，主要是对Linux做一些基本的要求，不至于是操作者换一台主机就成了Linux的“文盲”。根据FHS (http://www.pathname.com/fhs/) 的官方文件指出，他们的主要目的是希望让使用者可以了解发哦已安装软件通常放置于哪个目录下，所以他们希望独立的软件开发上、操作系统制作者、以及想要维护系统的用户，都能遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做的好处非常多，因为Linux操作系统就能够与在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样： 可分享的(shareable) 不可分享的(unshareable) 不变的(static) /usr (软件放置处) /etc (配置文件) /opt (第三方协力软件) /boot (开机与核心档) 可变动的(variable) /var/mail (使用者邮件信箱) /var/run (程序相关) /var/spool/news (新闻组) /var/lock (程序相关) 四种类型 可分享的可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录； 不可分享的自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 不变的有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等； 可变动的经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：/(root，根目录)：与开机系统有关/usr (unix software resource)：与软件安装/执行有关；/var (variable)：与系统运作过程有关。 根目录(/)的意义与内容根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。根据以上原因，FHS认为根目录(/)下应该包含如下子目录： 目录 应放置档案内容 /bin 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp, / dev/hd, /dev/sd*等等 /etc 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home 这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /media media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 /opt 这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 /root 系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 /sbin Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srv srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 事实上FHS针对根目录所定义的标准就仅限与上表，不过仍旧有些目录也需要我们了解一下，具体如下： 目录 应放置文件内容 /lost+found 这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc 这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys 这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录户被挂载，其他跟去则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：/etc：配置文件/bin：重要执行档/dev：所需要的装置文件/lib：执行档所需的函式库与核心所需的模块/sbin：重要的系统执行文件这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 /usr的意义与内容依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)，如果你知道如何透过网络进行分区的挂载（例如在服务器篇会谈到的NFS服务器），那么/usr确实可以分享给局域网络内的其他主机来使用喔。/usr不是user的缩写，其实usr是Unix Software Resource的缩写，也就是Unix操作系统软件资源放置的目录，而不是用户的数据啦。这点要注意。FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr的次目录建议有底下这些： 目录 应放置文件内容 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/ 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件/usr/share/doc：软件杂项的文件说明/usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var的意义与内容如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有： 目录 应放置文件内容 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档 /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/ 非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/ 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/ 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用 由于FHS仅是定义出最上层(/)及次层(/usr,/var)的目录内容应该要放置的文件或目录数据，因此，在其他次目录层级内，就可以随开发者自行来配置了。 目录树(directory tree) :在Linux底下，所有文件与目录都是由根目录开始的。那是所有目录与文件的源头，然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directoty tree)，这个目录的主要特性有：目录树的起始点为根目录(/，root)；每一个目录不止能使用本地端的partition的文件系统，也可以使用网络上的filesystem。举例来说，可以利用Network File System(NFS)服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示： 绝对路径和相对路径除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名的写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。这两种文件名/路径的写法依据是这样的：绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？cd /var/log (absolute)cd ../var/log (relative)因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。这个.与..目录概念是很重要的，你常常会看到cd ..或./command 之类的指令下达方式，就是代表上一层与目前所在目录的工作状态。 实例网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin,/usr/bin等为正规),此时要执行指令就要严格指定该执行档。./代表某目录的意思，所以./run.sh代表执行本目录下，名为run.sh的文件。 Linux文件类型与扩展名 概述Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。我们通过一般应用程序而创建的比如file.txt、file.tar.gz，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多是常规文件（也被称为普通文件）。 文件类型Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等，现在我们进行一个简要的说明。 普通文件我们用ls -lh来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是-，这样的文件在Linux中就是普通文件。这些文件一般使用一些相关的应用程序创建，比如图像工具、文档工具、归档工具…或cp工具等。这类文件的删除方式是用rm命令。另外，依照文件的内容，有大略可以分为： 纯文本档(ASCII):这是Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令：cat ~/.bashrc看到该文件的内容。(cat是将一个文件内容读出来的指令)。 二进制文件(binary)：Linux系统其实仅认识切可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts,文字型批处理文件不算)就是这种格式的文件。刚刚使用的cat命令就是一个binary file。 数据格式文件(data)：有些程序在运作的过程中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件(data file)。举例来说，我们的Linux在使用者登录时，都会精登录的数据记录在/var/log/wtmp那个文件内，该文件是一个data file，他能够透过last这个指令读出来！但是使用cat时，会读出乱码~因为贪睡属于一种特殊格式的文件 目录文件当我们在某个目录下执行，看到有类似drwxr-xr-x，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用mkdir命令，或cp命令，cp可以把一个目录复制为另一份目录。删除用rm或rmdir命令。 字符设备或块设备文件如果你进入/dev目录，列一下文件，会看到类似如下的:[root@localhost ~]# ls -al /dev/ttycrw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty[root@localhost ~]# ls -la /dev/sda1brw-r—– 1 root disk 8, 1 11-03 07:11 /dev/sda1我们看到/dev/tty的属性是crw-rw-rw-,注意前面第一个字符是c，这表示字符设备文件。比如猫等串口设备。我们看到/dev/sdal 的属性是brw-r—-，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。这个种类的文件，使用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。与系统周边及存储相关的一些文件，通常都集中在/dev这个目录之下通常又分成两种： 区块(block)设备档就是一些存储数据，以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是啦。你可以随机的在硬盘的不同区块读写，这种装置就是成组设备！你可以自行查一下/dev/sda看看，会发现第一个属性为 [b] ！ 字符(character)设备文件亦即是一些串行端口的接口设备，例如键盘、鼠标等等！这些设备的特设就是一次性读取的，不能够结算输出。举例来说，你不可能让鼠标调到另一个画面，而是滑动到另一个地方！第一个属性为[c]。 数据接口文件(sockets)：数据接口问文件(或者：套接口文件)，这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求，而客户端就可以透过这个socket来进行数据的沟通了。第一个数次那个为[s]，最常在/var/run这个目录中看到这种文件类型了。例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。[root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock注意这个文件的属性的第一个字符是s。 符号链接文件：当我们查看文件属性时，会看到有类似lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。是通过ln -s源文件名 新文件名。上面是一个例子，表示setup.log是instal.log的软链接文件。怎么理解呢？这和Windows操作系统中的快捷方式有点相似。符号链接文件的创建方法举例：[root@localhost test]# ls -lh log2012.log-rw-r–r– 1 root root 296K 11-13 06:03 log2012.log[root@localhost test]# ln -s log2012.log linklog.log[root@localhost test]# ls -lh *.loglrwxrwxrwx 1 root root 11 11-22 06:58 linklog.log -&gt; log2012.log-rw-r–r– 1 root root 296K 11-13 06:03 log2012.log 数据输送文件(FIFO，pipe):FIFO也是一种特殊的文件了类型，他主要的目的在解决多个程序同时存取一个问价所造成的错误问题。FIFO是first-in-first-out的缩写。第一个属性为[p]。 Linux文件扩展名 扩展名类型基本上，Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的是个属性有关，与档名根本一点关系也没有。这个观念和Windows的情况不相同。在Windows底下，能被执行的文件扩展名通常是.com,.exe,.bat等等。而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ]即代表这个文件可以被执行。不过，可以被执行根可以执行成功破那个是不一样的，举例来说，在root/home 目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个问价能够真的执行成功吗？当然就要看该文件的内容。虽然如此，不过我们任然希望可以藉由扩展名来了解该文件是什么东西，所以，通常我么还是会以适当的扩展名表示该文件是什么种类的。底下有数种常用的扩展名：.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .shZ, .tar, .tar.gz, .zip, .tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！.html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。 基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件 ，如常用的/bin/ls这个显示文件属性的指令，不过，如果这个问价的权限被修改为无法执行时，那么ls就变成不能执行。上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的Linux系统中就是无法执行！呵呵！那么就是可能文件的属性被改变了。不要怀疑，从网络上床送到你的Linux系统中，文件的属性与权限确实是会被改变的。 Linux文件名长度限制在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：单一文件或目录的最大容许文件名为 255 个字符包含完整路径名称及目录 (/) 之完整档名为 4096 个字符是相当长的档名！我们希望Linux的文件名可以一看就知道该文件在干嘛的， 所以档名通常是很长很长。 Linux文件名的字符的限制由于Linux在文字接口下的一些指令操作关系，一般来说，你在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如底下这些：* ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { }因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“.”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以你最好也避免将文件档名的开头以 - 或 + 来命名。 Linux文件属性详解 概述Linux文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。具体情况如下：命令： ls -lih输出：[root@localhost test]# ls -lih总计 316K2095120 lrwxrwxrwx 1 root root 11 11-22 06:58 linklog.log -&gt; log2012.log2095112 -rw-r–r– 1 root root 296K 11-13 06:03 log2012.log2095110 -rw-r–r– 1 root root 61 11-13 06:03 log2013.log2095107 -rw-r–r– 1 root root 0 11-13 06:03 log2014.log2095117 -rw-r–r– 1 root root 0 11-13 06:06 log2015.log2095118 -rw-r–r– 1 root root 0 11-16 14:41 log2016.log2095119 -rw-r–r– 1 root root 0 11-16 14:43 log2017.log2095113 drwxr-xr-x 6 root root 4.0K 10-27 01:58 scf2095109 drwxrwxr-x 2 root root 4.0K 11-13 06:08 test32095131 drwxrwxr-x 2 root root 4.0K 11-13 05:50 test4说明：第一列：inode第二列：文件种类和权限；第三列： 硬链接个数；第四列： 属主；第五列：所归属的组；第六列：文件或目录的大小；第七列和第八列：最后访问或修改时间；第九列：文件名或目录名我们以log2012.log为例：2095112 -rw-r–r– 1 root root 296K 11-13 06:03 log2012.loginode 的值是：2095112 文件类型：文件类型是-，表示这是一个普通文件； 关于文件的类型，请参考：每天一个linux命令(24)：Linux文件类型与扩展名 文件权限：文件权限是rw-r–r– ，表示文件属主可读、可写、不可执行，文件所归属的用户组不可写，可读，不可执行，其它用户不可写，可读，不可执行；硬链接个数： log2012.log这个文件没有硬链接；因为数值是1，就是他本身；文件属主：也就是这个文件归哪于哪个用户 ，它归于root，也就是第一个root；文件属组：也就是说，对于这个文件，它归属于哪个用户组，在这里是root用户组；文件大小：文件大小是296k个字节；访问可修改时间 ：这里的时间是最后访问的时间，最后访问和文件被修改或创建的时间，有时并不是一致的；当然文档的属性不仅仅包括这些，这些是我们最常用的一些属性。 关于inodeinode 译成中文就是索引节点。每个存储设备或存储设备的分区(存储设备是硬盘、软盘、u盘等等)被格式化为文件系统后，应该有两部分，一部分是inode，另一部分是Block，Block是用来存储数据用的。而inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令，能通过inode值最快的找到相对应的文件。做个比喻，比如一本书，存储设备或跟去就相当于这本书，Block相当于书中的每一页，inode 就相当与这本书前面的目录，一本书有很多的内容，如果想查找某部分的内容，我们可以先查目录，通过目录能最快的找到我们想要看的内容。虽然不太恰当，但还是比较形象。当我们用ls查看某个目录或文件时，如果加上-i参数，就可以看到inode节点了，比如我们前面所说的例子：[root@localhost test]# ls -li log2012.log 2095112 -rw-r–r– 1 root root 302108 11-13 06:03 log2012.loglog2012.log 的inode值是 2095112 ； 查看一个文件或目录的inode，要通过ls 命令的的 -i参数。 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[264. Ugly Number II]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fnum_264%2F</url>
    <content type="text"><![CDATA[题目描述Write a program to find the n-th ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example:Input: n = 10Output: 12Explanation: 11, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 110 ugly numbers.Note: 1 is typically treated as an ugly number. n does not exceed 1690.参考代码 12345678910111213141516171819202122class Solution &#123; public int nthUglyNumber(int n) &#123; int factors[] = &#123;2,3,5&#125;; //优先队列 Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;(); queue.offer(1L); 注意第1690个可能会超过int的范围 while (true) &#123; long min = queue.poll();//每次取最小值相乘，取得第n个数 if (n == 1) &#123; return (int)min; &#125; for (int i = 0; i &lt; 3; i++) &#123; long ugly = factors[i] * min; if(!queue.contains(ugly)) &#123;//去重 queue.offer(ugly); &#125; &#125; n--; &#125; &#125;&#125; 思路及总结利用优先队列进行排序，然后将2、3、5中最小值作为下次相乘的因子，确保没有重复的数字，queue.poll()取得的是即是第 1\2\3\4\5。。。 个数,当n = 1 时，min即是第n个数. 参考https://chuansongme.com/n/1648591652025]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LInux学习5]]></title>
    <url>%2F2019%2F01%2Fyuque%2Flinux_learning5%2F</url>
    <content type="text"><![CDATA[网络命令 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html ifconfig命令 概述许多Windows非常熟悉ipconfig命令工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有类似的工具，也就是ifconfig（interfaces config）。通常需要以root身份登录或者使用sudo以便在LInux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息等，还可以修改这些配置 命令格式ifconfig[网络设备][参数] 命令参数12345678910111213141516171819up 启动指定网络设备/网卡。down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。arp 设置指定网卡是否支持ARP协议。-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包-a 显示全部接口信息-s 显示摘要信息（类似于 netstat -i）add 给指定网卡配置IPv6地址del 删除指定网卡的IPv6地址&lt;硬件地址&gt; 配置网卡最大的传输单元mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。tunel 建立隧道dstaddr 设定一个远端地址，建立点对点通信-broadcast&lt;地址&gt; 为指定网卡设置广播协议-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议multicast 为网卡设置组播标志address 为网卡设置IPv4地址txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度 常用命令实例：显示网络设备信息（激活状态的）命令：ifconfig[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:20 inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB)说明：eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址（MAC地址）是 00:50:56:BF:26:20inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204，广播地址， Bcast:192.168.120.255，掩码地址Mask:255.255.255.0 lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）第二行：网卡的IP地址、子网、掩码第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节第四、五行：接收、发送数据包情况统计第七行：接收、发送数据字节数统计信息。实例：启动关闭指定网卡命令：ifconfig eth0 upifconfig eth0 down说明：ifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 实例：为网卡配置和删除IPv6地址命令：ifconfig eth0 add 33ffe:3240:800:1005::2/64ifconfig eth0 del 33ffe:3240:800:1005::2/64说明：ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0配置IPv6地址；ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址；练习的时候，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 实例：用ifconfig修改MAC地址命令：ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE[root@localhost ~]# ifconfig eth0 down //关闭网卡[root@localhost ~]# ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE //修改MAC地址[root@localhost ~]# ifconfig eth0 up //启动网卡[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:AA:BB:CC:DD:EE inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB)[root@localhost ~]# ifconfig eth0 hw ether 00:50:56:BF:26:20 //关闭网卡并修改MAC地址 [root@localhost ~]# ifconfig eth0 up //启动网卡[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:20 inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB) 实例：配置IP地址命令：[root@localhost ~]# ifconfig eth0 192.168.120.56 [root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 [root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255说明：ifconfig eth0 192.168.120.56 给eth0网卡配置IP地：192.168.120.56 ifconfig eth0 192.168.120.56 netmask 255.255.255.0 给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255/给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255实例：启动和关闭ARP协议命令：[root@localhost ~]# ifconfig eth0 arp [root@localhost ~]# ifconfig eth0 -arp说明：ifconfig eth0 arp 开启网卡eth0 的arp协议；ifconfig eth0 -arp 关闭网卡eth0 的arp协议； 实例：设置最大传输单元命令：ifconfig eth0 mtu 1500[root@localhost ~]# ifconfig eth0 mtu 1480[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:1F inet addr:192.168.120.203 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1480 Metric:1 RX packets:8712395 errors:0 dropped:0 overruns:0 frame:0 TX packets:36631 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:597062089 (569.4 MiB) TX bytes:2643973 (2.5 MiB)[root@localhost ~]# ifconfig eth0 mtu 1500[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:1F inet addr:192.168.120.203 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8712548 errors:0 dropped:0 overruns:0 frame:0 TX packets:36685 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:597072333 (569.4 MiB) TX bytes:2650581 (2.5 MiB)说明：设置能通过的最大数据包大小为1500bytes备注：用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在，要想将上述的配置信息永远的存在电脑里，那就要修改网卡的配置文件了。 route命令 概述Linux系统的toute命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在 / etc/rc.local 中添加 route 命令来保证该路由设置永久有效。 命令格式route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络连接口，如eth0。当使用参数时，路由表被修改，如果没有参数，则显示路由表当前内容 命令参数1234567891011121314151617181920-c 显示更多信息-n 不解析名字-v 显示详细的处理信息-F 显示发送信息-C 显示路由缓存-f 清除所有网关入口的路由表。 -p 与 add 命令一起使用时使路由具有永久性。add: 添加一条新路由。del: 删除一条路由。-net: 目标地址是一个网络。-host: 目标地址是一个主机。netmask: 当添加一个网络路由时，需要使用网络掩码。gw: 路由数据包通过网关。注意，你指定的网关必须能够达到。metric：设置路由跳数。Command 指定您想运行的命令 (Add/Change/Delete/Print)。 Destination 指定该路由的网络目标。 mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表 (与转发的数据包目标地址最匹配) 的多个路由中进行选择时可以使用。 if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。 常用命令实例：显示当前路由命令：routeroute -n[root@localhost ~]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.120.0 * 255.255.255.0 U 0 0 0 eth0e192.168.0.0 192.168.120.1 255.255.0.0 UG 0 0 0 eth010.0.0.0 192.168.120.1 255.0.0.0 UG 0 0 0 eth0default 192.168.120.240 0.0.0.0 UG 0 0 0 eth0[root@localhost ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.120.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0192.168.0.0 192.168.120.1 255.255.0.0 UG 0 0 0 eth010.0.0.0 192.168.120.1 255.0.0.0 UG 0 0 0 eth00.0.0.0 192.168.120.240 0.0.0.0 UG 0 0 0 eth0说明：第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240其中Flags为路由标志，标记当前网络节点的状态。Flags标志说明： 1234567U Up表示此路由当前为启动状态H Host，表示此网关为一主机G Gateway，表示此网关为一路由器aR Reinstate Route，使用动态路由重新初始化的路由D Dynamically,此路由是动态性地写入aM Modified，此路由是由路由守护程序或导向器动态修改! 表示此路由当前为关闭状态 备注：route -n (-n 表示不解析名字,列出速度会比route 快) 实例：添加网关/设置网管命令：route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0说明：增加一条 到达 244.0.0.0 的路由 实例：删除路由记录命令：route del -net 224.0.0.0 netmask 240.0.0.0route del -net 224.0.0.0 netmask 240.0.0.0 reject说明：删除224.0.0.0的路由记录 实例 ：删除和添加设置默认网关命令：route del default gw 192.168.120.240route add default gw 192.168.120.240 ping命令 概述Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说”ping一下某机器，看是不是开着“、不能打开网页时会说””你先ping网关地址192.168.1.1试试“。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样而我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。 命令格式ping [参数] [主机名或IP地址] 命令功能ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数1234567891011121314-d 使用Socket的SO_DEBUG功能。-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应。-n 只输出数值。-q 不显示任何传送封包的信息，只显示最后的结果。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。-R 记录路由过程。-v 详细显示指令的执行过程。&lt;p&gt;-c 数目：在发送指定数目的包后停止。-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-I 网络界面：使用指定的网络界面送出数据包。-l 前置载入：设置在送出要求信息之前，先行发出的数据包。-p 范本样式：设置填满数据包的范本样式。-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。-t 存活数值：设置存活数值TTL的大小。 常用命令实例：ping的通的情况命令：ping 192.168.120.205输出：[root@localhost ~]# ping 192.168.120.205PING 192.168.120.205 (192.168.120.205) 56(84) bytes of data.64 bytes from 192.168.120.205: icmp_seq=1 ttl=64 time=0.720 ms64 bytes from 192.168.120.205: icmp_seq=2 ttl=64 time=0.181 ms64 bytes from 192.168.120.205: icmp_seq=3 ttl=64 time=0.191 ms64 bytes from 192.168.120.205: icmp_seq=4 ttl=64 time=0.188 ms64 bytes from 192.168.120.205: icmp_seq=5 ttl=64 time=0.189 ms— 192.168.120.205 ping statistics —5 packets transmitted, 5 received, 0% packet loss, time 4000msrtt min/avg/max/mdev = 0.181/0.293/0.720/0.214 ms[root@localhost ~]# 实例：ping不通的情况命令：ping 192.168.120.202输出：[root@localhost ~]# ping 192.168.120.202PING 192.168.120.202 (192.168.120.202) 56(84) bytes of data.From 192.168.120.204 icmp_seq=1 Destination Host UnreachableFrom 192.168.120.204 icmp_seq=2 Destination Host Unreachable实例：ping指定次数命令：ping -c 10 192.168.120.206 实例：时间间隔和次数限制的ping命令：ping -c 10 -i 0.5 192.168.120.206 实例：多参数使用命令：ping -i 3 -s 1024 -t 255 192.168.120.206说明：-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255 traceroute命令 概述通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname而在Windows系统下是执行tracert的命令：tracert hostname 命令格式traceroute[参数][主机] 命令功能traceroute命令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] 命令参数123456789101112131415-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。 常用命令实例1：traceroute 用法简单、最常用的用法命令：traceroute www.baidu.com输出：[root@localhost ~]# traceroute www.baidu.comtraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets 1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms 2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms 3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms 4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms 5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms 6 61.148.154.97 (61.148.154.97) 718.908 ms bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms 7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms 8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms 9 30 *[root@localhost ~]# 说明：记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。 Traceroute的工作原理Traceroute最简单的基本用法是：traceroute hostnameTraceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。 scp命令 概述scp命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp知识在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外scp还非常不占资源，不会提高多少系统负荷，在这一点上rsync就远远不及它了。虽然rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 命令格式scp [参数] [原路径] [目标路径] 命令功能scp是secure copy的缩写，scp是Linux系统基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在Linux服务器之间复制文件和目录。 命令参数1234567891011121314151617-1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 常用命令实例：从远处复制到本地/从本地复制到远处命令：scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest说明：从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fnum_155%2F</url>
    <content type="text"><![CDATA[题目描述Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041class MinStack &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; /** initialize your data structure here. */ public MinStack() &#123; stackData = new Stack&lt;Integer&gt;(); stackMin = new Stack&lt;Integer&gt;(); &#125; public void push(int x) &#123; stackData.push(x); if(stackMin.isEmpty() || x &lt;= stackMin.peek()) &#123;//最小值栈的为空或这最小值小于等于 stackMin.push(x); &#125; &#125; public void pop() &#123; Integer num = stackData.pop(); if(num.equals(stackMin.peek())) &#123;//要用equals函数 stackMin.pop(); &#125; &#125; public int top() &#123; return stackData.peek(); &#125; public int getMin() &#123; return stackMin.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 思路及总结利用两个栈，一个代表最小值，一个代表普通情况。注意最小值栈要依靠普通栈，普通栈中最小值出栈，最小值栈的最小值也要出栈。另外自己基础太差，wrong answer的时候一直没发现要用equals才能进行更合理的比较。希望自己以后更深入的时候能有更好的理解。 参考https://blog.csdn.net/loophome/article/details/83749444https://blog.csdn.net/returnzhang/article/details/78608898]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[215. 数组中的第K个最大元素]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fnum_215%2F</url>
    <content type="text"><![CDATA[题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例 1:输入: 1[3,2,1,5,6,4] 和 k = 2输出: 5示例 2:输入: 1[3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4说明:你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 参考代码123456789101112class Solution &#123; public static int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(); for(int num :nums) &#123; priorityQueue.add(num); if(priorityQueue.size() &gt; k) &#123; priorityQueue.poll(); &#125; &#125; return priorityQueue.peek(); &#125;&#125; 思路及总结主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。 参考https://www.kancloud.cn/maliming/leetcode/844880]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[11. Container With Most Water]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fnum_11%2F</url>
    <content type="text"><![CDATA[题目描述Given _n_ non-negative integers _a_, _a_, …, _a_, where each represents a point at coordinate (_i_, _a_). _n_ vertical lines are drawn such that the two endpoints of line _i_ is at (_i_, _a_) and (_i_, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and _n_ is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example:Input: [1,8,6,2,5,4,8,3,7]Output: 49 参考代码123456789101112131415class Solution &#123; public int maxArea(int[] height) &#123; int max = 0; boolean temp; for(int i = 0,j = height.length - 1;i &lt; j;) &#123; int h = (height[i] &gt; height[j]) ? height[j] : height[i]; if(h * (j - i)&gt;max) max = h * (j - i); temp = (height[i] &lt; height[j]) ? true : false; if(temp) i++; else j--; &#125; return max; &#125;&#125; 思路及总结较为简单的思路就是采用双指针，从两边往中间逼近，并没有什么边界问题，主要是注意在寻找最多水的容器过程中要一直把较深的一边留下，即沿着较小的边界进行移动（因为较小的边界不可能再产生更多的水）。 参考https://blog.csdn.net/qq_40435621/article/details/84790436]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vim实用技巧]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fvim_skill%2F</url>
    <content type="text"><![CDATA[希望由厚至薄 概述 学习Vim，最难受的就是它对新手出名的不友好，网上一大堆乱七八糟的东西，还是自己进行学习对自己的帮助最大。建议首先学习 :vimtutor 入门vim学习。最好会盲打，自己看了这本 vim 实用技巧。 第 1 章 Vim解决问题的方式{char} 是指任意字符 指cw会删除光标位置到当前词位置结尾处的文本，并进入插入模式&gt;G是首行缩进C=c$ 删除到行尾再插入o=A下一行插入s删除光标处再插入@：重复命令行命令&amp;重复替换命令f{char} 搜索，; 下一个字符，, 上一个字符* 可以查看当前光标下的单词理想模式：用一个键移动，另一键执行。又称为 “.范式”。 第一部分 模式Vim 提供一个区分模式的用户界面，就是说在 Vim 中按键盘上的任意键所产生的结果可能会不一样，而这取决于当前正处于哪种模式，以及如何在各模式间切换，是极其重要的。在本书的这一部分，我们将学习每种模式的工作方式及其用途。 第 2 章 普通模式b 把光标移动到单词开头daw 在单词末尾也能删除 在数字上执行加一，不在数字上，在当前行正向查找一个数字，10 在数字上执行减一最好不要用数字 d2w 这样，因为 . 能很好代替，但是 c3w 有用，行中间来快速进行修改g~ 反转大小写，gu 转成小写，gU转成大写。gUap 将一段转换为大写，g 当成操作符前缀gc{motion} 切换为注释状态，gcap 切换当前段落的注释状态。gcG 当前行到文件结尾间的所有内容注释掉，gcc 注释当前行，gg=G 自动缩进整个文件。 第 3 章 插入模式在输入错误时，专业打字员会建议先删除整个单词，然后再重新输入一遍。 删除前一个字符（同退格键） 删除前一个单词 删至行首。&lt;c-[&gt;切换到普通模式， 切换到插入-普通模式。在此模式中，可以执行一个普通模式命令，执行完后，马上又返回到插入模式 按键操作 缓冲区内容 yt, Practical Vim, by Drew NeilRead Drew Neil’s jA␣ Practical Vim, by Drew NeilRead Drew Neil’s 0 Practical Vim, by Drew NeilRead Drew Neil’s Practical Vim . Practical Vim, by Drew NeilRead Drew Neil’s Practical Vim. yt, 命令把“Practical Vim”复制到复制专用寄存器中,0 把刚才复制的文本粘贴到光标所在位置= 符号指明使用表达式寄存器,=6*35，将执行结果插入到文档的当前位置{code}根据字符编码插入字符，{code} 是要插入字符的编码，065插入Au{1234} 以十六进制字符编码插入字符ga 分别以十进制和十六进制的形式显示出其字符编码{char1}{char2} 插入以二合字母{char1}{char2}表示的字符，?I 表示的“¿”字符，二合字母 12 指1⁄2R 命令可以由普通模式进入替换模式，“,␣b” 替换原有的“. ␣ B”字符gR 进入虚拟替换模式(Virtual Replace mode)，把制表符当成一组空格进行处理，输入制表符占据的最后一个字符，该字符会替换制表符。 第 4 章 可视模式viw 来高亮选择这个词,用 c 命令进行修改V 激活面向行的可视模式 激活面向列块的可视模式gv 重选上次的高亮选区o 切换高亮选区的活动端，vbb ，o ，e重复执行面向行的可视命令，Vj ，&gt;.vit 可被解读为高亮选中标签内部的内容(visually select inside the tag),it 命令是一种被称为文本对象(text object)gUit 要优于 vitU 命令，首选操作符命令，再者是可是模式命令，可视模式擅长一次性处理和动作命令难以构建的文本范围技巧24 面向列块的可是模式编辑表格数据，在一行下生成分割线 yyp，Vr-列块可视模式,插入操作只影响顶行，但实际影响所有，插入模式时间很短暂I 命令把光标置于当前行的开头 第 5 章 命令行模式有些命令在插入模式和命令行模式中可以通用。例如,可以用 和 分别删除至上个单词的开头及行首,也可以用 或 来插入键盘上找不到的字符,还可以用 {register} 命令把任意寄存器的内容插入到命令行。Ex 命令可以在任意位置执行 :3d 等于 3G dd 一定程度上要比普通模式命令要快. 代表当前行的地址，:.,$d 这样的命令可能很实用% 代表当前文件中的所有行，:%s/Practical/Pragmatic/可视模式加命令行模式，VG，输入 ：命令行上就会预先填充一个范围 :’&lt;,’&gt; 。代表高亮选区的范围:6copy. 命令解读为“为第 6 行创建一份副本,并放到当前行下方”，:copy 简写:co 或是 :t:t6 把当前行复制到第 6 行下方，:t$ 把当前行复制到文本结尾快速跳回原先的位置( )，在复制距离较远的行时, :t 命令通常更加高效。: yyp 会使用寄存器，不想覆盖默认寄存器中的当前内容时，可以考虑使用 :t. 来复制行:’&lt;,’&gt;m$ 等于 :’&lt;,’&gt;m$，重复上次的 Ex 命令 @:‘&lt;,’&gt;normal . 命令可以解读为“对高亮选区中的每一行,对其执行普通模式下的 . 命令”。:%normal i// 把整个 JavaScript 文件注释掉:normal 命令则让我们可以把具有强大表现力的 Vim 普通模式命令与具有大范围影响力的 Ex 命令结合在一起遍历缓冲区列表的条目，:bn[ext] 可以在列表中逐项正向移动,而 :bp[revious] 命令则进行反向移动 逐个查看每个缓冲区 :bnext，@: 命令和:bprevious 命令可能会出现反向遍历缓冲区列表，将人搞糊涂，更好用 命令，该命令会回到跳转列表的上条记录。想往回跳,就用 命令。 命令会让 Vim 显示可用的补全列表，按 键依次显示 用于插入光标下的单词，插入光标下的字串，一般和 * 、:%s 一起使用，:%s///g命令行窗口就像是一个常规的 Vim 缓冲区,只不过它的每行内容都对应着命令历史中的一个条目。我们可以用 k 及 j 键在历史中向前或向后移动,也可以用 Vim 的查找功能查找某一行。在按下 键时,将会把当前行的内容当成 Ex 命令加以执行。好处是强大的vim编辑能力可以派上用场。q: 调出命令行窗口，J 命令合并下一行，命令行窗口处于打开状态时,它会始终拥有焦点。 从命令行模式切换到命令行窗口，已经输入到命令行上的内容仍然会得以保留:!ls 执行 Shell 中的程序，在 Vim 的命令行中,符号 % 代表当前文件名(指调用了shell程序时)执行几条命令:shell 命令来启动一个交互的 shell 会话,用 exit 命令可以退出此 shell 并返回 Vim把 Vim 置于后台，看书 p 94 命令会产生大量输出，用:read !{cmd} 命令，它让我们把命令的标准输出重定向到缓冲区。:write !{cmd} 做相反的事。它把缓冲区内容作为指定 {cmd} 的标准输入:write! sh 把缓冲区内容写到一个名为 sh 的文件，叹号放得位置不同,命令的作用]也大相径庭。:write !sh 命 令 的 作 用 是 在 shell 中 执 行 当 前 缓 冲 区 中 的 每 行 内 容Vim 把过滤器定义为“一个由标准输入读取文本,并对其进行某种形式的修改后输出到标准输出的程序”:2,$!sort -t’,’ -k2，命令行结合 shell 来对文本进行处理。Vim 提供了一种方便的快捷方式来设置 :[range]!{filter} 命令中的范围。我们可以用 !{motion} 操作符切换到命令行模式,并把指定 {motion} 所涵盖的范围预置在命令行上，如果我们把光标移到第 2 行,然后执行 !G ,Vim 就会打开命令行并把范围 :.,$! 预置在命令行上。虽然此后我们仍需输入剩下的 {filter} 命令,但这毕竟节省了部分工作。:read !{cmd} 在 shell 中执行 {cmd} ,并把其标准输出插入到光标下方:[range]write !{cmd} 在 shell 中执行 {cmd} ,以 [range] 作为其标准输入:[range]!{filter} 使用外部程序 {filter} 过滤指定的 [range] 第二部分 文件在本书的这一部分，我们将学习如何使用文件及缓冲区。Vim 允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。另外，我们还会看到在 Vim 中打开文件的机种不同方式，并掌握一些方法来解决无法把缓冲区保存到文件的问题。 第 6 章 管理多个文件我们编辑的只是内存中的映像，也就是 Vim 术语中的“缓冲区”。 :ls 命令会列出所有被载入到内存中的缓冲区的列表， :bnext 命令可以切换到列表中的下一个缓冲区，% 符号指明哪个缓冲区在当前窗口中可见，而 # 符号则代表轮换文件。按 &lt;C-^&gt; 可以在当前文件和轮换文件间快速切换。 :bprev (bp) 和 :bnext (bn)在列表中反向或正向移动；而 :bfirst 和 :blast 则分别跳到列表的开头和结尾 12《 1 # "a.txt" line 1 2 %a "b.txt" line 1 :buffer N 命令直接凭编号跳转到一个缓冲区，:buffer {bufname} 格式实现同样的功能。{bufname} 只需包含文件路径中 足以唯一标识此缓冲区的字符即可 删除缓冲区，可以用 :bdelete 命令, :5,10bd ,删除编号 5～10（包含 5 和 10）的缓冲区 用 :argdo 命令可以在参数列表中的每个文件上执行一条 Ex 命令。 当不带参数运行 :args 命令时，它会打印当前参数列表的内容。 :args {arglist} {arglist} 可以包括文件名、通配符，甚至是一条 shell 命令的输出结果 填充参数列表最简单的方式是逐一指定文件的名字：➾ :args index.html app.js 通配符也匹配 0 个或多个字符，但它可以递归进入指定目录的子目录 :args /.js , :args **/.js */.css :args cat .chapters 按 Go 在缓冲区的结尾增加一个空行,缓冲区 a.txt 前有一个 + 号，表示这个缓冲区被修改过了,被标记为 h，表示它是一个隐藏缓冲区（hidden） :w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区（即回滚所做修改） :qa[ll]! 关闭所有窗口，摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 启用‘hidden’选项,运行完 :argdo {cmd} 后,一切正常，可以运行 :argdo write （或 :wall）来保存所有的缓冲区。 用 s 命令可以水平切分此窗口，使之成 为两个高度相同的窗口；或者可以用 v 命令对其进行垂直切分，这样会产生两 个宽度相同的窗口 编辑长文件时,可以滚动其中一个窗口，使之显示缓冲区的一部分，这样，在修改第二 个窗口中缓冲区的另外一部分时，就可以参考第一个窗口中的内容。 :sp[lit] {file} 水平切分当前窗口，并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口，并在新窗口中载入{file}w 在窗口间循环切换 h 切换到左边的窗口 j 切换到下边的窗口 k 切换到上边的窗口 l 切换到右边的窗口,按住 键，然后再输入 ww （或 wj ，或上表中的其他命令）来切换活动窗口。 = 使所有窗口等宽、等高 _ 最大化活动窗口的高度 | 最大化活动窗口的宽度 [N]_ 把活动窗口的高度设为[N]行 [N]| 把活动窗口的宽度设为[N]列,用鼠标做最好 用 :edit 命令打开一个文件时，Vim 却不会自动创建一 个新标签页，而是会创建一个新缓冲区，并把该缓冲区显示到当前窗口。应该把标签页想成容纳一系 列窗口的容器 :lcd {path} 命令让我们可以设置当前窗口的本地工作目录。如果我们创建了一 个新标签页，并用 :lcd 命令切换到另一个目录，那么就可以把每个标签页限制在不 同的工程范围内。用 :tabedit {filename} 命令可以打开一个新的标签页，如果省略了 {filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区 T 命 令把当前窗口移到一个新标签页中 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页，关闭所有其他标签页 :tabmove [N] 命令可以重新排列标签页。省略了 [N]，当前标签页会被移到结尾，如果支持鼠标，则用鼠标拖拽 第 7 章 打开及保存文件:edit {file} 命令可以接受相对于工作目录的文件路径 % 符号代表活动缓冲区的完整文件路径，:h 修饰符会去除文件名，但保留路径中的其他部分 :edit %:hM $ vim . 在按 键时，Vim 会打开光标下的条 目。如果光标位于目录上，那么此窗口的内容会更新为该目录的内容；如果光标位于文件上，那么该文件会被载入一个缓冲区里，并把它显示在当前窗口中。这将导致当 前窗口中的文件管理器被该缓冲区的内容所替代 :edit . :e. 打开文件管理器，并显示当前工作目录 :Explore :E 打开文件管理器，并显示活动缓冲区所在的目录 :E 及 :e. 命令表现得有些古怪，因为它们会用文件管理器替换掉当前窗口的内容，想象成一张纸牌，如果在调出文 件管理器后，又想切换回刚才正在编辑的那个文件，此时可以使用 &lt;C-^&gt; 命令。 杀手级功能，其名字正因为此功能而来，即 netrw 可 以通过网络读写文件。该插件可以利用多种协议读写网络文件，包括 scp、ftp、curl 及 wget，这取决于你的系统上可以用哪些协议。（手动流汗） 命令用于显示当前文件的文件名及状态，以超级用户执行，tee /etc/hosts &gt; /dev/null。这条命令会把缓冲区的内容当作标准输入，并用它来覆盖 /etc/hosts 文件的内容，下面文件与缓冲区的内容刚好是完全一致的。 第三部分 更快地移动及跳转动作命令是进行 Vim 操作的最重要的一些命令。我们不仅可以用它们四处移动光标，还能够用它们与操作符待决模式配合使用，指定一段文本范围并在其上进行操作。在本书的这一部分，我们将结识一些最为有用的动作命令，另外，我们还会学习 Vim 的跳转命令，这些命令让我们可以在文件间快速地跳转。 第 8 章 用动作命令在文档中移动我们不用把手从本位行上移开，就可以上下左右移动，操作符待决模式中最出彩的明星是文本对象如果你在一行中连续按了两次以上的 h 键，那就是在浪费时间（手动流汗）。 即 j、k、0和 $ 都用于操作实际行，而如果在这些 键前加上 g 前缀的话，就会让 Vim 对屏幕行进行操作 w 正向移动到下一单词的开头 (for-)wordb 反向移动到当前单词/上一单词的开头 back-worde 正向移动到当前单词/下一单词的结尾ge 反向移动到上一单词的结尾ea 命令连在一起可被解读为“在当前单词结尾后添加”gea 命令当成“在上一单词结尾后 添加”的命令 我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对 应，这当中包括 W、B、E和 gE一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白 字符分隔，字串的定义则更简单，它由非空白字符序列组成， 字串间以空白字符分隔 Vim 会记录 上次执行过的 f{char} 命令，随后用 ; 命令就可以重复该命令了，用 , 命令就可以再跳回来f{char} 正向移动到下一个 {char} 所在之处F{char} 反向移动到上一个 {char} 所在之处t{char} 正向移动到下一个 {char} 所在之处的前一个字符上T{char} 反向移动到上一个 {char} 所在之处的后一个字符上; 重复上次的字符查找命令, 反转方向查找上次的字符查找命令 f,dt.训练成手指的下意识动作（删除 , 和 . 之间的内容） 缺省的 键是 \ 查找命令不仅限于在普通模式下使用，我们也可以在可视模式及操作符待决模式 中使用它，用来完成实际的工作删除工作会更方便，先高亮然后通过命令行模式进行大范围选择。d/ge 用 /ge 查找动作告诉 d{motion} 命令删除什么。查找命令是 一个开动作，也就是说，虽然光标是在单词“gets”开头的“g”上的，但此字符却被 排除在删除操作之外，用 v 还需要 h 一下把 d{motion} 操作符与查找动作结 合在一起使用，这是个很大的进步，你可以好好在朋友和同事们面前炫耀一番了 可以把 i 想成“inside”，而把 a 想成 “around” 或“all”。 文本对象自身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以 在可视模式及操作符待决模式中使用文本对象 ：每当在命令语法里看到 {motion} 时，你也可以在这个地方使用文本对象，常见的例子包括 d{motion}、 c{motion}和 y{motion} 把 ci” 命令解读为“修改双引号内部的内容”，把 cit 命令解读为“修 改标签内部的内容”。另外，我们也可以很容易地用 yit 命令拷贝标签内的文本，或 者是用 dit 删除这些文本。 如果说 f{char} 和 /pattern 命令如同单足飞踹， 那么文本对象则像是一次攻击两个目标的剪刀腿 iw 和 aw 之间的区别很微妙，为什么会需要这样两个文本对象呢？ciw 命令只删除该单词，而不删除其前后的空白字符，随后它会进入插入模式， 这刚好是我们想要的效果。如果用的是 caw 的话，那最后两个单词就会连在一起一般来说，d{motion} 命令和 aw、as 和 ap 配合起来使用比较好，而 c{motion} 命令和 iw 及类似的文本对象一起用效果会更好。 m{a-zA-Z} 命令会用选定的字母标记当前光标所在位置,mm 和 `m 命令是一对便于使用的命令，它们分别设置位置标记 m，以及跳转到 该标记% 命令允许我们在一组开、闭括号间跳转,在执行 % 命令时，Vim 会 自动为发生跳转的地方设置一个位置标记, % 命令只能用在配对的括号上,所以利用替换命令时最好利用位置标记，防止陷阱。 第 9 章 在文件间跳转:jumps 查看跳转列表的内容，如果我们运行 :edit 命令 打开了一个新文件，那么就可以用 和 命令在这个新文 件以及原本的文件之间来回跳转，会始终在 当前活动窗口的跳转列表范围内进行跳转， Vim 本来就把 和 当成同一个东西。映射需谨慎。 Vim 会在编辑会话期间维护一张表，里面记载我们对每个缓冲区所做的修改， 此表就是所谓的改变列表 :changes，用 g; 和 g, 命令反向或正向遍历改变列表。改变列表中则保存了多组位置。我们可以多次按 g; 命令，每次它都会把 我们带到改变列表中较早的一个位置，而 `. 则总是把我们带到改变列表的最后一项。 执行 gf 命令“go to file”加上 .rb 扩展名，用 ‘suffixesadd’ 选项做到这一点 :set suffixesadd+=.rb查看 ‘path’ 选项的值:set path?《 path=.,/usr/include,,&lt;C-]&gt; 命令的作用也类似。它也需要进行一些配置（在技巧 102 中讨论），然而 一旦正确配置好，它就允许我们从函数调用的地方直接跳到该函数定义的地方 用两次按键就可以打开你的 vimrc 文件，先打开你的 vimrc 文件，按 mV 设置一个全局标记（助记词 V 代 表 vimrc），然后切换到另一个文件中按 `V 缺省情况下，:vimgrep 会直接跳到它所找到的第一处匹配上，这或许会切换到 另外一个文件。一般来说，要养成在使用与 quickfix 列表有关的命令前，如:grep、:vimgrep 及:make，设置全局标记的习惯。另外，在执行与缓冲区列表或参数列表有关的命令前， 如:args {arglist}和:argdo（参见技巧 37），也要设置全局标记。 你总共可以设置 26 个全局位置标记，可以迅速跳回。 第四部分 寄存器Vim 的寄存器是一组用于保存文件的简单容器。它们既可像剪贴板那样，剪切、复制和粘贴文本；也可以记录一系列按键操作，把它们录制成宏。通过本书的这一部分，我们将掌握这一核心功能。 第 10 章 复制与粘贴xp，可被用于“调换光标之后的两个字符”ddp，可被用于“调换当前行和它的下一行” diw 命令不仅删除了单词，而且还将它拷贝到了无名寄存器，按 P时得到的是刚刚删除的单词，而不是之前复制的单词，给命令加 “{register} 前缀的方式指定要用的寄存器，Vim 将缺省使用无 名寄存器。”ayiw复制，用 “bdd删除，”ap粘贴，可以解决无名寄存器的问题，使用复制寄存器也可以解决，黑洞集训器从删除方面也可以解决 Vim 的 delete 命令也与标准剪切操作的作用一致。也就是说，该命令会先把 指定文本复制到寄存器后再从文档中删掉，引用黑洞寄存器，”_d{motion}会执行真正的删除操作。 无名寄存器（””）， “”p，它完全等同于 p命令，x 和 d{motion} 经常被当作“删除”命 令。这其实是用词不当，把它们理解为“剪切”命令会更合适 复制专用寄存器（”0）使用 y{motion} 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，因为专用，只有 y 能触发 检查无名寄存器和复制专用寄存器的内容，:reg “0 ，小问题用复制专用寄存器，如果碰到需要将一段或多段文本粘贴到多处的情况，有名寄存器就会大显神通。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后 如果我们在外部程序中用剪切或复制命令获取了文本，就可以通过 “+p 命令（或 在插入模式下用 +）将其粘贴到 Vim 内部。相反地，如果在 Vim 的复制或删除 命令之前加入 “+ ，相应的文本将被捕获至系统剪贴板。“+ X11 剪贴板，用剪切、复制与粘贴命令操作 “ X11 主剪贴板，用鼠标中键操作把它们粘贴出来，Windows与Mac OS X操作系统并没有主剪贴板的概念，因此 “+ 寄存器与 “ 寄 存器可以混用，它们都代表系统剪贴板。 表达式寄存器（”=）当我们从表达式寄存器获取内容时，Vim 将跳到命 令行模式，并显示提示符“=”。这时，我们可以输入一段 Vim 脚本表达式并按 执行，如果返回的是字符串（或者可被强制转换成字符串的数据），Vim 将会使用它 只读寄存器 “% 当前文件名 “# 轮换文件名 “. 上次插入的文本 “: 上次执行的Ex命令 “/ 上次查找的模式 在可视模式下使用 p 命令时，Vim 将用我们指定的寄存器内容来替换高亮选区中的文本，可视再次解决了文本”丢失”现象，我们输入 u 撤销上次的修改。然后，按 gv重选上一次高亮选区的内容，再按一次 p键。发生了什么？显然什么也没发生，第一次使用 p时，之所以成功，是因为无名寄存器恰巧包含了我们想要的 文本。但在第二次使用 p时，无名寄存器包含的是被覆盖的内容，所以可是模式替换内容也会进入无名寄存器 在 Vim 的可视模式下使用 p命令时。首先，从无名寄存器里取出内容，然后，把高亮选区中的内容存入无名寄存器。（花里胡哨） c3w命令删除“chips and fish”并重新输入“fish and chips”， 应该会更快地完成任务。但是，以上方法可被用于交换更长的短语 p 命令旨在将寄存器中的文本粘贴到光标之后，P 命令用于将文本插入到光标之前，puP 和 Pup几乎成了下意识动作。当要粘贴的内容来自于面向行的寄存器时，p 和 P 命令会把它们粘贴至当前行的 上一行或下一行。这一点比面向字符的行为更直观 在插入模式下，我们可以通过输入 “ 来插入无名寄存器的内容，或者输入 0来插入复制专用寄存器的内容gp和 gP命令也值得关注，它们会把光标的位置移到被粘贴出来的文本结尾而不是开头。 当复制多行文本时，gP命令尤为管用，P 和 gP 命令区别 如果你运行的 Vim 是已集成系统剪贴板的版本，就可以完全避免与’paste’ 选项打交道了。普通模式下的 “+p 命令用来粘贴加号寄存器中的内容，即系统剪 贴板的镜像。 第 11章 宏]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux学习4]]></title>
    <url>%2F2019%2F01%2Fyuque%2Flinux_learning4%2F</url>
    <content type="text"><![CDATA[linux文件权限设置 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html chmod命令 概述chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 -rw-r–r– 1 root root 296K 11-13 06:03 log2012.log 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。 命令格式chmod [-cfvR] [–help] [–version] mode file 命令功能用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。 命令参数 必要参数1234-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数12345--reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限--version 显示版本信息&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围1234u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限代号123456r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限 该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 文字设定法 chmod ［who］ ［+ | - | =］ ［mode］ 文件名 数字设定法我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o） chmod ［mode］ 文件名 常用命令实例：增加文件所有用户组可执行权限命令：chmod a+x log2012.log说明：即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。实例：同时修改不同用户权限命令：chmod ug+w,o-x log2012.log实例：删除文件权限命令：chmod a-x log2012.log实例：使用“=”设置权限命令：chmod u=x log2012.log说明：撤销原来所有的权限，然后使拥有者具有可读权限实例：对一个目录及其子目录所有文件添加权限命令：chmod -R u+x test4说明：递归地给test4目录下所有文件和子目录的属主分配权限命令：chmod 751 filechmod u=rwx,g=rx,o=x file说明：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限命令:chmod =r filechmod 444 filechmod a-wx,a+r file说明：所有用户分配读权限 chgrp命令 概述在Linux系统里，文件或目录的权限掌控以拥有者及所诉群组来管理。可以使用chgrp指令去变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内才行。 命令格式chgrp [选项] [组] [文件] 命令功能chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。 命令参数 必要参数123456-c 当发生改变时输出调试信息-f 不显示错误信息-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细的处理信息--dereference 作用于符号链接的指向，而不是符号链接本身--no-dereference 作用于符号链接本身 选择参数123--reference=&lt;文件或者目录&gt;--help 显示帮助信息--version 显示版本信息 常用命令实例：改变文件的群组属性命令：chgrp -v bin log2012.log说明：将log2012.log文件由root群组改为bin群组123456[root@localhost test]# ll---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chgrp -v bin log2012.log“log2012.log” 的所属组已更改为 bin[root@localhost test]# ll---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log 实例：根据指定文件改变文件的群组属性命令：chgrp –reference=log2012.log log2013.log说明：改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同实例：改变指定目录以及其子目录下的所有文件的群组属性命令：chgrp -R bin test6说明：改变指定目录以及其子目录下的所有文件的群组属性实例4：通过群组识别码改变文件群组属性命令：chgrp -R 100 test6说明：通过群组识别码改变文件群组属性，100为users群组的识别码，具体群组和群组识别码可以去/etc/group文件中查看 chown命令 概述chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以使组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将问价拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 命令格式chown [选项]… [所有者][:[组]] 文件… 命令功能通过chown改变文件的拥有组和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者，其操作权限一般为管理员。 命令参数 必要参数123456-c 显示更改的部分的信息-f 忽略错误信息-h 修复符号链接-R 处理指定目录以及其子目录下的所有文件-v 显示详细的处理信息-deference 作用于符号链接的指向，而不是链接文件本身 选择参数1234--reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组--from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变--help 显示帮助信息--version 显示版本信息 常用命令实例：改变拥有者和群组命令：chown mail:mail log2012.log 实例：改变文件拥有者和群组命令：chown root: log2012.log 实例：改变文件群组命令：chown :mail log2012.log 实例：改变指定目录以及其子目录下的所有文件的拥有者和群组命令：chown -R -v root:mail test6 /etc/group文件详解 概述Linux /etc/group文件与/etc/passwd和/etc/shadow文件都是有关于系统管理员对用户和用户组管理时相关的文件。linux /etc/group文件是有关于系统管理员对用户和用户组管理的文件,linux用户组的所有信息都存放在/etc/group文件中。具有某种共同特征的用户集合起来就是用户组（Group）。用户组（Group）配置文件主要有 /etc/group和/etc/gshadow，其中/etc/gshadow是/etc/group的加密信息文件。将用户分组是LInux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 格式用户组的所有信息都存放在/etc/group文件中。此文件的格式是由冒号(:)隔开若干个字段，这些字段具体如下1组名:口令:组标识号:组内用户列表 组名：组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。口令：口令字段存放的是用户加密后的口令字。一般LInux系统的用户组都没有口令，即这个字段一般为空，或者是*。组标识号：组标识号与用户表示号类似，也是一个整数，被系统内部用来标识组，别称GID组内用户列表：是属于这个组的所有用户的列表，不同的用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 使用实例[root@localhost test6]# cat /etc/grouproot:x:0:root,linuxsirbin:x:1:root,bin,daemondaemon:x:2:root,bin,daemonsys:x:3:root,bin说明：我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux学习3]]></title>
    <url>%2F2019%2F01%2Flinux_learning3%2F</url>
    <content type="text"><![CDATA[文件查找命令 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html which命令概述我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：which查看可执行文件的位置whereis查看文件的位置locate配合数据库查看文件位置find实际搜寻硬盘查询文件名称which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 命令格式which 可执行文件名称 命令功能which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 命令参数1234-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名-p 与-n参数相同，但此处包含了文件的路径-w 指定输出时栏位的宽度-V 显示版本的信息 常用命令实例：用 which 去找出 which命令：which which which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！ whereis命令概述whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 命令格式whereis [-bmsu] [BMS 目录名 -f ] 文件名 命令功能whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 命令参数1234567-b 定位可执行文件。-m 定位帮助文件。-s 定位源代码文件。-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。-B 指定搜索可执行文件的路径。-M 指定搜索帮助文件的路径。-S 指定搜索源代码文件的路径。 常用命令实例：将和**文件相关的文件都查找出来命令：whereis man 实例：只将二进制文件 查找出来命令：whereis -b manwhereis -m man 查出说明文档路径，whereis -s man 找source源文件。 locate命令概述locate让使用者可以很快速搜索档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的distribution之中，数据库的建立都被放在crontab中自动执行。 命令格式locate [选择参数] [样式] 命令功能locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”” 或”?”等）来指定范本样式，如指定范本为kcpaner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库 命令参数123456789101112-e 将排除在寻找的范围之外。-1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会使速度减慢，因为 locate 必须至实际的档案系统中取得档案的权限资料。-f 将特定的档案系统排除在外，例如我们没有道理要把 proc 档案系统中的档案放在资料库中。-q 安静模式，不会显示任何错误讯息。-n 至多显示 n个输出。-r 使用正规运算式 做寻找的条件。-o 指定资料库存的名称。-d 指定资料库的路径-h 显示辅助讯息-V 显示程式的版本讯息 常用命令实例:查找和pwd相关的所有文件命令：locate pwd 实例： 搜索etc目录下所有以sh开头的文件命令：locate /etc/sh find命令概览概述Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 命令格式find pathname -options [-print -exec -ok …] 命令功能用于在文件树中查找文件，并做出相应的处理 命令参数1234pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&apos;command&apos; &#123; &#125; ;，注意&#123; &#125;和；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项12345678910111213141516171819202122232425262728-name 按照文件名查找文件-perm 按照文件权限来查找文件-prune 使用这一选项可以是find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略-user 按照文件所属主来查找文件。-group 按照文件所属的组来查找文件-mtime -n +n 按照文件的更改时间来查找文件，-n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项-nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。-type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。-mount：在查找文件时不跨越文件系统mount点。-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。另外,下面三个的区别:-amin n 查找系统中最后N分钟访问的文件-atime n 查找系统中最后n*24小时访问的文件-cmin n 查找系统中最后N分钟被改变文件状态的文件-ctime n 查找系统中最后n*24小时被改变文件状态的文件-mmin n 查找系统中最后N分钟被改变文件数据的文件-mtime n 查找系统中最后n*24小时被改变文件数据的文件 常用命令实例：查找指定时间内修改过的文件命令：find -atime -2说明：超找48小时内修改过的文件 实例：根据关键字查找命令：find . -name “*.log”说明：在当前目录查找 以.log结尾的文件。 “. “代表当前目录 实例：按照目录或文件的权限来查找文件命令：find /opt/soft/test/ -perm 777说明：查找/opt/soft/test/目录下 权限为 777的文件 实例：按类型查找命令：find . -type f -name “*.log”说明：查找当前目录，以.log结尾的普通文件 实例：查找当前所有目录并排序命令：find . -type d | sort 实例6：按大小查找文件命令：find . -size +1000c -print说明：查找当前目录大于1K的文件 find命令之exec概述find是我们很常用的一个Linux命令，但是我们一般查找出来的并不仅仅是看看而已，还会有进一步的操作，这个时候exec的作用就显现出来了。 exec解释-exec参数后面跟的是command命令，它的终止是以；为结束标志的，所以这句命令后面的分号是比不可少的，考虑到各个系统中分浩会有不同的意义，所以前面加反斜杠。{}花括号代表前面find查找出来的文件名使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用命令实例：ls -l命令放在find命令的-exec选项中命令：find . -type f -exec ls -l {} \;说明：上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。 实例：在目录中查找更改时间在n日以前的文件并删除它们命令：find . -type f -mtime +14 -exec rm {} \;说明：在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。 实例：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示命令：find . -name “*.log” -mtime +5 -ok rm {} \;说明：在上面的例子中， find命令在当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除。 实例：-exec中使用grep命令命令：find /etc -name “passwd“ -exec grep “root” {} \;说明：任何形式的命令都可以在-exec选项中使用。 在上面的例子中我们使用grep命令。find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 实例：查找文件移动到指定目录命令：find . -name “*.log” -exec mv {} .. \; 实例6：用exec选项执行cp命令命令：find . -name “*.log” -exec cp {} test3 \;说明: 当前目录中.log文件移动到该目录下的test3目录下 find命令之xargs概述在使用find命令的-exec选项处理匹配到的文件时，find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。find命令把匹配到的文件传递给xarg命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样，这样他可以最先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行，这样在有些情况就会出现进程过多，系统性能下降的问题，因而效率不高，而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数买还是分批取得所有参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 常用命令实例：查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件命令：find . -type f -print | xargs file 实例：在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中命令：find / -name “core” -print | xargs echo “” &gt;/tmp/core.log 实例:在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限命令：find . -perm -7 -print | xargs chmod o-w说明：执行命令后，相应的权限都发生改变 实例：用grep命令在所有的普通文件中搜索hostname这个词命令：find . -type f -print | xargs grep “hostname” 实例：用grep命令在当前目录下的所有普通文件中搜索hostnames这个词命令：find . -name * -type f -print | xargs grep “hostnames”说明：注意，在上面的例子中， \用来取消find命令中的*在shell中的特殊含义 实例：使用xargs执行mv命令：find . -name “*.log” | xargs -i mv {} test4 实例：find后执行xargs提示xargs: argument line too long解决方法命令：find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f说明：-l1是一次处理一个；-t是处理之前打印出命令 实例：使用-i参数默认的前面输出用{}代替，-I参数可以指定其他代替字符，如例子中的[]命令： find . -name “file” | xargs -I [] cp [] ..说明：使用-i参数默认的前面输出用{}代替，-I参数可以指定其他代替字符，如例子中的[] 实例9：xargs的-p参数的使用命令：find . -name “*.log” | xargs -p -i mv {} ..说明：-p参数会提示让你确认是否执行后面的命令,y执行，n不执行。 find命令的参数详解概述find一些常用参数的常用实例和一些具体方法和注意事项 使用name选项文件名选项是find命令最常用的选项，要么蛋酥使用该选项，要么和其他选项一起使用。可以使用某种文件名模式来匹配文件，记住要用引用将文件名模式引用起来。 不管当前路径是什么，如果想要在自己的根目录$HOME中查找文件名符合.log的文件，使用作为’pathname’参数，波浪号~代表了你的$HOME目录。find ~ -name “.log” -print 想要在当前目录及子目录中查找所有的‘ .log‘文件，可以用：find . -name “.log” -print 想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：find . -name “[A-Z]*” -print 想要在/etc目录中查找文件名以host开头的文件，可以用：find /etc -name “host*” -print 想要查找$HOME目录中的文件，可以用：find ~ -name “*” -print 或find . -print 要想让系统高负荷运行，就从根目录开始查找所有的文件。（手动狗头）find / -name “*” -print 如果想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件：命令：find . -name “[a-z]*[4-9].log” -print 使用perm选项按照文件权限模式用-perm选项，按文件权限模式来查看文件的话。最好使用八进制的权限表示法。 如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：find . -perm 755 -print 还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-005相当于555命令：find . -perm -005 使用-prune选项如果在查找文件希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你使用了-depth选项，那么-prune选项就会被find命令忽略。 如果希望在test目录下查找文件，但不希望在test/test3目录下查找命令：find test -path “test/test3” -prune -o -print 实例：在test 目录下查找不在test4子目录之内的所有文件命令：find test -path “test/test4” -prune -o -print说明：find [-path ..] [expression] 在路径列表的后面的是表达式-path “test” 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 -path “test” -a -prune 为假，则求值 -print ，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。 实例：避开多个文件夹:命令：find test ( -path test/test4 -o -path test/test3 ) -prune -o -print说明：圆括号表示表达式的结合。 \ 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。 实例：查找某一确定文件，-name等选项加在-o 之后命令：find test (-path test/test4 -o -path test/test3 ) -prune -o -name “*.log” -print 使用user和nouser选项按文件属主查找文件：实例1：在$HOME目录中查找文件属主为peida的文件命令：find ~ -user peida -print 实例2：在/etc目录下查找文件属主为peida的文件:命令：find /etc -user peida -print说明： 实例3：为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/home目录下查找所有的这类文件命令：find /home -nouser -print说明：这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。 使用group和nogroup选项就像user和nouser选项一样，针对文件所属于的用户组，find命令也具有同样的选项，为了在/apps目录下查找属于gem用户组的文件，可以用：find /apps -group gem -print 要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件：find / -nogroup-print 按照更改时间或访问时间等查找文件如果希望按照更改时间来查找文件，可以使用mtime，atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件，用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 希望在系统根目录下查找更改时间在5日以内的文件，可以用：find / -mtime -5 -print 为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:find /var/adm -mtime +3 -print 查找比某个文件新或旧的文件如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 它的一般形式为： newest_file_name ! oldest_file_name其中，！是逻辑非符号。 实例：查找更改时间比文件log2012.log新但比文件log2017.log旧的文件命令：find -newer log2012.log ! -newer log2017.log 实例：查找更改时间在比log2012.log文件新的文件命令：find . -newer log2012.log -print 使用type选项实例：在/etc目录下查找所有的目录命令：find /etc -type d -print 实例：在当前目录下查找除目录以外的所有类型的文件命令：find . ! -type d -print 实例：在/etc目录下查找所有的符号链接文件命令：find /etc -type l -print 使用size选项可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。 实例：在当前目录下查找文件长度大于1 M字节的文件命令：find . -size +1000000c -print 实例：在/home/apache目录下查找文件长度恰好为100字节的文件:命令：find /home/apache -size 100c -print 实例：在当前目录下查找长度超过10块的文件（一块等于512字节）命令：find . -size +10 -print 使用depth选项在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件 实例：find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。命令：find / -name “CON.FILE” -depth -print说明：它将首先匹配所有的文件然后再进入子目录中查找 使用mount选项在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。 实例:从当前目录开始查找位于本文件系统中文件名以XC结尾的文件命令：find . -name “*.XC” -mount -print 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习2]]></title>
    <url>%2F2018%2F12%2Flinux-learning2%2F</url>
    <content type="text"><![CDATA[文件目录操作命令(9-15） 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html touch命令概述linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。 命令格式touch [选项]… 文件… 命令参数1234567-a 或--time=atime或--time=access或--time=use 只更改存取时间。-c 或--no-create 不建立任何文档。-d 使用指定的日期时间，而非现在的时间。-f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。-m 或--time=mtime或--time=modify 只更改变动时间。-r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。-t 使用指定的日期时间，而非现在的时间。 命令功能touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 常用命令实例：更新log.log的时间和log2012.log时间戳相同命令：touch -r log.log log2012.log 实例：设定文件的时间戳命令：touch -t 201211142234.50 log.log 说明-t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] 这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch 将把年数CCYY限定在1969–2068之内．MM为月数，DD为天将把年数CCYY限定在1969–2068之内．MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数．此处秒的设定范围是0–61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时 间．由于系统的限制，早于1970年1月1日的时间是错误的。 cat命令概述cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 命令格式cat [选项] [文件]… 命令功能cat主要有三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file 命令参数12345678910-A, --show-all 等价于 -vET-b, --number-nonblank 对非空输出行编号-e 等价于 -vE-E, --show-ends 在每行结束处显示 $-n, --number 对输出的所有行编号,由1开始对所有输出的行数编号-s, --squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价-T, --show-tabs 将跳格字符显示为 ^I-u (被忽略)-v, --show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 常用命令实例：把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里。命令：cat -b log2012.log log2013.log log.log 实例：使用here doc来生成文件输出： [root@localhost test]# cat &gt;log.txt &lt;&lt;EOF &gt; Hello &gt; World &gt; Linux &gt; PWD=$(pwd) &gt; EOF [root@localhost test]# ls -l log.txt -rw-r--r-- 1 root root 37 10-28 17:07 log.txt [root@localhost test]# cat log.txt Hello World Linux PWD=/opt/soft/test [root@localhost test]# 实例：tac (反向列示)命令：tac log.txt 说明：tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！ nl命令概述nl 命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 命令格式nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 命令参数123456789-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种：-n ln ：行号在萤幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数。-p 在逻辑定界符处不重新开始计算。 命令功能nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 常用命令实例：用 nl 列出 log2012.log 的内容命令：nl log2012.log 实例：用 nl 列出 log2012.log 的内容，空本行也加上行号命令：nl -b a log2012.log 实例3：让行号前面自动补上0,统一输出格式命令： nl -b a -n rz -w 3 log2014.log说明：nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w 3 调整为3位。 more命令概述more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 命令格式more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ] 命令功能more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。 命令参数123456789+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉 常用操作命令Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 常用命令实例：从文件中查找第一个出现”day3”字符串的行，并从该处前两行开始显示输出命令：more +/day3 log2012.log 实例4：列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来命令：ls -l | more -5说明：每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息。 less命令概述less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在more的时候，我们并没有办法向前面翻，只能往后面看，但若使用了less时，就可以使用[pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容，除此之外，在less可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 命令格式less [参数] 文件 命令功能less与more类似，但使用less可以随意浏览文件。而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件。 命令参数1234567891011121314151617181920212223242526-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 常用命令实例：查看文件命令：less linux_learning.md 实例：浏览多个文件命令：less linux_learning.md java_entry_learning.md说明：输入 ：n后，切换到 log2014.log输入 ：p 后，切换到log2013.log 实例：查看命令历史使用记录并通过less分页显示命令：history | less 实例2：ps查看进程信息并通过less分页显示命令：ps -ef |lessLinux进程的基本概念 附加备注全屏导航ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 单行导航j - 向前移动一行k - 向后移动一行 其它导航123G - 移动到最后一行g - 移动到第一行q / ZZ - 退出 less 命令 其它有用的命令123v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件 标记导航当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：ma - 使用 a 标记文本的当前位置‘a - 导航到标记 a 处 head命令概述head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然就是看档案的结尾。 命令格式head [参数]… [文件]… 命令功能head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 命令参数1234-q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数 常用命令实例：显示文件的前n行命令：head -n 5 log2014.log 实例：文件的除了最后n个字节以外的内容命令：head -c -32 log2014.log 实例：输出文件除了最后n行的全部内容命令：head -n -6 log2014.log tail命令概述tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 命令格式tail[必要参数][选择参数][文件] 命令功能用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 命令参数12345678-f 循环读取-q 不显示处理信息-v 显示详细的处理信息-c&lt;数目&gt; 显示的字节数-n&lt;行数&gt; 显示行数--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. -q, --quiet, --silent 从不输出给出文件名的首部 -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 常用命令实例：循环查看文件内容命令：tail -f test.log [root@localhost ~]# ping 192.168.120.204 &gt; test.log &amp; [1] 11891[root@localhost ~]# tail -f test.log PING 192.168.120.204 (192.168.120.204) 56(84) bytes of data. 64 bytes from 192.168.120.204: icmp_seq=1 ttl=64 time=0.038 ms 64 bytes from 192.168.120.204: icmp_seq=2 ttl=64 time=0.036 ms 64 bytes from 192.168.120.204: icmp_seq=3 ttl=64 time=0.033 ms 64 bytes from 192.168.120.204: icmp_seq=4 ttl=64 time=0.027 ms 64 bytes from 192.168.120.204: icmp_seq=5 ttl=64 time=0.032 ms 64 bytes from 192.168.120.204: icmp_seq=6 ttl=64 time=0.026 ms 64 bytes from 192.168.120.204: icmp_seq=7 ttl=64 time=0.030 ms 64 bytes from 192.168.120.204: icmp_seq=8 ttl=64 time=0.029 ms 64 bytes from 192.168.120.204: icmp_seq=9 ttl=64 time=0.044 ms 64 bytes from 192.168.120.204: icmp_seq=10 ttl=64 time=0.033 ms 64 bytes from 192.168.120.204: icmp_seq=11 ttl=64 time=0.027 ms [root@localhost ~]# 说明：ping 192.168.120.204 &gt; test.log &amp; //在后台ping远程主机。并输出文件到test.log；这种做法也使用于一个以上的档案监视。用Ctrl＋c来终止。 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习1]]></title>
    <url>%2F2018%2F12%2Flinux_learning1%2F</url>
    <content type="text"><![CDATA[文档目录操作命令(1-8) 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html ls命令概述ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单。如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多! 命令格式：ls [选项] [目录名 命令功能：列出目标目录中所有的子目录和文件。 命令参数：12345678910111213141516171819202122232425262728293031323334353637383940414243-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。-c 配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序-C 每栏由上至下列出项目–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一-d, –directory 将目录象文件一样显示，而不是显示其下的文件。-D, –dired 产生适合 Emacs 的 dired 模式使用的结果-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效-g 类似 -l,但不列出所有者-G, –no-group 不列出任何有关组的信息-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)–si 类似 -h,但文件大小取 1000 的次方而不是 1024-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)-i, –inode 印出每个文件的 inode 号-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息-m 所有项目以逗号分隔，并填满整行行宽-o 类似 -l,显示文件的除组信息外的详细信息。-r, –reverse 依相反次序排列-R, –recursive 同时列出所有子目录层-s, –size 以块大小为单位列出所有文件的大小-S 根据文件大小排序–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：extension -X status -cnone -U time -tsize -S atime -utime -t access -uversion -v use -u-t 以文件修改时间排序-u 配合 -lt:显示访问时间而且依访问时间排序配合 -l:显示访问时间但根据名称排序否则：根据访问时间排序-U 不进行排序;依文件系统原有的次序列出项目-v 根据版本进行排序-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值-x 逐行列出项目而不是逐栏列出-X 根据扩展名排序-1 每行只列出一个文件–help 显示此帮助信息并离开–version 显示版本信息并离开 常用命令实例：列出目录下的所有文件的权限等信息命令：ls -al 实例：列出/home/peidachang文件夹下的所有文件和目录的详细资料命令：ls -l -R /home/peidachang 实例：列出目前工作目录下所有档案及目录;目录于名称后加”/”, 可执行档于名称后加”*”命令：ls -AF 实例：计算当前目录下的文件数和目录数命令：ls -l |grep “^-“|wc -l —文件个数ls -l |grep “^d”|wc -l —目录个数 实例: 在ls中列出文件的绝对路径命令：ls | sed “s:^:pwd/:” 显示彩色目录列表Ubuntu1804具备此功能，如果不满足，可以在/etc/bashrc, 加入一行: alias ls=”ls –color” 1. 蓝色–&gt;目录 2. 绿色–&gt;可执行文件 3. 红色–&gt;压缩文件 4. 浅蓝色–&gt;链接文件 5. 灰色–&gt;其他文件 cd命令概述Linux cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。 命令格式cd [目录名] 命令功能切换当前目录至dirName 常用命令123456cd / 进入系统根目录cd .. 退至上一个目录cd or cd ~ 进入当前用户主目录cd – 返回进入此目录之前所在的目录cd !$ 把上个命令的参数作为cd参数使用注意：跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可 pwd命令概述Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。 命令格式pwd [选项] 命令功能查看”当前工作目录“的完整路径 命令参数123一般情况下不带任何参数如果目录是链接时：格式：pwd -P 显示出实际路径，而非使用连接（link）路径。 理解 Linux 的硬链接与软链接 常用命令实例：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令：find $PWD -maxdepth 1 | xargs ls -ld mkdir命令概述linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 命令格式mkdir [选项] 目录… 命令功能通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写) 命令参数12345-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask-p, --parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;-v, --verbose 每次创建新目录都显示信息--help 显示此帮助信息并退出--version 输出版本信息并退出 常用命令实例：创建权限为777的目录命令： mkdir -m 777 test3 rm命令rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。 命令格式 rm [选项] 文件… 命令功能删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 命令参数123456-f, --force 忽略不存在的文件，从不给出提示。-i, --interactive 进行交互式删除 -r, -R, --recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。 -v, --verbose 详细显示进行的步骤--help 显示此帮助信息并退出 --version 输出版本信息并退出 参考 常用命令实例：删除任何.log文件；删除前逐一询问确认命令：rm -i *.log 实例：将 test1子目录及子目录中所有档案删除命令：rm -r test1 or rm -rf test1 rmdir命令概述rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm – r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。 命令格式rmdir [选项]… 目录… 命令功能该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。 命令参数123- p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。-v, --verbose 显示指令执行过程 常用命令实例：rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除命令：rmdir -p logs/product mv命令概述mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。 命令格式mv [选项] 源文件或目录 目标文件或目录 命令功能视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。 命令参数12345-b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 常用命令实例：移动当前文件夹下的所有文件到上一级目录命令：mv * ../ 实例：把当前目录的一个子目录里的文件移动到另一个子目录里命令：mv test3/*.txt test5 实例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉。命令： mv -f log3.txt log2.txt cp命令概述cp命令既是copy用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同 命令格式 cp [选项]… [-T] 源 目的或：cp [选项]… 源… 目录或：cp [选项]… -t 目录 源… 命令功能将源文件复制至目标文件，或将多个源文件复制至目标目录。 命令参数123456789101112131415-a, –archive 等于-dR –preserve=all–backup[=CONTROL 为每个已存在的目标文件创建备份-b 类似–backup 但不接受参数–copy-contents 在递归处理是复制特殊文件内容-d 等于–no-dereference –preserve=links-f, –force 如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项)-i, –interactive 覆盖前询问(使前面的 -n 选项失效)-H 跟随源文件中的命令行符号链接-l, –link 链接文件而不复制-L, –dereference 总是跟随符号链接-n, –no-clobber 不要覆盖已存在的文件(使前面的 -i 选项失效)-P, –no-dereference 不跟随源文件中的符号链接-p 等于–preserve=模式,所有权,时间戳–preserve[=属性列表 保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：环境、链接、xattr 等-R, -r, –recursive 复制目录及目录内的所有项目 常用命令实例：复制的文件建立一个连结档命令：cp -s db.json db_link.json 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型及BFC]]></title>
    <url>%2F2018%2F12%2FCSS-Box-BFC%2F</url>
    <content type="text"><![CDATA[前言确实是因为菜，感觉自己没什么东西可以写，最近被迫学习一些前端的东西，为了防止日后遗忘，方便有用之时再次学习并加深印象，就记录一些比较基础的东西。 基础知识内容（CONTENT）就是盒子里装的东西；填充(PADDING)就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框(BORDER)就是盒子本身了；边界(MARGIN)则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出。在网页设计上，内容常指文字、图片等元素，但是也可以是小盒子（DIV嵌套），与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子，否则盒子会被撑坏的，而CSS盒子具有弹性，里面的东西大过盒子本身最多把它撑大，但它不会损坏的。填充只有宽度属性，每个HTML标记都可看作一个盒子；更多基础知识参考：w3school：http://www.w3school.com.cn/ 两种模式盒模型的组成:由里向外：content、padding、border、margin 在标准模型（默认）中，盒模型的宽高只是内容（content）的宽高 而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高 模式使用：12 box-sizing: content-box 是W3C盒子模型 box-sizing: border-box 是IE盒子模型 BFC(Block Formatting Context)前端的页面设计，实现一些常见的布局必须要掌握BFC的规律 概念BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 形成BFC的条件（满足四条之一即可）1、浮动元素，float 除 none 以外的值； 2、定位元素，position（absolute，fixed）； 3、display 为以下其中之一的值 inline-block，table-cell，table-caption； 4、overflow 除了 visible 以外的值（hidden，auto，scroll）； BFC的特性1.内部的Box会在垂直方向上一个接一个的放置。 2.垂直方向上的距离由margin决定 3.bfc的区域不会与float的元素区域重叠。 4.计算bfc的高度时，浮动元素也参与计算 5.bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 功能实现1.内部的Box会在垂直方向上一个接一个的放置。 2.垂直方向上的距离由两个盒子的margin相加或重叠决定 3.随浏览器自适应，防止出现这一行跑到下一行的状况 4.防止字体环绕图片 5.防止浮动元素脱离常规流 https://www.cnblogs.com/chen-cong/p/7862832.html 日常搬运 In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 在BFC中，每个盒子的左外边框紧挨着左边框的包含块（从右到左的格式化时，则为右边框紧挨）。即使在浮动里也是这样的（尽管一个盒子的边框会因为浮动而萎缩），除非这个盒子的内部创建了一个新的BFC（这种情况下,由于浮动，盒子本身将会变得更窄） W3C 原文 © w3cplus.com前因后果、细节重点讲解较为仔细 掘金这篇文章进行了更多的拓展，算是加强巩固一下]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记]]></title>
    <url>%2F2018%2F11%2FNotes_of_Struts2%2F</url>
    <content type="text"><![CDATA[struts2概述struts2框架应用javaee三层结构中web层框架struts2框架在struts1和webwork基础之上发展全新框架用servlet和struts框架的基本比较web层框架：1.struts 2.spring struts2入门案例1.每次访问servlet时候，都会执行service方法 写类继承HttpServlet，重写类里面的方法 在web.xml中配置servlet访问路径2.每次访问action时候，默认执行execute方法 配置action访问路径 第一步 导入jar包1.在lib中jar包，不能把这些jar都导入到项目中2.到apps目录里面，找到实例程序，从示例程序中复制相关的jar包 第二步 创建action 第三步 配置action类访问路径1.创建struts2核心配置文件 核心配置文件吗名称和位置是固定的 位置必须在src下面，名称struts.xml2.引入dtd约束3.action配置 第四步 配置struts2过滤器根据配置显示的是相应的hello.jsp文件 基本执行过程过滤器在服务器启动时候创建，创建过滤器时候执行init方法，在init方法中主要加载配置文件，包含自己创建的和struts2自带的配置文件struts.xml和web.xml 常见多变的方法动态方法的调用动态方法调用就是为了解决一个Action对应多个请求的处理，以免Action太多通常有三种方式： 指定method属性感叹号方式（不推荐）通配符方式 接收参数 使用Action的属性接收参数使用DomainModel接收参数使用ModelDriven接收参数 处理结果类型 局部结果将作为元素的子元素配置全局结果将作为元素的子元素配置 Action三种创建方式 创建普通类，不继承任何类，不实现任何接口创建类，实现接口Action创建类，继承类ActionSupport(一般使用这种方式) 获取表单数据使用ActionContext(推荐) 使用ServletActionContext类使用接口注入方式ServletAPI解藕方式 为了避免与Servlet API耦合在一起，方便Action类做单元测试，Struts2对HttpServletRequest、 HttpSession和ServletContext进行了封装，构造了三个Map对象来替代这三种对象。可以通过com.opensymphony.xwork2.ActionContext类来得到这三个对象。ActionContext是 Action执行的上下文，保存了很多对象如parameters、request、session、application和locale等。 获取request、session等方法创建方式 1Map&lt;String,Object&gt; attributes = ActionContext.getContext().getSession(); 或者 12ActionContext context = ActionContext.getContext();Map&lt;String, Object&gt; session = context.getSession(); 1session.put(&quot;str2&quot;, str1); 意思是将str1这个变量的内容赋给str2这个变量在jsp中有两种输出方式（大致上没有区别，除非对应直接输入，会有一定的差别） 12 $&#123;requestScope.str2&#125; &lt;%= ActionContext.getContext().get(&quot;str2&quot;) %&gt; 参考网址：https://www.yiibai.com/struts_2/https://www.w3cschool.cn/struts_2/]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet学习ing]]></title>
    <url>%2F2018%2F11%2Fservlet%2F</url>
    <content type="text"><![CDATA[http协议：超文本传输协议概念和作用特点作用：规范浏览器（客户端）与服务器之间的数据交互 特点：简单、快捷、灵活、无连接（http1.1后支持可持续连接）、无状态（没有记忆，数据量大，新应答快速） 交互流程、请求格式、请求方式交互流程：客户端和服务器建立连接客户端法发送请求到服务器端服务器端接收到请求后进行处理，然后将处理结果相应客户端关闭客户端和服务器端的连接（HTTP1.1后不会立即关闭）请求格式：结构：请求头、请求行、空行、请求数据​​请求方式（结构大致一样，方式可能不同）：HTTP1.0：GET（？后有请求数据，不安全）、POST、HEAD方法HTTP1.1：OPTIONS、PUT、DELETE、TRACE、CONNECT方法​ 响应格式的结构和常见的状态码响应行（状态行）：HTTP版本、状态码、状态消息响应头：消息报头、客户端使用的附加信息空行：响应头和响应实体之间必须的响应实体：正文，服务器返回浏览器的信息​​常见的状态码（告诉浏览器）：​​ 服务器（主流是Tomcat）：本质：实际上就是java网络编程用代码编写的一个容器Tomcat目录结构：​​因为含有class文件，所以一定要依靠jdk，java虚拟环境 Servlet技术：概念和介绍 程序员在编写代码的时候如果能够按照服务器能够识别的规则进行编写，浏览器按照指定的规则进行发送请求（服务器识别就类似于JVM找main（）方法似的，有指定的规则），那么服务器就可以调用并执行响应的逻辑代码进行请求处理了。 ​​ 本质上就是服务器能够识别的接口规范1.创建普通的java类并继承HttpServlet方法2.覆写service方法3.在service方法中书写逻辑代码就行4.在webRoot下的WEB-INF文件夹下的web.xml文件中配置servlet（确保能找到）现在很多IDE环境不需要将class文件移交到相应的Tomcat下 运行（访问）流程：URL: http://localhost:8080/01.MyServlet/my2组成：服务器地址：端口号/服务器下webapps下的文件夹的名称（虚拟项目名）/（servlet的别名）要执行的servlet的url-pattern（因为防止包名类名被黑客利用，需有一定的隐藏，所以采用url-pattern的规则） URI：虚拟项目名/ servlet的别名123456789&lt;servlet&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjsxt.servlet.MyServlet2&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;url-pattern&gt;/my2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 相当于起一个别名，通过web.xml下找到my2，再找到包类名，找不到则404（my2相当于暗号）服务器会加载一下本地的文件，删除文件并关闭服务器再打开会提示报错信息 Servlet生命周期：1.第一次调用到服务器关闭2.如果servlet在web.xml中配置了load-on-startup之间的数字表示顺序，生命周期为从服务器启动到服务器关闭3.注意：Init方法是对servlet进行初始化的一个方法，会在servlet第一次加载进行存储时进行Destroy方法是在servlet销毁时执行 Jsp中的表单数据：​​ Service和doGet和doPost方法的区别： Service方法:可以处理get、post方式的请求，如果servlet中包含service方法，优先调用service方法对请求进行处理 doGet方法:处理get方式的请求 doPost方法:处理post方式的请求注意：如果在覆写的service方法中调用了父类的service方法（super.service（arg0,arg1））,则service方法处理后，会再次根据请求方式响应的doGet和doPost方法执行。一般情况下，不在service中调用父类的service方法，避免出现405错误 Servlet常见错误：404错误：资源未找到在请求地址中的servlet的别名书写错误虚拟项目名称拼写错误500错误：不可预估的错误在web.xml中校验servlet类的全限定路径是否拼写错误。service方法体的代码执行错误所致，根据错误提示对service方法体中的代码进行更改405错误：请求方式不支持请求方式和servlet中的方法不匹配所导致的，尽量使用service方法进行请求处理，并且不要在service方法中调用父类的service。 Request对象：介绍和获取请求头信息 服务器接收到浏览器的请求后，会创建一个request对象，对象中存储了此次请求相关的请求数据。服务器在调用servlet时会将创建好的request对象作为实参传递给servlet的方法，比如service方法。 使用：获取请求头数据、请求行数据、用户数据作用：request对象中封存了当前请求的多有请求信息注意：request对象由Tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法 Service中的形参以req为例子 获取请求头数据：获取请求方式12String method = req.getMethod();Sout(method); 获取请求URL12StringBuffer url = req.getRequestURL()l;Sout(url); 获取URI12String uri = req.getRequestURI();Sout(uri); 获取协议12String h = req.getScheme();Sout(h); 获取请求行数据;获取指定的请求行信息1String value = req.getHeader(“User-Agent”);//根据F12浏览器端找到的键值，加入想要获取666但是你没有，那么你在控制台后收到null 获取所有的请求行的键的枚举12Enumeration e = req.getHeaderNames();while(e.hasMoreElements())&#123; 获取所有键值1sout(e.nextElement()); 获取所有信息123String name = (String)e. nextElement();String value2= req.getHeader(name);Sout(name+”:”+value2); 获取用户数据：req.getParameter(“键名”);(返回指定的用户数据，不能获得同键不同值的多项选择数据，会漏值)​​ 避免漏值​​12req.getParameterValue(“键名”);(返回同键不同值的请求数据（多选），返回数组)req.getParameterNames(“键名”);(返回所有请求数据的枚举集合) 注意：如过要获取的请求数据不存在，不会报错，返回null。 request对象学习问题：在使用request对象获取请求数据并进行处理后，处理的结果如何显示到浏览器中？总结：Service请求处理代码流程：设置响应编码格式、获取请求数据、处理请求数据、数据库操作（MVC思想）、响应处理结果响应实体里面可以设置具体的html代码（无JSP的麻烦之处）乱码问题：记得服务器到浏览器，浏览器到服务器两个半流程中的编码规范问题servlet流程总结： Request作用域问题：使用请求转发后，不同的servlet之间怎么进行数据共享呢？或者说数据怎么从一个servlet流转给另外一个servlet呢？解决：使用request对象的作用域 请求转发：问题：服务器在接收到浏览器的请求后，仅仅使用一个servlet进行请求处理，会造成不同的servlet逻辑代码冗余，servlet的职责不明确解决：使用请求转发特点：一次请求、地址栏信息不改变 重定向学习问题：如果当前的请求servlet无法处理怎么办？如果使用请求转发，造成表单数据重复提交怎么办？解决：使用重定向 Cookie学习Cookie介绍、使用、设置有效期、信息获取 Cookie三天免登录 session学习session介绍及原理问题：request对象解决了一次请求内的不同servlet的数据共享问题，那么一个用户的不同请求的处理需要使用相同的数据怎么办呢？解决：使用session技术原理：用户使用浏览器第一次向服务器发送请求，服务器在接收到请求后，调用响应的servlet进行处理。在处理过程中会给用户创建一个session对象，用来存储用户请求处理相关的公共数据，并将此session对象的JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效）。用户在发起第二次请求及后续请求能够获取同一个session对象，也保证了不同请求能够获取到共享的数据。 session特点及使用特点：存储在服务器端、服务器进行创建、依赖cookie技术、一次会话作用：解决了一个用户不同请求的数据共享问题使用： 创建session对象/获取session对象 设置session存储时间（一般为30分钟） 设置session强制失效hs.invalidate(); 注意JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效） session数据流转和总结存储和获取数据使用时机：一般用户在登录web项目时会将用户的个人信息存储到session中，供该用户的其他请求使用总结：session解决了有个用户的不同请求的数据共享问题，只要在JSESSIONID不失效和session对象不失效的情况下，用户的任意请求在处理时都能获取到同一个session对象。作用域：一次会话（在JSESSIONID不失效和session对象不失效的情况下为整个项目内）session失效处理：将用户请求中的JSESSIONID和后台获取到的session对象JSESSIONID进行对比，如果一致则session没有失效，否则证明session失效了。重定向到登录界面，让用户重新登录。 解决主页面用户名显示为null的问题原因：因为在用户登录成功后使用重定向显示主页面，两次请求，而用户的信息在第一次请求中，第二次请求中没有用户数据，所以显示为null解决：使用session ServletContext对象学习问题：request解决了一次请求内的数据共享问题，session解决了用户不同请求的数据共享问题，那么不同的用户的数据共享该怎么办呢？解决：使用ServletContext对象作用：解决了不同用户的数据共享问题原理：ServletContext对象由服务器进行创建，一个项目只有一个对象。不管在项目的任意位置进行获取得到的都是同一个对象，那么不同用户发起请求获取到的也就是同一个对象了，该对象由用户共同拥有特点：服务器创建、用户共享、一个项目只有一个生命周期：服务器启动到关闭作用域：项目内使用：获取ServletContext对象/使用ServletContext对象完成数据共享获取项目中web.xml文件中的全局配置数据获取项目webroot下的资源的绝对路径/流对象使用ServletContext对象完成网页计数器在用户登录校验中创建计数器并自增，然后存储到ServletContext对象中，在主页面中取出计数器数据并显示给用户即可 ServletConfig对象问题：使用ServletConfig对象可以获取web.xml中的全局配置文件，在web.xml中每个servlet也可以进行单独的配置，那么该怎么获取配置信息呢？解决：使用ServletConfig对象作用：ServletConfig对象是servlet的专属配置对象，每个servlet都单独拥有一个ServletConfig对象用来获取web.xml中的配置信息使用： web.xml文件作用：存储项目相关的配置信息，保护servlet。解耦一些数据对程序的依赖使用位置：每个web项目中、tomcat服务器中（在服务器目录conf目录中）区别：web项目下的web.xml文件为局部配置，针对本项目的位置tomcat下的web.xml文件为全局配置，配置公共信息内容（核心组件）：全局上下文配置（全局配置参数）、servlet配置、过滤器配置、监听器配置加载顺序：web容器会按照ServletContext-&gt;context-param-&gt;listener-&gt;filter-&gt;servlet这个顺序加载组件，这些元素可配置在web.xml中的任意位置加载时机：服务器启动时 server.xml文件问题：浏览器发起请求后服务器根据请求在webapps目录下调用对应的servlet进行请求处理。那么为什么是webapps目录而不是其他的目录呢？解决：了解server.xml文件的配置信息server.xml文件核心组件：热部署：1&lt;Context path=&quot;/Pet&quot; reloadable=&quot;false&quot; docBase=&quot;F:/PetWeb&quot; /&gt; 参考链接：B站菜鸟教程]]></content>
      <categories>
        <category>Java</category>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群聊初步学习实现过程]]></title>
    <url>%2F2018%2F10%2FThinking-of-Chat%2F</url>
    <content type="text"><![CDATA[看学习视频所得 Chat0.1:客户端：先写一个简易的窗口，采用extends Frame Chat0.2:客户端：给窗口添加TextArea在BorderLayout北面，添加TextField在BorderLayout南面，注意pack()、add(); Chat0.3:客户端：匿名类改写windowClosing()使其System.exit(0)（可以关闭） Chat0.4:客户端：使用内部类给框架添加监听事件，改写actionPerformed(ActionEvent e)使Field内容显示到Area中，清空Field Chat0.5:客户端：不变服务器端：建立ServerSocket serverSocket = new ServerSocket(8088);当有连接时Socket s = serverSocket.accept(); Chat0.6:客户端：设置connect函数建立 socket = new Socket(“127.0.0.1”, 8088);连接，connect()置于launchFrame()框架建立同时连接上端口号服务器端：不变 Chat0.7:客户端：利用DataOutputStream dos = new DataOutputStream(s.getOutputStream()); dos.writeUTF(str);将输入内容写入流中，内容储存在流中方便通信。服务器端：利用 DataInputStream dis = new DataInputStream(s.getInputStream()); Stringstr; dis.readUTF(); System.out.println(str);将内容接收过来并在控制台打印出来 Chat0.8:客户端：将DataOutputStream设为全局变量,设置disconnect函数,当关闭窗口时应断开连接服务器端：不变 Chat0.9:客户端：不变服务器端：增加容错性，添加BindException、EOFException、以及finally判断来关闭Socket和DataInputStream，出现EOFException表示前面有客户端占用端口，所以应当写出提示语句最后在finally中关闭之前的占用 Chat1.0:客户端：不变服务器端：使用内部类增加多线程Client，重写run()、创建函数start(),main()函数中只有一句话，在start()中创建端口使其监听好，设置started为true，并设置BindException，再接收端口，调用Client类构造函数接受到流中的内容并bConnected = true;最后生成新的线程（在run()中进行）来读取流中的内容并打印出来，初步实现多客户端的功能 Chat1.1:客户端：不变服务器端：将客户端的信息通过服务端存储并发给每个客户端,但客户端没有接收 Chat1.2:客户端：利用多线程来接收发过来的字符串,后面再打印在TextArea上服务器端：不变 Chat1.3:客户端：不变服务器端：修正关闭一个客户端报错的问题,应当将去除的客户端从集合中删去,这时候移除的客户端应当是要发送的那个线程的客户端,此时客户端也就不会接收到信息,而不是当前客户端,删去的客户端应当要注意区分 学习的代码–&gt;源文件日后有机会将逐步完善]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度云加速的一些方式]]></title>
    <url>%2F2018%2F09%2FBaidu_cloud_acceleration%2F</url>
    <content type="text"><![CDATA[有常见的几种方式 1.Pan Download2.度盘下载器 DpDownload3.BaiduPCS-Go4.proxyee-down5.速盘详情可以参考：https://blog.csdn.net/tsvico/article/details/80659361 proxy-downgithub地址：https://github.com/proxyee-down-org/proxyee-down Pan Downloadgithub网址： https://github.com/Accelerider/BaiduPanDownloadWinform教程：http://pandownload.com/ 建议Pan Download易被屏蔽，建议采用其他方式，博主用的是proxy-down 效果 速盘SpeedPan现在还是用速盘感觉还行，其他方式不推荐了下载链接：https://www.weidown.com/xiazai/1448.html]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网学习]]></title>
    <url>%2F2018%2F09%2FJava_further_study%2F</url>
    <content type="text"><![CDATA[要每天都有收获 局部类匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。静态内部类不能直接访问外部类的非静态成员，但可以通过new外部类（）.成员的方式访问。 Collection接口 类方法有如下一些限制： 1 在类方法中不能引用对象变量。2 在类方法中不能使用super、this关键字。3 类方法不能调用类中的对象方法。与类方法相比，实例方法几乎没有什么限制：1 实例方法可以引用对象变量（这是显然的），也可以引用类变量。2 实例方法中可以使用super、this关键字。3 实例方法中可以调用类方法。 抽象类和接口特点:1.抽象类中可以构造方法2.抽象类中可以存在普通属性，方法，静态属性和方法。3.抽象类中可以存在抽象方法。4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。6,抽象类不能被实例化，抽象类和抽象方法必须被abstract修饰 关键字使用注意：抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。接口 1.在接口中只有方法的声明，没有方法体。2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final，接口中的变量默认是public static final 的，方法默认是public abstract 的3.在接口中的方法，永远都被public来修饰。4.接口中没有构造方法，也不能实例化接口的对象。（所以接口不能继承类）5.接口可以实现多继承6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。7.接口可以继承接口，用extends 构造过程class A{ static { System.out.println(“父类静态代码块”); } public A(){ System.out.println(“父类构造方法”); } { System.out.println(“父类初始化块”); }}public class B extends A{ static{ System.out.println(“子类静态代码块”); } public B(){ System.out.println(“子类构造方法”); } { System.out.println(“子类初始化块”); } public static void main(String[] args){ new B(); }}父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法； object类的方法： final final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。final修饰的方法不能被重写而不是重载！final修饰属性，此属性就是一个常量，不能被再次赋值！ for循环的执行顺序用如下表达式：for(expression1;expression2;expression3){expression4;}执行的顺序应该是：1）第一次循环，即初始化循环。首先执行表达式expression1（一般为初始化语句）；再执行expression2（一般为条件判断语句），判断expression1是否符合expression2的条件；如果符合，则执行expression4，否则，停止执行；最后执行expression3。 2）第N（N&gt;=2）次循环首先执行expression2，判断在expression3是否符合在expression2要求；如果符合，则继续执行在expression4，否则，停止执行。最后执行在expression3。如此往复，直至expression3不满足在expression2条件是为止。 总结：总的来说，执行的顺序是一致的。先条件判断（expression2），再函数体执行（expression4），最后for执行（expression3）。往复……区别在于，条件判断的对象。第一次判断时，对象为初始化语句（expression1），后续的判断对象为执行后的结果（expression3）。 volatile 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。而对该变量的修改，volatile并不提供原子性的保证。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况多线程下计数器必须使用锁保护。 BooleanBoolean修饰的变量为包装类型，初始化值为false,进行赋值时会调用Boolean.valueOf(boolean b)方法自动拆箱为基本数据类型，因此赋值后flag值为true，输出文本true。 如果使用==比较,则输出文本false。if的语句比较，除boolean外的其他类型都不能使用赋值语句，否则会提示无法转成布尔值。 String 类 finally语句块:结论：1、不管有木有出现异常，finally块中代码都会执行；2、当try和catch中有return时，finally仍然会执行；3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。举例：情况1：try{} catch(){}finally{} return;显然程序按顺序执行。 情况2:try{ return; }catch(){} finally{} return;程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，最后执行try中return;finally块之后的语句return，因为程序在try中已经return所以不再执行。 情况3:try{ } catch(){return;} finally{} return;程序先执行try，如果遇到异常执行catch块，有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，最后执行catch块中return. finally之后也就是4处的代码不再执行。无异常：执行完try再finally再return. 情况4:try{ return; }catch(){} finally{return;}程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 情况5:try{} catch(){return;}finally{return;}程序执行catch块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 情况6:try{ return;}catch(){return;} finally{return;}程序执行try块中return之前（包括return语句中的表达式运算）代码；有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；则再执行finally块，因为finally块中有return所以提前退出。无异常：则再执行finally块，因为finally块中有return所以提前退出。 最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。 Java表达式转型规则由低到高转换：1、所有的byte,short,char型的值将被提升为int型；2、如果有一个操作数是long型，计算结果是long型；3、如果有一个操作数是float型，计算结果是float型；4、如果有一个操作数是double型，计算结果是double型；5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化 Socket ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。Socket(InetAddress address , int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。 socket和servletSocket的交互如下图所示：参考链接 JSP内置对象1.request对象 客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。2.response对象 response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。3.session对象 session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.4.out对象 out对象是JspWriter类的实例,是向客户端输出内容常用的对象5.page对象 page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例6.application对象 application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。7.exception对象 exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象8.pageContext对象pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。9.config对象config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象） 面向对象五大基本原则五个基本原则：单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口 小点1.switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型 2.捕获到的异常不仅可以在当前方法中处理，还可以将异常抛给调用它的上一级方法来处理。 3.HashMap的底层是由数组加链表实现的，对于每一个key值，都需要计算哈希值，然后通过哈希值来确定顺序，并不是按照加入顺序来存放的，因此可以认为是无序的，但不管是有序还是无序，它都一个自己的顺序。故A错。最开始有Hashtable，Hashtable是不允许key和value的值为空的，但后来开发者认为有时候也会有key值为空的情况，因为可以允许null为空，通过查看HashMap的源代码就知道：if(key = null) {putForNullKey(value);};Map底层都是用key/value键值对的形式存放的 4.Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 L ist 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复5.public Method[] getDeclaredMethods()返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。public Method[] getMethods()返回类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。 6.0xFFFFFFFFFFFFFFFF 转为源码 = -1 7.URL u =new URL(http://www.123.com).如果 www.123.com 不存在，则返回 http://www.123.com 8.InputStreamReader可用于处理 Unicode，bufferedReader主要起装饰作用。 9.HashMap是线程安全的HashMapVector是线程安全的ArrayListTreeSet和LinkedList都不是线程安全的 10.Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 11.不同的编码之间是可以转换的，通常流程如下：将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。例：String newUTF8Str = new String(oldGBKStr.getBytes(“GBK”), “UTF8”); 12.Java虚拟机中通常使用UTF-16的方式保存一个字符 13.ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。 14.Math.cos为计算弧度的余弦值，Math.toRadians函数讲角度转换为弧度double d=Math.cos（Math.toDegrees（42）） 15.hashcode和equals的约定关系如下： 1、如果两个对象相等，那么他们一定有相同的哈希值（hash code）。 2、如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断） 16.加载驱动方法 1、Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); 2、 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 3、System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”); 17.运算符中优先级最高:口诀：淡云一笔安洛三福 单目&gt;算数运算符&gt;移位&gt;比较&gt;按位&gt;逻辑&gt;三目&gt;赋值 18.所有异常都是Exception的子类 19.String classFile = “com.jd.”. replaceAll(“.”, “/“) + “MyClass.class”;///////MyClass.class由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\.” 20.注解 Override 注解指明被注解的方法需要覆写超类中的方法.如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.Deprecated 注解可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。 个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。 当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。Suppresswarnings 注解可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。 21.两个数值进行二元操作时，会有如下的转换操作：如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，如果其中一个操作数是float类型，另一个将会转换为float类型。否则，如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。 22. 23.sleep()是Thread类中的方法，而wait()则是Object类中的方法。sleep()方法导致了程序暂停，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。wait()方法会导致线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。注意是准备获取对象锁进入运行状态，而不是立即获得 24.Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。 25.hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表进行锁定即让线程独享整张hash表，在安全同时造成了浪费。concurrentHashMap采用分段加锁的机制来确保安全 26.Properties 继承了Hashtable，因为Hashtable是线程安全的，所以Properties是线程安全的，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder，Arraylist是非线程安全的，其对应的线程安全类是Vector 27.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落后的vim简易设计]]></title>
    <url>%2F2018%2F09%2Fjava_entry_learning%2F</url>
    <content type="text"><![CDATA[还是要发点博客 暑假关于Java的学习主要是实现vim的简易功能，很简陋，以后有时间再更改 最终目标用Java实现简单的Vim编辑器功能为什么是Vim?Vim以其强大的功能在程序员中间被尊为编辑器之神。它设计为完全用键盘操纵电脑,减少了双手频繁地在鼠标和键盘间切换的时间,在你熟练掌握它之后,你的编辑效率将会成倍增加Vim是一款高度可定制的软件,它充分体现了自由的程序思想,你可以根据个人喜好,自由地改变Vim的行为,也可以使用别人的配置将Vim打造成强大的集成开发环境Vim几乎是处处可用的,在其它主流的编辑器中你也可以使用Vim的编辑模式,甚至于浏览器中都有Vim插件,你可以用Vim浏览网页在你远程登陆服务器修改代码时Vim几乎是唯一的选择(远程登陆服务器没有图形界面,无法使用鼠标)具体安排1.第一周:(基本字符串操作)按i进入编辑模式(文本可编辑),按esc进入普通模式(文本不可编辑,所有按键都是快捷键)普通模式中按h,j,k,l光标左,下,上,右移动(其中上下移动为难点)2.第二周:(IO流,文件操作)按w保存文件,但不退出按x保存并退出,未保存退出要有提示,提示显示在下方状态栏按dd删除一行按yy复制一行到粘贴板按p将粘贴板内容粘贴在下一行3.第三周:(多线程,网络操作,字符串高级操作)定时备份文件(尽力做) 远程编辑文件(这台电脑编辑另外一台电脑上的文件)按/匹配字符串(如/foo,匹配文本中的foo字符串)按/foo/foo1,用foo1替换所有foo字符串4.第四周:(高级功能,代码重构、完善、总结)(选做)宏录制:qa,开始记录键盘操作,并录入a寄存器中。再按q完成录制。再按@a,重复a中记录的动作没完成的功能继续完善减少重复代码,使用面向对象的设计方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365import javax.swing.*;import javax.swing.text.BadLocationException;import javax.swing.text.DefaultHighlighter;import javax.swing.text.Highlighter;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;class UpdateFile implements Runnable&#123; public void run() &#123; while(true)&#123; try&#123; String fname = "Write1.txt"; String childdir = "backup"; File f1,f2,child; f1 = new File(fname); child = new File(childdir); if(f1.exists()) &#123; if(!child.exists())&#123; child.mkdir(); &#125; f2 = new File(child, fname); if(!f2.exists()||f2.exists()&amp;&amp;(f1.lastModified() &gt; f2.lastModified())) &#123; copy(f1, f2); &#125; getinfo(f1); getinfo(child); &#125; else&#123; System.out.println(f1.getName() + " file not found!"); &#125; &#125;catch (IOException e)&#123; System.out.println("error"); &#125; try&#123; Thread.sleep(60000); &#125;catch(Exception e)&#123;&#125; &#125; &#125; public void copy(File f1, File f2) throws IOException&#123; FileInputStream rf = new FileInputStream(f1); FileOutputStream wf = new FileOutputStream(f2); int count,n = 512; byte buffer[] = new byte[n]; count = rf.read(buffer,0,n); while (count != -1) &#123; wf.write(buffer,0,count); count = rf.read(buffer,0,n); &#125; System.out.println("CopyFile " + f2.getName() + "!"); rf.close(); wf.close(); &#125; public static void getinfo(File f1) throws IOException&#123; SimpleDateFormat sdf; sdf = new SimpleDateFormat("yyyy年 MM 月 dd 日 hh 时 mm 分"); if(f1.isFile()) &#123; System.out.println("&lt;File&gt;\t" + f1.getAbsolutePath() + "\t" + f1.length() + "\t" + sdf.format(new Date())); &#125; else&#123; System.out.println("&lt;Dir&gt;\t" + f1.getAbsolutePath()); File[] files = f1.listFiles(); for(int i = 0;i&lt;files.length; i++) &#123; getinfo(files[i]); &#125; &#125; &#125;&#125;class Read&#123; String key="i 键被按下"; String word=" "; int d=0; int y=0; String psg = " "; Read(JTextArea ja) &#123; ja.addKeyListener(new KeyListener() &#123; public void keyPressed(KeyEvent e) &#123;&#125; public void keyTyped(KeyEvent e)&#123; int location = ja.getCaretPosition(); switch (e.getKeyChar()) &#123; case 'h': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" h 键被按下"); if (location==0) &#123;&#125; else ja.setCaretPosition(location - 1); &#125; break; &#125; case 'l': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" l键被按下"); mouse(ja, location, 'l',psg); &#125; break; &#125; case 'j': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" j键被按下"); mouse(ja, location, 'j',psg); &#125; break; &#125; case 'k': &#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" k键被按下"); mouse(ja, location, 'k',psg); &#125; break; &#125; case 'i': &#123; System.out.println("i 键被按下"); key = "i 键被按下"; ja.setEditable(true); break; &#125; case 'w': &#123; if (!key.equals("i 键被按下")) &#123; System.out.print("保存文件\n"); WriteInto(ja.getText()); word = "保存文件"; &#125; break; &#125; case 'x': &#123; if (!key.equals("i 键被按下")) &#123; System.out.print("保存文件并退出\n"); WriteInto(ja.getText()); System.exit(0); &#125; break; &#125; case KeyEvent.VK_ESCAPE: &#123; System.out.print("Esc键被按下\n"); key = "Esc键被按下"; ja.setEditable(false); break; &#125; case'd':&#123; d++; if (!key.equals("i 键被按下")&amp;&amp;d==2) &#123; System.out.println(" d键被按下"); mouse(ja, location, 'd',psg); d=0; &#125; break; &#125; case'y':&#123; y++; if (!key.equals("i 键被按下")&amp;&amp;y==2) &#123; System.out.println(" y键被按下"); psg = mouse(ja, location, 'y',psg); y=0; &#125; break; &#125; case'p':&#123; if (!key.equals("i 键被按下")) &#123; System.out.println(" p键被按下"); psg = mouse(ja, location, 'p',psg); &#125; break; &#125; case'/':&#123; Scanner s = new Scanner(System.in); String str = null; System.out.println("请输入您想输入的字符串："); str = s.nextLine(); HighLighter(ja,str); &#125; default: break; &#125; &#125; public void keyReleased(KeyEvent e) &#123;&#125; &#125;); &#125; public String mouse(JTextArea jas,int pos,char letter,String text)&#123; int lineOfC,aline,col; try &#123; //获取行数 lineOfC = jas.getLineOfOffset(pos);// 上面的字符总数 aline = jas.getLineStartOffset(lineOfC); //获取列数 col = pos - aline + 1;// System.out.println("当前光标位置" + lineOfC + "行 , " + col + " 列 "); switch (letter)&#123; case'l':&#123; if(pos==jas.getLineEndOffset(jas.getLineCount()-1)) &#123;&#125; else jas.setCaretPosition(pos+1); break; &#125; case'j':&#123; if(lineOfC == jas.getLineCount()-1)&#123;&#125; else&#123; int chance1 = jas.getLineEndOffset(lineOfC)-aline; int chance2 = jas.getLineEndOffset(lineOfC+1)-jas.getLineStartOffset(lineOfC+1); if(chance2 &gt; col) &#123; jas.setCaretPosition(pos+chance1); &#125; else&#123; jas.setCaretPosition(pos+chance2); &#125; &#125; break; &#125; case'k':&#123; if(lineOfC == 0)&#123;&#125; else&#123; int chance = jas.getLineEndOffset(lineOfC-1)-jas.getLineStartOffset(lineOfC-1); if(chance&gt;col)&#123; jas.setCaretPosition(pos-chance); &#125; else&#123; jas.setCaretPosition(pos-col); &#125; &#125; break; &#125; case'y':&#123; int chance = jas.getLineEndOffset(lineOfC)-aline; text=jas.getText(jas.getLineStartOffset(lineOfC),chance-1); return text; &#125; case'd':&#123; jas.replaceRange("",aline,jas.getLineEndOffset(lineOfC)); break; &#125; case'p':&#123; String tex=text+'\n'; jas.insert(tex,jas.getLineEndOffset(lineOfC)); return text; &#125; default: &#125; &#125; catch(Exception ex) &#123; System.out.println( "无法获得当前光标位置 "); &#125; return text; &#125; public void WriteInto(String line)&#123; try&#123; FileOutputStream fw = new FileOutputStream("Write1.txt");//向指定文本内写入 fw.write(line.getBytes()); fw.close(); System.out.println(); &#125;catch(Exception e)&#123;System.out.println("error");&#125; &#125; public String getKey() &#123; return key;&#125; public String getWord()&#123; return word;&#125; public void HighLighter(JTextArea ta, String keyWord)&#123; int key=0,i; String s="",s1=""; for(i=0;i&lt;keyWord.length();i++) &#123; if(keyWord.charAt(i)=='/') &#123; key=1; break; &#125; s1+=keyWord.charAt(i); &#125; Highlighter highLighter = ta.getHighlighter(); String text = ta.getText(); DefaultHighlighter.DefaultHighlightPainter p = new DefaultHighlighter.DefaultHighlightPainter(Color.RED); int pos = 0; if(key==0)&#123; while ((pos = text.indexOf(keyWord, pos)) &gt;= 0) &#123; try &#123; highLighter.addHighlight(pos, pos + keyWord.length(), p); pos += keyWord.length(); &#125; catch (BadLocationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; else&#123; for(int j=i+1;j&lt;keyWord.length();j++) &#123; s += keyWord.charAt(j); &#125; while ((pos = text.indexOf(s1, pos)) &gt;= 0) &#123; ta.replaceRange(s,pos,pos + s1.length()); pos += keyWord.length(); &#125; &#125; &#125;&#125;public class Vim implements WindowListener &#123; JTextField tB; JTextArea tA; Read a ; JFrame jf; public static void main(String[] args) &#123; Vim test = new Vim(); &#125; public Vim() &#123; String s = "hfciuwfoouierhf\nchbaohdfooequfh\ndsiuyfoogaerwiuyfooghui\nweichgengcheng\nfoohguewoiuryefoohalfhdfoohel\njhfiufooasergfure"; jf = new JFrame("Vim"); // 创建一个文本区域和一个文本框 tA = new JTextArea(s, 8, 8); tB = new JTextField(5); // 设置自动换行 tA.setLineWrap(true); // 添加到内容面板 JScrollPane scrollPane = new JScrollPane(tA); jf.add(scrollPane, BorderLayout.CENTER); jf.add(tB,BorderLayout.SOUTH); jf.setLocation(new Point(200, 200)); tA.setEditable(true); tB.setEditable(false); jf.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE); jf.addWindowListener(this);// 向文本对象添加窗口事件监听 jf.setVisible(true); jf.setSize(400, 400); a = new Read(tA); UpdateFile updateFile = new UpdateFile(); Thread a = new Thread(updateFile); a.start(); &#125; @Override public void windowActivated(WindowEvent e) &#123;&#125; @Override public void windowClosed(WindowEvent e) &#123;&#125; @Override public void windowClosing(WindowEvent e) &#123; if(a.getKey().equals("Esc键被按下")&amp;&amp;a.getWord().equals("保存文件"))&#123; System.exit(0);// 系统退出 &#125; else &#123; tB.setText(": 未保存"); &#125; &#125; @Override public void windowDeactivated(WindowEvent e) &#123;&#125; @Override public void windowDeiconified(WindowEvent e) &#123;&#125; @Override public void windowIconified(WindowEvent e) &#123;&#125; @Override public void windowOpened(WindowEvent e) &#123; tB.setText(": 窗口被激活"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2018%2F08%2Ffirst_hexo%2F</url>
    <content type="text"><![CDATA[你不能一直做一些烂事，然后自己后悔，好像后悔有用一样，你需要变好 想法 2017给了我很多最最美好的经历，目前对我最重要的年份是这一年,希望能继往开来希望自己能多给自己一些惊喜，少管些闲事，累了就休息，再也不失眠希望自己能跟着大佬学点东西，不要别人一张嘴你就一头雾水、一脸尴尬多看点书，学点东西，然后写一些对自己有用的博文 你要是无聊，它可以让你学不动，给你省了时间和金钱 计算机相关技术资料整理 https://github.com/EZLippi/practical-programming-books 编程书籍的整理和收集 https://github.com/KeKe-Li/book java 的书多一些 https://github.com/huangbaoquan/books 现在没太多时间读书，但可以整理一下，大家有好的链接不妨推荐一下放在这个博客中，方便以后有时间阅读寄语（鸡汤）没有不可治愈的伤痛，没有不能结束的沉沦，所有失去的，都会以另一种方式归来人生亦如逆旅，一切美好与温暖沉默如影，静立你的身后，不会迎头遇见，只要你不断走向远方，它便一路相随]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+nexT中的其他内容]]></title>
    <url>%2F2018%2F08%2Fhexo%2BnexT%2Bsomething%2F</url>
    <content type="text"><![CDATA[建议直接看最根本的东西 限于本人英语水平有限，建议大家直接到github上阅读相应的仓库获取最新知识，这样能避免很多错误，也不会被网上很多已经过时的东西影响。本人的版本： Theme versionversion: 5.1.4 hexo 版本 东拼西凑的东西每次输入都需要重新输入github帐号和密码？参考设置 SSH 使用 hexo deploy 时免输用户名密码设置好的状态： 版权声明之前的版本声明我觉得有点丑，除了有最新更新时间没有别的好处，而且那些声明明显落后于现在版本更新的速度，建议使用新版本里面的简洁声明 打开主题配置文件找到post_copyright1234post_copyright: enable: true #将false改成true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 设置gitment评论系统尝试过valine评论，但是决定作为程序员还是使用gitment比较好 最新版里面不需要添加配置文件只需要有app即可操作如下： 注册OAuth Application点击https://github.com/settings/applications/new注册参数说明：1234Application name： #应用名称Homepage URL： #网站URLApplication description #描述Authorization callback URL：#网站URL 修改themes/next/_config.yml在其中添加：12345678910111213141516# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: 不添加则跟随默认语言# Force language, or auto switch by theme跟随默认语言 github_user: Github名 # MUST HAVE, Your Github ID github_repo: .github.io的仓库 # MUST HAVE, The repo you use to store Gitment comments client_id: App id # MUST HAVE, Github client id for the Gitment client_secret: App secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 链接消除汉语在文章量不是很大的情况下建议直接设置链接的英文名，网上有相关教程我采用了转换，但是出了些小bug，但还能应付的过来 关于用自己的页面做页面请参考jacklightChenHexo-用自己的页面做首页 主题内添加相册功能（可能会出现卡顿）请参考asdfv1929Hexo NexT主题内添加相册功能 添加网页标题崩溃欺骗搞怪特效请参考asdfv1929Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效 添加加载效果打开主题配置文件搜索pace_theme看到下面这些效果，有很多种，挑选一个自己喜欢的就好了12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-loading-bar 最后 鉴于很多大佬都有相应的分享我就老老实实做一个搬运工，希望有更多人能有一个自己满意的博客网上有更多好的效果和实现方式欢迎与我交流 —-&gt;传送门]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github+ubuntu搭建个人博客]]></title>
    <url>%2F2018%2F08%2Fhexo%2Bhithub_pages%2BnexT%2F</url>
    <content type="text"><![CDATA[菜鸟初步搭建须知（是我没错，备忘）相应知识 会一些基本的Linux命令和vim的操作命令。可以在实验楼上入门学习 网上已经浏览了 官方文档 安装ubuntu和git（因为最近在学习用ubuntu，而且很多操作ubuntu上会更简单） 安装Node.js并拥有github账号 github上新建好一个专门的仓库，并最好熟悉github及其基本操作比如SSH密钥 以上知识网上有比较完善的信息，搜索关键字学习并进行必要的搭建前提已经完成下图： 建议大家选择不同的博客建站，可以参考有哪些好看的 Hexo 主题? 新手初步搭建可能有用搭建nexT主题可能有帮助的链接： https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.jianshu.com/p/a0a27d840992 https://www.jianshu.com/p/24cb74aeb0a3 http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 深入搭建，安装NexT主题Hexo 安装主题的方式非常简单，新建blog文档（命名随意）在其下打开终端操作即可，具体到 NexT 来说，安装步骤如下。 安装主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 具体还有以下步骤（自行网上搜索）： hexo init(第一次需要) hexo clean hexo g hexo s hexo d 启动主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件（官方文档中给出站点配置文件解释）， ctrl+f 搜索到 theme 字段，并将其值更改为 next，主题默认为landscape，建议选择Pisces或Gemini 1theme: next 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug，dubug会帮助你更好找到安装过程的错误），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 改动hexo 站点配置文件我们打开站点下的_config.yml文件 深入站点配置文件，事先变动RSS订阅 1.在hexo的根目录下执行命令： 1npm install hexo-generator-feed --save 2在根目录下的/theme/next/_config.yml文件中添加配置 123456feed: type: rss2 path: rss2.xml limit: 5 hub: content: 'true' 加入站点内容搜索功能 1.安装hexo-generator-searchdb 注意：安装时应在站点根目录下，即blog目录下 1$ npm install hexo-generator-searchdb --save 2.添加search字段，在站点blog/_config.yml中添加search字段，如下 12345search: path: search.xml field: post format: html limit: 10000 编辑远程部署 ，添加代码块 1234deploy: type: git repository: https://github.com/Thunderforrain/Thunderforrain.github.io.git branch: master 方便写博客，自动生成图片文档 1post_asset_folder: true 如果是flase 改成true 参考文章内添加图片 注意 : : 使用英文的，并且后面要有空格 执行完以上步骤，查找关键字来更改其他信息，最后结果大致如下(仅作最后的参考)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: Thunderforrain's Blog #网站标题subtitle: 实迷途其未远,觉今是而昨非 #网站副标题description: 菜鸟的 尝试，笨鸟的先飞 #网站描述keywords:author: Thunderforrain #博主的名字language: zh-Hans #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://thunderforrain.github.io/ ** #你网站的urlroot: /blog/ #子目录permalink: :year/:month/:day/:title/ #生成文件名字的格式permalink_defaults:# Directory 目录配置source_dir: source public_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章new_post_name: :title.md # File name of new posts （新建文章链接形式）default_layout: post # 默认布局（官方文档中给出其他布局）titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 render_drafts: false post_asset_folder: true #启动 Asset 文件夹,方便管理文章图片relative_link: false future: true highlight: #代码块设为true enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: # Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页（非全屏不显示）## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page search: path: search.xml field: post format: html limit: 10000# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next## Rss订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有) hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:Tenke007/Tenke007.github.io.git branch: master 改动hexo 主题配置文件建议参考网址，网上有比较好的教程:Never_yu’s Blog主题配置参考知了笔记Elegant theme for Hexo建议看一下我下一篇博客我们打开主题下的_config.yml文件 深入主题配置文件，里面可以添加很多东西（参考上述网址）： 在右上角或者左上角实现fork me on github 背景配置 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改“代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加Gitment评论系统 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 hexo 添加百度站长推送 hexo NexT主题首页title链接的优化 Hexo NexT主题修改文章标题样式 hexo 添加百度站长推送 参考上文知了笔记的hexo框架基于next主题定制 下文可作为理解帮助（仅作为最后的参考）:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexofavicon: ##网站的头像 small: /images/avatar.jpg medium: /images/avatar.jpg apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "记录耕耘"##网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml # 需要安装插件# Specify the date when the site was setupsince: 2015 网站时间，类似 2015-2016 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: #我的是自己设置可否评论，可以使用统一u形式，不同的评论方式不同 # ------------------------------------------------------------- # Hexo link (Powered by Hexo).#管理底部驱动信息，个人去了版本号 powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / categories: /categories #分类 tags: /tags #标签 archives: /archives #归档 #about: /about # 关于我 #sitemap: /sitemap.xml #这个可以不用开启，给搜索引擎用的，需要安装插件 #commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #上面menu的iconmenu_icons: enable: true home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next主题的三个schemes(默认是Muse)#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini #个人比较喜欢Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.#social: #社交链接，可以放github,weibo,qq等 GitHub: https://github.com/Thunderforrain || github CSDN: https://blog.csdn.net/Thunderforrain #微博: #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: #对应的社交icon enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo Wechat: wechat# Blog rolls #相关链接links_icon: linklinks_title: 友情链接links: git学习: http://github.phodal.com/ 馨客栈: http://www.mackxin.com/ CSL's Blog 的链接: http://cubercsl.cn/links/ jacklightChen's Blog: http://blog.lightina.cn/links_layout: block #Title: http://example.com/# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /images/avatar.jpg #博主头像（可以放外链）# Table Of Contents in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: #侧边栏，只对Pisces、Gemini有效 # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).像素菜单条边栏偏移量 offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: #设置为true,首页文章会显示 阅读全文，建议使用 &lt;!-- more --&gt; enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber #文章内显示微信二维码wechat_subscriber: enabled: true qcode: /images/wechat.png #微信二维码图片路径 description: 随便说点 #微信二维码描述#Reward #打赏功能，图片相应目录有或者外链reward_comment: 捐助菜鸡，提携笨鸟wechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on posts # 版权声明post_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme 代码高丽风格，个人喜欢默认版本# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: # ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key #第三方搜索（根据喜好选择，不举例了）#swiftype_key:# Baidu Analytics ID #百度分析#baidu_analytics:# Duoshuo ShortName #多说评论，已成为过去，不可使用duoshuo_shortname: tenke# Disqus #来必力评论#disqus_shortname:# changyan #畅言评论changyan: enable: false appid: appkey: # Hypercomments#hypercomments_id:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: #下面有东西，暂不举例，涉及隐私 # Gitment #需要github账号才能留言# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled:# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share #废弃duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: #弃用 ua_enable: true admin_enable: true user_id: admin_nickname: # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: #facebook相关 enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# --------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: #第三方用户访问插件，直接开启，根据喜好添加文字 # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp阅读数 page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search #自己添加# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0 #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-center-simple# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 最后一些想法1.科学上网（你懂的） 2.逐步升级博客（一次性弄好不现实） 3.先理解站点和主题配置文件（有些东西随着版本的更新，没有必要进行很麻烦的操作） 4.还有一部分东西可以自己查,希望对大家有所帮助 欢迎互加友情链接 ，互相交流—–&gt;传送门 一些博客实例： IIssNan’s NotesKevin Pu’s Blog Showo^^e吴小龙同學]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
